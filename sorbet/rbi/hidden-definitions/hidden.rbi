# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

class AbstractController::DoubleRenderError
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

module AbstractController::Rendering
  DEFAULT_PROTECTED_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
end

class Account
  def after_add_for_inbound_transfer_transactions(); end

  def after_add_for_inbound_transfer_transactions=(val); end

  def after_add_for_inbound_transfer_transactions?(); end

  def after_add_for_mtransactions(); end

  def after_add_for_mtransactions=(val); end

  def after_add_for_mtransactions?(); end

  def after_add_for_outbound_transfer_transactions(); end

  def after_add_for_outbound_transfer_transactions=(val); end

  def after_add_for_outbound_transfer_transactions?(); end

  def after_add_for_transaction_files(); end

  def after_add_for_transaction_files=(val); end

  def after_add_for_transaction_files?(); end

  def after_remove_for_inbound_transfer_transactions(); end

  def after_remove_for_inbound_transfer_transactions=(val); end

  def after_remove_for_inbound_transfer_transactions?(); end

  def after_remove_for_mtransactions(); end

  def after_remove_for_mtransactions=(val); end

  def after_remove_for_mtransactions?(); end

  def after_remove_for_outbound_transfer_transactions(); end

  def after_remove_for_outbound_transfer_transactions=(val); end

  def after_remove_for_outbound_transfer_transactions?(); end

  def after_remove_for_transaction_files(); end

  def after_remove_for_transaction_files=(val); end

  def after_remove_for_transaction_files?(); end

  def autosave_associated_records_for_inbound_transfer_transactions(*args); end

  def autosave_associated_records_for_mtransactions(*args); end

  def autosave_associated_records_for_outbound_transfer_transactions(*args); end

  def autosave_associated_records_for_transaction_files(*args); end

  def before_add_for_inbound_transfer_transactions(); end

  def before_add_for_inbound_transfer_transactions=(val); end

  def before_add_for_inbound_transfer_transactions?(); end

  def before_add_for_mtransactions(); end

  def before_add_for_mtransactions=(val); end

  def before_add_for_mtransactions?(); end

  def before_add_for_outbound_transfer_transactions(); end

  def before_add_for_outbound_transfer_transactions=(val); end

  def before_add_for_outbound_transfer_transactions?(); end

  def before_add_for_transaction_files(); end

  def before_add_for_transaction_files=(val); end

  def before_add_for_transaction_files?(); end

  def before_remove_for_inbound_transfer_transactions(); end

  def before_remove_for_inbound_transfer_transactions=(val); end

  def before_remove_for_inbound_transfer_transactions?(); end

  def before_remove_for_mtransactions(); end

  def before_remove_for_mtransactions=(val); end

  def before_remove_for_mtransactions?(); end

  def before_remove_for_outbound_transfer_transactions(); end

  def before_remove_for_outbound_transfer_transactions=(val); end

  def before_remove_for_outbound_transfer_transactions?(); end

  def before_remove_for_transaction_files(); end

  def before_remove_for_transaction_files=(val); end

  def before_remove_for_transaction_files?(); end

  def validate_associated_records_for_inbound_transfer_transactions(*args); end

  def validate_associated_records_for_mtransactions(*args); end

  def validate_associated_records_for_outbound_transfer_transactions(*args); end

  def validate_associated_records_for_transaction_files(*args); end
end

class Account::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Account::GeneratedRelationMethods
end

class Account::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Account::GeneratedRelationMethods
end

class Account::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Account::GeneratedRelationMethods
end

module Account::GeneratedAssociationMethods
  def inbound_transfer_transaction_ids(); end

  def inbound_transfer_transaction_ids=(ids); end

  def inbound_transfer_transactions(); end

  def inbound_transfer_transactions=(value); end

  def mtransaction_ids(); end

  def mtransaction_ids=(ids); end

  def outbound_transfer_transaction_ids(); end

  def outbound_transfer_transaction_ids=(ids); end

  def outbound_transfer_transactions(); end

  def outbound_transfer_transactions=(value); end

  def transaction_file_ids(); end

  def transaction_file_ids=(ids); end

  def transaction_files(); end

  def transaction_files=(value); end
end

module Account::GeneratedAttributeMethods
  extend ::Mutex_m
end

module Account::GeneratedRelationMethods
end

module Account::GeneratedRelationMethods
  extend ::Mutex_m
end

class Account
  def self.after_add_for_inbound_transfer_transactions(); end

  def self.after_add_for_inbound_transfer_transactions=(val); end

  def self.after_add_for_inbound_transfer_transactions?(); end

  def self.after_add_for_mtransactions(); end

  def self.after_add_for_mtransactions=(val); end

  def self.after_add_for_mtransactions?(); end

  def self.after_add_for_outbound_transfer_transactions(); end

  def self.after_add_for_outbound_transfer_transactions=(val); end

  def self.after_add_for_outbound_transfer_transactions?(); end

  def self.after_add_for_transaction_files(); end

  def self.after_add_for_transaction_files=(val); end

  def self.after_add_for_transaction_files?(); end

  def self.after_remove_for_inbound_transfer_transactions(); end

  def self.after_remove_for_inbound_transfer_transactions=(val); end

  def self.after_remove_for_inbound_transfer_transactions?(); end

  def self.after_remove_for_mtransactions(); end

  def self.after_remove_for_mtransactions=(val); end

  def self.after_remove_for_mtransactions?(); end

  def self.after_remove_for_outbound_transfer_transactions(); end

  def self.after_remove_for_outbound_transfer_transactions=(val); end

  def self.after_remove_for_outbound_transfer_transactions?(); end

  def self.after_remove_for_transaction_files(); end

  def self.after_remove_for_transaction_files=(val); end

  def self.after_remove_for_transaction_files?(); end

  def self.before_add_for_inbound_transfer_transactions(); end

  def self.before_add_for_inbound_transfer_transactions=(val); end

  def self.before_add_for_inbound_transfer_transactions?(); end

  def self.before_add_for_mtransactions(); end

  def self.before_add_for_mtransactions=(val); end

  def self.before_add_for_mtransactions?(); end

  def self.before_add_for_outbound_transfer_transactions(); end

  def self.before_add_for_outbound_transfer_transactions=(val); end

  def self.before_add_for_outbound_transfer_transactions?(); end

  def self.before_add_for_transaction_files(); end

  def self.before_add_for_transaction_files=(val); end

  def self.before_add_for_transaction_files?(); end

  def self.before_remove_for_inbound_transfer_transactions(); end

  def self.before_remove_for_inbound_transfer_transactions=(val); end

  def self.before_remove_for_inbound_transfer_transactions?(); end

  def self.before_remove_for_mtransactions(); end

  def self.before_remove_for_mtransactions=(val); end

  def self.before_remove_for_mtransactions?(); end

  def self.before_remove_for_outbound_transfer_transactions(); end

  def self.before_remove_for_outbound_transfer_transactions=(val); end

  def self.before_remove_for_outbound_transfer_transactions?(); end

  def self.before_remove_for_transaction_files(); end

  def self.before_remove_for_transaction_files=(val); end

  def self.before_remove_for_transaction_files?(); end
end

module ActionCable
  INTERNAL = ::T.let(nil, ::T.untyped)
end

class ActionCable::Channel::TestCase
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionCable::Channel::TestCase::Behavior
  include ::ActionCable::TestHelper
  def _channel_class(); end

  def _channel_class=(val); end

  def _channel_class?(); end

  def connection(); end

  def subscription(); end
end

module ActionCable::Channel::TestCase::Behavior
  include ::ActionCable::TestHelper
  def assert_broadcast_on(stream_or_object, *args); end

  def assert_broadcasts(stream_or_object, *args); end

  def assert_has_stream(stream); end

  def assert_has_stream_for(object); end

  def assert_no_streams(); end

  def perform(action, data=T.unsafe(nil)); end

  def stub_connection(identifiers=T.unsafe(nil)); end

  def subscribe(params=T.unsafe(nil)); end

  def transmissions(); end

  def unsubscribe(); end
  CHANNEL_IDENTIFIER = ::T.let(nil, ::T.untyped)
end

module ActionCable::Channel::TestCase::Behavior::ClassMethods
  def channel_class(); end

  def determine_default_channel(name); end

  def tests(channel); end
end

module ActionCable::Channel::TestCase::Behavior::ClassMethods
end

module ActionCable::Channel::TestCase::Behavior
  extend ::ActiveSupport::Concern
end

class ActionCable::Channel::TestCase
  extend ::ActionCable::Channel::TestCase::Behavior::ClassMethods
  def self._channel_class(); end

  def self._channel_class=(val); end

  def self._channel_class?(); end
end

module ActionCable::Connection::Assertions
  def assert_reject_connection(&block); end
end

module ActionCable::Connection::Assertions
end

class ActionCable::Connection::ClientSocket
  def alive?(); end

  def client_gone(); end

  def close(code=T.unsafe(nil), reason=T.unsafe(nil)); end

  def env(); end

  def initialize(env, event_target, event_loop, protocols); end

  def parse(data); end

  def protocol(); end

  def rack_response(); end

  def start_driver(); end

  def transmit(message); end

  def url(); end

  def write(data); end
  CLOSED = ::T.let(nil, ::T.untyped)
  CLOSING = ::T.let(nil, ::T.untyped)
  CONNECTING = ::T.let(nil, ::T.untyped)
  OPEN = ::T.let(nil, ::T.untyped)
end

class ActionCable::Connection::ClientSocket
  def self.determine_url(env); end

  def self.secure_request?(env); end
end

class ActionCable::Connection::MessageBuffer
  def append(message); end

  def initialize(connection); end

  def process!(); end

  def processing?(); end
end

class ActionCable::Connection::MessageBuffer
end

class ActionCable::Connection::Stream
  def close(); end

  def each(&callback); end

  def flush_write_buffer(); end

  def hijack_rack_socket(); end

  def initialize(event_loop, socket); end

  def receive(data); end

  def shutdown(); end

  def write(data); end
end

class ActionCable::Connection::Stream
end

class ActionCable::Connection::StreamEventLoop
  def attach(io, stream); end

  def detach(io, stream); end

  def post(task=T.unsafe(nil), &block); end

  def stop(); end

  def timer(interval, &block); end

  def writes_pending(io); end
end

class ActionCable::Connection::StreamEventLoop
end

class ActionCable::Connection::Subscriptions
  def add(data); end

  def execute_command(data); end

  def identifiers(); end

  def initialize(connection); end

  def logger(*args, &block); end

  def perform_action(data); end

  def remove(data); end

  def remove_subscription(subscription); end

  def unsubscribe_from_all(); end
end

class ActionCable::Connection::Subscriptions
end

class ActionCable::Connection::TaggedLoggerProxy
  def add_tags(*tags); end

  def debug(message); end

  def error(message); end

  def fatal(message); end

  def info(message); end

  def initialize(logger, tags:); end

  def tag(logger); end

  def tags(); end

  def unknown(message); end

  def warn(message); end
end

class ActionCable::Connection::TaggedLoggerProxy
end

class ActionCable::Connection::TestCase
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionCable::Connection::TestCase::Behavior
  include ::ActionCable::Connection::Assertions
  def _connection_class(); end

  def _connection_class=(val); end

  def _connection_class?(); end

  def connection(); end
end

module ActionCable::Connection::TestCase::Behavior
  include ::ActionCable::Connection::Assertions
  def connect(path=T.unsafe(nil), **request_params); end

  def cookies(); end

  def disconnect(); end
  DEFAULT_PATH = ::T.let(nil, ::T.untyped)
end

module ActionCable::Connection::TestCase::Behavior::ClassMethods
  def connection_class(); end

  def determine_default_connection(name); end

  def tests(connection); end
end

module ActionCable::Connection::TestCase::Behavior::ClassMethods
end

module ActionCable::Connection::TestCase::Behavior
  extend ::ActiveSupport::Concern
end

class ActionCable::Connection::TestCase
  extend ::ActionCable::Connection::TestCase::Behavior::ClassMethods
  def self._connection_class(); end

  def self._connection_class=(val); end

  def self._connection_class?(); end
end

class ActionCable::Connection::WebSocket
  def alive?(); end

  def close(); end

  def initialize(env, event_target, event_loop, protocols: T.unsafe(nil)); end

  def possible?(); end

  def protocol(); end

  def rack_response(); end

  def transmit(data); end
end

class ActionCable::Connection::WebSocket
end

class ActionCable::RemoteConnections
  def initialize(server); end

  def server(); end

  def where(identifier); end
end

class ActionCable::RemoteConnections::RemoteConnection
  include ::ActionCable::Connection::InternalChannel
  include ::ActionCable::Connection::Identification
  def disconnect(); end

  def identifiers(); end

  def identifiers=(val); end

  def identifiers?(); end

  def initialize(server, ids); end

  def server(); end
end

class ActionCable::RemoteConnections::RemoteConnection::InvalidIdentifiersError
end

class ActionCable::RemoteConnections::RemoteConnection::InvalidIdentifiersError
end

class ActionCable::RemoteConnections::RemoteConnection
  extend ::ActionCable::Connection::Identification::ClassMethods
  def self.identifiers(); end

  def self.identifiers=(val); end

  def self.identifiers?(); end
end

class ActionCable::RemoteConnections
end

module ActionCable::Server::Connections
  BEAT_INTERVAL = ::T.let(nil, ::T.untyped)
end

module ActionCable::SubscriptionAdapter
end

class ActionCable::SubscriptionAdapter::Async
end

class ActionCable::SubscriptionAdapter::Async
end

class ActionCable::SubscriptionAdapter::Base
  def broadcast(channel, payload); end

  def initialize(server); end

  def logger(); end

  def server(); end

  def shutdown(); end

  def subscribe(channel, message_callback, success_callback=T.unsafe(nil)); end

  def unsubscribe(channel, message_callback); end
end

class ActionCable::SubscriptionAdapter::Base
end

module ActionCable::SubscriptionAdapter::ChannelPrefix
  def broadcast(channel, payload); end

  def subscribe(channel, callback, success_callback=T.unsafe(nil)); end

  def unsubscribe(channel, callback); end
end

module ActionCable::SubscriptionAdapter::ChannelPrefix
end

class ActionCable::SubscriptionAdapter::Inline
  def initialize(*_); end

  def subscribe(channel, callback, success_callback=T.unsafe(nil)); end

  def unsubscribe(channel, callback); end
end

class ActionCable::SubscriptionAdapter::Inline
end

class ActionCable::SubscriptionAdapter::SubscriberMap
  def add_channel(channel, on_success); end

  def add_subscriber(channel, subscriber, on_success); end

  def broadcast(channel, message); end

  def invoke_callback(callback, message); end

  def remove_channel(channel); end

  def remove_subscriber(channel, subscriber); end
end

class ActionCable::SubscriptionAdapter::SubscriberMap
end

class ActionCable::SubscriptionAdapter::Test
  def broadcasts(channel); end

  def clear(); end

  def clear_messages(channel); end
end

class ActionCable::SubscriptionAdapter::Test
end

module ActionCable::SubscriptionAdapter
  extend ::ActiveSupport::Autoload
end

class ActionCable::TestCase
  include ::ActionCable::TestHelper
end

class ActionCable::TestCase
end

module ActionCable::TestHelper
  def after_teardown(); end

  def assert_broadcast_on(stream, data); end

  def assert_broadcasts(stream, number); end

  def assert_no_broadcasts(stream, &block); end

  def before_setup(); end

  def broadcasts(*args, &block); end

  def clear_messages(*args, &block); end

  def pubsub_adapter(); end
end

module ActionCable::TestHelper
end

module ActionCable::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class ActionController::API
  MODULES = ::T.let(nil, ::T.untyped)
end

class ActionController::Base
  MODULES = ::T.let(nil, ::T.untyped)
  PROTECTED_IVARS = ::T.let(nil, ::T.untyped)
end

module ActionController::DataStreaming
  DEFAULT_SEND_FILE_DISPOSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_SEND_FILE_TYPE = ::T.let(nil, ::T.untyped)
end

module ActionController::ForceSSL
  ACTION_OPTIONS = ::T.let(nil, ::T.untyped)
  REDIRECT_OPTIONS = ::T.let(nil, ::T.untyped)
  URL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActionController::HttpAuthentication::Token
  AUTHN_PAIR_DELIMITERS = ::T.let(nil, ::T.untyped)
  TOKEN_KEY = ::T.let(nil, ::T.untyped)
  TOKEN_REGEX = ::T.let(nil, ::T.untyped)
end

class ActionController::Live::SSE
  PERMITTED_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionController::LogSubscriber
  def exist_fragment?(event); end

  def expire_fragment(event); end

  def expire_page(event); end

  def halted_callback(event); end

  def process_action(event); end

  def read_fragment(event); end

  def redirect_to(event); end

  def send_data(event); end

  def send_file(event); end

  def start_processing(event); end

  def unpermitted_parameters(event); end

  def write_fragment(event); end

  def write_page(event); end
  INTERNAL_PARAMS = ::T.let(nil, ::T.untyped)
end

class ActionController::MiddlewareStack
  EXCLUDE = ::T.let(nil, ::T.untyped)
  INCLUDE = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
end

class ActionController::Parameters
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  PERMITTED_SCALAR_TYPES = ::T.let(nil, ::T.untyped)
end

module ActionController::ParamsWrapper
  EXCLUDE_PARAMETERS = ::T.let(nil, ::T.untyped)
end

class ActionController::Renderer
  DEFAULTS = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  RACK_KEY_TRANSLATION = ::T.let(nil, ::T.untyped)
  RACK_VALUE_TRANSLATION = ::T.let(nil, ::T.untyped)
end

module ActionController::Renderers
  RENDERERS = ::T.let(nil, ::T.untyped)
end

module ActionController::Rendering
  RENDER_FORMATS_IN_PRIORITY = ::T.let(nil, ::T.untyped)
end

module ActionController::RequestForgeryProtection
  AUTHENTICITY_TOKEN_LENGTH = ::T.let(nil, ::T.untyped)
  NULL_ORIGIN_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActionController::RespondToMismatchError
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActionController::SessionOverflowError
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActionController::TestRequest
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
  ENCODER = ::T.let(nil, ::T.untyped)
end

class ActionController::TestSession
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::AssertionResponse
  def code(); end

  def code_and_name(); end

  def initialize(code_or_name); end

  def name(); end
  GENERIC_RESPONSE_CODES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::AssertionResponse
end

module ActionDispatch::Assertions::ResponseAssertions
  RESPONSE_PREDICATES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::ContentSecurityPolicy::Middleware
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  POLICY = ::T.let(nil, ::T.untyped)
  POLICY_REPORT_ONLY = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::ContentSecurityPolicy::Request
  NONCE = ::T.let(nil, ::T.untyped)
  NONCE_DIRECTIVES = ::T.let(nil, ::T.untyped)
  NONCE_GENERATOR = ::T.let(nil, ::T.untyped)
  POLICY = ::T.let(nil, ::T.untyped)
  POLICY_REPORT_ONLY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Cookies
  AUTHENTICATED_ENCRYPTED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  COOKIES_DIGEST = ::T.let(nil, ::T.untyped)
  COOKIES_ROTATIONS = ::T.let(nil, ::T.untyped)
  COOKIES_SERIALIZER = ::T.let(nil, ::T.untyped)
  ENCRYPTED_COOKIE_CIPHER = ::T.let(nil, ::T.untyped)
  ENCRYPTED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  ENCRYPTED_SIGNED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  GENERATOR_KEY = ::T.let(nil, ::T.untyped)
  HTTP_HEADER = ::T.let(nil, ::T.untyped)
  MAX_COOKIE_SIZE = ::T.let(nil, ::T.untyped)
  SECRET_KEY_BASE = ::T.let(nil, ::T.untyped)
  SIGNED_COOKIE_DIGEST = ::T.let(nil, ::T.untyped)
  SIGNED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  USE_AUTHENTICATED_COOKIE_ENCRYPTION = ::T.let(nil, ::T.untyped)
  USE_COOKIES_WITH_METADATA = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Cookies::CookieJar
  include ::ActionDispatch::Cookies::ChainedCookieJars
  DOMAIN_REGEXP = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Cookies::SerializedCookieJars
  MARSHAL_SIGNATURE = ::T.let(nil, ::T.untyped)
end

ActionDispatch::Cookies::SerializedCookieJars::SERIALIZER = ActiveSupport::MessageEncryptor::NullSerializer

class ActionDispatch::DebugLocks
  def call(env); end

  def initialize(app, path=T.unsafe(nil)); end
end

class ActionDispatch::DebugLocks
end

class ActionDispatch::DebugView
  def debug_hash(object); end

  def debug_headers(headers); end

  def debug_params(params); end

  def initialize(assigns); end

  def params_valid?(); end

  def protect_against_forgery?(); end

  def render(*_); end
  RESCUES_TEMPLATE_PATH = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::DebugView
end

class ActionDispatch::Flash
  KEY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::HostAuthorization
  DEFAULT_RESPONSE_APP = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http
  include ::ActiveSupport::Deprecation::DeprecatedConstantAccessor
end

module ActionDispatch::Http::Cache::Request
  HTTP_IF_MODIFIED_SINCE = ::T.let(nil, ::T.untyped)
  HTTP_IF_NONE_MATCH = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::Cache::Response
  DATE = ::T.let(nil, ::T.untyped)
  DEFAULT_CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  LAST_MODIFIED = ::T.let(nil, ::T.untyped)
  MUST_REVALIDATE = ::T.let(nil, ::T.untyped)
  NO_CACHE = ::T.let(nil, ::T.untyped)
  PRIVATE = ::T.let(nil, ::T.untyped)
  PUBLIC = ::T.let(nil, ::T.untyped)
  SPECIAL_KEYS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Http::ContentDisposition
  RFC_5987_ESCAPED_CHAR = ::T.let(nil, ::T.untyped)
  TRADITIONAL_ESCAPED_CHAR = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::FilterParameters
  ENV_MATCH = ::T.let(nil, ::T.untyped)
  KV_RE = ::T.let(nil, ::T.untyped)
  NULL_ENV_FILTER = ::T.let(nil, ::T.untyped)
  NULL_PARAM_FILTER = ::T.let(nil, ::T.untyped)
  PAIR_RE = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::FilterRedirect
  FILTERED = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Http::Headers
  CGI_VARIABLES = ::T.let(nil, ::T.untyped)
  DEFAULT = ::T.let(nil, ::T.untyped)
  HTTP_HEADER = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::MimeNegotiation
  BROWSER_LIKE_ACCEPTS = ::T.let(nil, ::T.untyped)
  RESCUABLE_MIME_FORMAT_ERRORS = ::T.let(nil, ::T.untyped)
end

ActionDispatch::Http::ParameterFilter = ActiveSupport::ParameterFilter

module ActionDispatch::Http::Parameters
  DEFAULT_PARSERS = ::T.let(nil, ::T.untyped)
  PARAMETERS_KEY = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::URL
  HOST_REGEXP = ::T.let(nil, ::T.untyped)
  IP_HOST_REGEXP = ::T.let(nil, ::T.untyped)
  PROTOCOL_REGEXP = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Integration::Runner
  APP_SESSIONS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Integration::Session
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::Turbolinks::Assertions
  include ::ActionDispatch::Integration::RequestHelpers
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Format
  ESCAPE_PATH = ::T.let(nil, ::T.untyped)
  ESCAPE_SEGMENT = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Journey::Formatter::RegexCaseComparator
  DEFAULT_INPUT = ::T.let(nil, ::T.untyped)
  DEFAULT_REGEX = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::GTG::Builder
  DUMMY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Nodes::Symbol
  DEFAULT_EXP = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Parser
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Journey::Route::VerbMatchers
  VERBS = ::T.let(nil, ::T.untyped)
  VERB_TO_CLASS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Router::Utils
  ENCODER = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Router::Utils::UriEncoder
  ALPHA = ::T.let(nil, ::T.untyped)
  DEC2HEX = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ENCODE = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  SEGMENT = ::T.let(nil, ::T.untyped)
  SUB_DELIMS = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  US_ASCII = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Dot
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Each
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::FunctionalVisitor
  DISPATCH_CACHE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::String
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Visitor
  DISPATCH_CACHE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::RemoteIp
  TRUSTED_PROXIES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Request
  include ::ActionDispatch::Flash::RequestMethods
  ACTION_DISPATCH_REQUEST_ID = ::T.let(nil, ::T.untyped)
  ENV_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_LOOKUP = ::T.let(nil, ::T.untyped)
  LOCALHOST = ::T.let(nil, ::T.untyped)
  RFC2518 = ::T.let(nil, ::T.untyped)
  RFC2616 = ::T.let(nil, ::T.untyped)
  RFC3253 = ::T.let(nil, ::T.untyped)
  RFC3648 = ::T.let(nil, ::T.untyped)
  RFC3744 = ::T.let(nil, ::T.untyped)
  RFC4791 = ::T.let(nil, ::T.untyped)
  RFC5323 = ::T.let(nil, ::T.untyped)
  RFC5789 = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::RequestId
  X_REQUEST_ID = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Response
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE_PARSER = ::T.let(nil, ::T.untyped)
  LOCATION = ::T.let(nil, ::T.untyped)
  NO_CONTENT_CODES = ::T.let(nil, ::T.untyped)
  NullContentTypeHeader = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  SEPARATORS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper
  URL_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Constraints
  CALL = ::T.let(nil, ::T.untyped)
  SERVE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Mapping
  ANCHOR_CHARACTERS_REGEX = ::T.let(nil, ::T.untyped)
  JOINED_SEPARATORS = ::T.let(nil, ::T.untyped)
  OPTIONAL_FORMAT_REGEX = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::Resources
  CANONICAL_ACTIONS = ::T.let(nil, ::T.untyped)
  RESOURCE_OPTIONS = ::T.let(nil, ::T.untyped)
  VALID_ON_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Scope
  NULL = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  RESOURCE_METHOD_SCOPES = ::T.let(nil, ::T.untyped)
  RESOURCE_SCOPES = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::Scoping
  POISON = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::PathRedirect
  URL_PARTS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::RouteSet
  DEFAULT_CONFIG = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  RESERVED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::RouteSet::Generator
  PARAMETERIZE = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::RouteSet::MountedHelpers
  def _main_app(); end

  def main_app(); end
end

class ActionDispatch::Routing::RouteWrapper
  include ::Sprockets::Rails::RouteWrapper
  def assets_prefix(); end

  def assets_prefix=(val); end

  def assets_prefix?(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::RouteWrapper
  def self.assets_prefix(); end

  def self.assets_prefix=(val); end

  def self.assets_prefix?(); end
end

class ActionDispatch::Routing::RoutesProxy
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def _routes(); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def initialize(routes, scope, helpers, script_namer=T.unsafe(nil)); end

  def routes(); end

  def routes=(routes); end

  def scope(); end

  def scope=(scope); end
end

class ActionDispatch::Routing::RoutesProxy
  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end
end

class ActionDispatch::SSL
  def call(env); end

  def initialize(app, redirect: T.unsafe(nil), hsts: T.unsafe(nil), secure_cookies: T.unsafe(nil)); end
  HSTS_EXPIRES_IN = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::SSL
  def self.default_hsts_options(); end
end

class ActionDispatch::Session::CacheStore
  def delete_session(env, sid, options); end

  def write_session(env, sid, session, options); end
end

class ActionDispatch::Session::CacheStore
end

class ActionDispatch::Session::CookieStore::SessionId
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::ShowExceptions
  FAILSAFE_RESPONSE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::SystemTestCase
  include ::Capybara::DSL
  include ::Capybara::Minitest::Assertions
  include ::ActionDispatch::SystemTesting::TestHelpers::SetupAndTeardown
  include ::ActionDispatch::SystemTesting::TestHelpers::ScreenshotHelper
  def initialize(*_); end

  def method_missing(method, *args, &block); end
end

class ActionDispatch::SystemTestCase
  def self.driven_by(driver, using: T.unsafe(nil), screen_size: T.unsafe(nil), options: T.unsafe(nil), &capabilities); end

  def self.driver(); end

  def self.driver=(val); end

  def self.driver?(); end

  def self.start_application(); end
end

module ActionDispatch::SystemTesting::TestHelpers::ScreenshotHelper
  def take_failed_screenshot(); end

  def take_screenshot(); end
end

module ActionDispatch::SystemTesting::TestHelpers::ScreenshotHelper
end

module ActionDispatch::SystemTesting::TestHelpers::SetupAndTeardown
  def after_teardown(); end

  def before_setup(); end

  def before_teardown(); end

  def host!(host); end
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::SystemTesting::TestHelpers::SetupAndTeardown
end

class ActionDispatch::TestRequest
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::TestResponse
  def parsed_body(); end

  def response_parser(); end
end

class ActionDispatch::TestResponse
  def self.from_response(response); end
end

class ActionMailbox::Base
  include ::ActiveSupport::Rescuable
  include ::ActionMailbox::Routing
  include ::ActiveSupport::Callbacks
  include ::ActionMailbox::Callbacks
  def __callbacks(); end

  def __callbacks?(); end

  def _process_callbacks(); end

  def _run_process_callbacks(&block); end

  def bounce_with(message); end

  def bounced!(*args, &block); end

  def delivered!(*args, &block); end

  def finished_processing?(); end

  def inbound_email(); end

  def initialize(inbound_email); end

  def logger(*args, &block); end

  def mail(*args, &block); end

  def perform_processing(); end

  def process(); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end

  def router(); end

  def router=(obj); end
end

class ActionMailbox::Base
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._process_callbacks(); end

  def self._process_callbacks=(value); end

  def self.receive(inbound_email); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end

  def self.router(); end

  def self.router=(obj); end
end

module ActionMailbox::Callbacks
  TERMINATOR = ::T.let(nil, ::T.untyped)
end

module ActionMailbox::Callbacks
  extend ::ActiveSupport::Concern
end

class ActionMailbox::InboundEmail
  include ::ActionMailbox::InboundEmail::Routable
  include ::ActionMailbox::InboundEmail::MessageId
end

module ActionMailbox::InboundEmail::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActionMailbox::InboundEmail::GeneratedRelationMethods
  extend ::Mutex_m
end

class ActionMailbox::Router
  def add_route(address, to:); end

  def add_routes(routes); end

  def route(inbound_email); end
end

class ActionMailbox::Router::Route
  def address(); end

  def initialize(address, to:); end

  def mailbox_class(); end

  def mailbox_name(); end

  def match?(inbound_email); end
end

class ActionMailbox::Router::Route
end

class ActionMailbox::Router::RoutingError
end

class ActionMailbox::Router::RoutingError
end

class ActionMailbox::Router
end

module ActionMailbox::Routing
end

module ActionMailbox::Routing
  extend ::ActiveSupport::Concern
end

class ActionMailbox::TestCase
  include ::ActionMailbox::TestHelper
end

class ActionMailbox::TestCase
end

module ActionMailbox::TestHelper
  def create_inbound_email_from_fixture(fixture_name, status: T.unsafe(nil)); end

  def create_inbound_email_from_mail(status: T.unsafe(nil), **mail_options); end

  def create_inbound_email_from_source(source, status: T.unsafe(nil)); end

  def receive_inbound_email_from_fixture(*args); end

  def receive_inbound_email_from_mail(**kwargs); end

  def receive_inbound_email_from_source(*args); end
end

module ActionMailbox::TestHelper
end

class ActionMailer::Base
  PROTECTED_IVARS = ::T.let(nil, ::T.untyped)
end

class ActionMailer::Base::LateAttachmentsProxy
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionMailer::InlinePreviewInterceptor
  PATTERN = ::T.let(nil, ::T.untyped)
end

class ActionMailer::LogSubscriber
  def deliver(event); end

  def process(event); end

  def receive(event); end
end

class ActionMailer::MessageDelivery
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionMailer::Parameterized::MessageDelivery
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module ActionMailer::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionPack::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionText::Attachable
  LOCATOR_NAME = ::T.let(nil, ::T.untyped)
end

class ActionText::Attachables::ContentAttachment
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Conversion
  include ::ActiveModel::Model
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  def __callbacks(); end

  def __callbacks?(); end

  def _run_validate_callbacks(&block); end

  def _validate_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def attachable_plain_text_representation(caption); end

  def model_name(*args, &block); end

  def name(); end

  def name=(name); end

  def to_trix_content_attachment_partial_path(); end

  def validation_context(); end
end

class ActionText::Attachables::ContentAttachment
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Validations::HelperMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validators(); end

  def self._validators=(val); end

  def self._validators?(); end

  def self.from_node(node); end
end

module ActionText::Attachables::MissingAttachable
  def model_name(*args, &block); end
end

module ActionText::Attachables::MissingAttachable
  extend ::ActiveModel::Naming
  def self.to_partial_path(); end
end

class ActionText::Attachables::RemoteImage
  def attachable_plain_text_representation(caption); end

  def content_type(); end

  def height(); end

  def initialize(attributes=T.unsafe(nil)); end

  def model_name(*args, &block); end

  def to_partial_path(); end

  def url(); end

  def width(); end
end

class ActionText::Attachables::RemoteImage
  extend ::ActiveModel::Naming
  def self.from_node(node); end
end

class ActionText::Attachment
  include ::ActionText::Attachments::Caching
  include ::ActionText::Attachments::Minification
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SELECTOR = ::T.let(nil, ::T.untyped)
  TAG_NAME = ::T.let(nil, ::T.untyped)
end

class ActionText::AttachmentGallery
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Conversion
  include ::ActiveModel::Model
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  def __callbacks(); end

  def __callbacks?(); end

  def _run_validate_callbacks(&block); end

  def _validate_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def attachments(); end

  def initialize(node); end

  def model_name(*args, &block); end

  def node(); end

  def size(); end

  def validation_context(); end
end

class ActionText::AttachmentGallery
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Validations::HelperMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validators(); end

  def self._validators=(val); end

  def self._validators?(); end

  def self.find_attachment_gallery_nodes(content); end

  def self.fragment_by_canonicalizing_attachment_galleries(content); end

  def self.fragment_by_replacing_attachment_gallery_nodes(content); end

  def self.from_node(node); end
end

class ActionText::Fragment
  def find_all(selector); end

  def initialize(source); end

  def replace(selector); end

  def source(); end

  def to_html(); end

  def to_plain_text(); end

  def update(); end
end

class ActionText::Fragment
  def self.from_html(html); end

  def self.wrap(fragment_or_html); end
end

module ActionText::HtmlConversion
  def create_element(tag_name, attributes=T.unsafe(nil)); end

  def fragment_for_html(html); end

  def node_to_html(node); end
end

module ActionText::HtmlConversion
  extend ::ActionText::HtmlConversion
end

module ActionText::PlainTextConversion
  def node_to_plain_text(node); end
end

module ActionText::PlainTextConversion
  extend ::ActionText::PlainTextConversion
end

module ActionText::RichText::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActionText::RichText::GeneratedRelationMethods
  extend ::Mutex_m
end

class ActionText::TrixAttachment
  def attributes(); end

  def initialize(node); end

  def node(); end

  def to_html(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_TYPES = ::T.let(nil, ::T.untyped)
  COMPOSED_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SELECTOR = ::T.let(nil, ::T.untyped)
  TAG_NAME = ::T.let(nil, ::T.untyped)
end

class ActionText::TrixAttachment
  def self.from_attributes(attributes); end
end

module ActionView
  ENCODING_FLAG = ::T.let(nil, ::T.untyped)
end

class ActionView::AbstractRenderer::RenderedTemplate
  EMPTY_SPACER = ::T.let(nil, ::T.untyped)
end

class ActionView::Base
  include ::ActionView::Context
  include ::ERB::Util
  include ::ActionCable::Helpers::ActionCableHelper
  include ::Webpacker::Helper
  include ::Sprockets::Rails::Helper
  include ::Sprockets::Rails::Utils
  def assets_environment(); end

  def assets_environment=(val); end

  def assets_environment?(); end

  def assets_manifest(); end

  def assets_manifest=(val); end

  def assets_manifest?(); end

  def assets_precompile(); end

  def assets_precompile=(val); end

  def assets_precompile?(); end

  def assets_prefix(); end

  def assets_prefix=(val); end

  def assets_prefix?(); end

  def check_precompiled_asset(); end

  def check_precompiled_asset=(val); end

  def check_precompiled_asset?(); end

  def debug_assets(); end

  def debug_assets=(val); end

  def debug_assets?(); end

  def digest_assets(); end

  def digest_assets=(val); end

  def digest_assets?(); end

  def precompiled_asset_checker(); end

  def precompiled_asset_checker=(val); end

  def precompiled_asset_checker?(); end

  def resolve_assets_with(); end

  def resolve_assets_with=(val); end

  def resolve_assets_with?(); end

  def unknown_asset_fallback(); end

  def unknown_asset_fallback=(val); end

  def unknown_asset_fallback?(); end
  NULL = ::T.let(nil, ::T.untyped)
end

class ActionView::Base
  def self.assets_environment(); end

  def self.assets_environment=(val); end

  def self.assets_environment?(); end

  def self.assets_manifest(); end

  def self.assets_manifest=(val); end

  def self.assets_manifest?(); end

  def self.assets_precompile(); end

  def self.assets_precompile=(val); end

  def self.assets_precompile?(); end

  def self.assets_prefix(); end

  def self.assets_prefix=(val); end

  def self.assets_prefix?(); end

  def self.check_precompiled_asset(); end

  def self.check_precompiled_asset=(val); end

  def self.check_precompiled_asset?(); end

  def self.debug_assets(); end

  def self.debug_assets=(val); end

  def self.debug_assets?(); end

  def self.digest_assets(); end

  def self.digest_assets=(val); end

  def self.digest_assets?(); end

  def self.precompiled_asset_checker(); end

  def self.precompiled_asset_checker=(val); end

  def self.precompiled_asset_checker?(); end

  def self.resolve_assets_with(); end

  def self.resolve_assets_with=(val); end

  def self.resolve_assets_with?(); end

  def self.unknown_asset_fallback(); end

  def self.unknown_asset_fallback=(val); end

  def self.unknown_asset_fallback?(); end
end

class ActionView::DependencyTracker::ERBTracker
  EXPLICIT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  IDENTIFIER = ::T.let(nil, ::T.untyped)
  LAYOUT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  LAYOUT_HASH_KEY = ::T.let(nil, ::T.untyped)
  PARTIAL_HASH_KEY = ::T.let(nil, ::T.untyped)
  RENDER_ARGUMENTS = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  VARIABLE_OR_METHOD_CHAIN = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::AssetUrlHelper
  ASSET_EXTENSIONS = ::T.let(nil, ::T.untyped)
  ASSET_PUBLIC_DIRECTORIES = ::T.let(nil, ::T.untyped)
  URI_REGEXP = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::ControllerHelper
  CONTROLLER_DELEGATES = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::DateHelper
  MINUTES_IN_QUARTER_YEAR = ::T.let(nil, ::T.untyped)
  MINUTES_IN_THREE_QUARTERS_YEAR = ::T.let(nil, ::T.untyped)
  MINUTES_IN_YEAR = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::JavaScriptHelper
  JS_ESCAPE_MAP = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::TagHelper
  BOOLEAN_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  PRE_CONTENT_STRINGS = ::T.let(nil, ::T.untyped)
  TAG_PREFIXES = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::UrlHelper
  BUTTON_TAG_METHOD_VERBS = ::T.let(nil, ::T.untyped)
  STRINGIFIED_COMMON_METHODS = ::T.let(nil, ::T.untyped)
end

class ActionView::LogSubscriber
  def render_collection(event); end

  def render_partial(event); end

  def render_template(event); end
  EMPTY = ::T.let(nil, ::T.untyped)
  VIEWS_PATTERN = ::T.let(nil, ::T.untyped)
end

module ActionView::LookupContext::Accessors
  DEFAULT_PROCS = ::T.let(nil, ::T.untyped)
end

class ActionView::PartialRenderer
  include ::ActiveRecord::Railties::CollectionCacheAssociationLoading
  IDENTIFIER_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
  OPTION_AS_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
  PREFIXED_PARTIAL_NAMES = ::T.let(nil, ::T.untyped)
end

class ActionView::PathResolver
  DEFAULT_PATTERN = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class ActionView::Railtie
  NULL_OPTION = ::T.let(nil, ::T.untyped)
end

module ActionView::RecordIdentifier
  JOIN = ::T.let(nil, ::T.untyped)
  NEW = ::T.let(nil, ::T.untyped)
end

class ActionView::Resolver::Cache
  KEY_BLOCK = ::T.let(nil, ::T.untyped)
  NAME_BLOCK = ::T.let(nil, ::T.untyped)
  NO_TEMPLATES = ::T.let(nil, ::T.untyped)
  PARTIAL_BLOCK = ::T.let(nil, ::T.untyped)
  PREFIX_BLOCK = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Error
  SOURCE_CODE_RADIUS = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Handlers::ERB
  ENCODING_TAG = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Handlers::ERB::Erubi
  BLOCK_EXPR = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Handlers::LegacyHandlerWrapper
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Inline
  Finalizer = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::LegacyTemplate
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Sources::File
  def initialize(filename); end
end

class ActionView::Template::Sources::File
end

class ActionView::Template::Types::Type
  SET = ::T.let(nil, ::T.untyped)
end

class ActionView::TestCase
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::Turbolinks::Assertions
  include ::AbstractController::Helpers
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::UrlHelper
  include ::ActionView::Helpers::FormTagHelper
  include ::ActionView::Helpers::FormHelper
  include ::ActionView::Helpers::TranslationHelper
  include ::ActionView::Helpers
  include ::ActiveSupport::Benchmarkable
  include ::ActionView::Helpers::ActiveModelHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::ActionView::Helpers::AtomFeedHelper
  include ::ActionView::Helpers::CacheHelper
  include ::ActionView::Helpers::ControllerHelper
  include ::ActionView::Helpers::CspHelper
  include ::ActionView::Helpers::CsrfHelper
  include ::ActionView::Helpers::DateHelper
  include ::ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::JavaScriptHelper
  include ::ActionView::Helpers::NumberHelper
  include ::ActionView::Helpers::RenderingHelper
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionView::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionController::TemplateAssertions
  include ::ActionView::Context
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  include ::ActionView::RoutingUrlFor
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def _helper_methods(); end

  def _helper_methods=(val); end

  def _helper_methods?(); end

  def _helpers(); end

  def _helpers=(val); end

  def _helpers?(); end

  def debug_missing_translation(); end

  def debug_missing_translation=(obj); end
end

module ActionView::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionController::TemplateAssertions
  include ::ActionView::Context
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  include ::ActionView::RoutingUrlFor
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def _routes(); end

  def config(); end

  def controller(); end

  def controller=(controller); end

  def lookup_context(*args, &block); end

  def output_buffer(); end

  def output_buffer=(output_buffer); end

  def render(options=T.unsafe(nil), local_assigns=T.unsafe(nil), &block); end

  def rendered(); end

  def rendered=(rendered); end

  def rendered_views(); end

  def setup_with_controller(); end
  INTERNAL_IVARS = ::T.let(nil, ::T.untyped)
end

module ActionView::TestCase::Behavior::ClassMethods
  def determine_default_helper_class(name); end

  def helper_class(); end

  def helper_class=(helper_class); end

  def helper_method(*methods); end

  def new(*_); end

  def tests(helper_class); end
end

module ActionView::TestCase::Behavior::ClassMethods
end

module ActionView::TestCase::Behavior::Locals
  def render(options=T.unsafe(nil), local_assigns=T.unsafe(nil)); end

  def rendered_views(); end

  def rendered_views=(rendered_views); end
end

module ActionView::TestCase::Behavior::Locals
end

class ActionView::TestCase::Behavior::RenderedViewsCollection
  def add(view, locals); end

  def locals_for(view); end

  def rendered_views(); end

  def view_rendered?(view, expected_locals); end
end

class ActionView::TestCase::Behavior::RenderedViewsCollection
end

module ActionView::TestCase::Behavior
  extend ::ActiveSupport::Concern
end

class ActionView::TestCase::TestController
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  def controller_path=(path); end

  def initialize(); end

  def params=(params); end
end

class ActionView::TestCase::TestController
  def self.controller_path=(controller_path); end
end

class ActionView::TestCase
  extend ::AbstractController::Helpers::ClassMethods
  extend ::ActionView::TestCase::Behavior::ClassMethods
  def self._helper_methods(); end

  def self._helper_methods=(val); end

  def self._helper_methods?(); end

  def self._helpers(); end

  def self._helpers=(val); end

  def self._helpers?(); end

  def self.debug_missing_translation(); end

  def self.debug_missing_translation=(obj); end
end

module ActionView::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveJob::Arguments
  OBJECT_SERIALIZER_KEY = ::T.let(nil, ::T.untyped)
end

module ActiveJob::Callbacks
  extend ::ActiveSupport::Callbacks
end

class ActiveJob::ConfiguredJob
  def initialize(job_class, options=T.unsafe(nil)); end

  def perform_later(*args); end

  def perform_now(*args); end
end

class ActiveJob::ConfiguredJob
end

class ActiveJob::QueueAdapters::AsyncAdapter::Scheduler
  DEFAULT_EXECUTOR_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveJob::QueueAdapters::InlineAdapter
  def enqueue(job); end

  def enqueue_at(*_); end
end

class ActiveJob::QueueAdapters::InlineAdapter
end

class ActiveJob::QueueAdapters::TestAdapter
  def enqueue(job); end

  def enqueue_at(job, timestamp); end

  def enqueued_jobs(); end

  def enqueued_jobs=(enqueued_jobs); end

  def filter(); end

  def filter=(filter); end

  def perform_enqueued_at_jobs(); end

  def perform_enqueued_at_jobs=(perform_enqueued_at_jobs); end

  def perform_enqueued_jobs(); end

  def perform_enqueued_jobs=(perform_enqueued_jobs); end

  def performed_jobs(); end

  def performed_jobs=(performed_jobs); end

  def queue(); end

  def queue=(queue); end

  def reject(); end

  def reject=(reject); end
end

class ActiveJob::QueueAdapters::TestAdapter
end

class ActiveJob::TestCase
  include ::ActiveJob::TestHelper
end

class ActiveJob::TestCase
end

module ActiveJob::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveModel::AttributeMethods
  CALL_COMPILABLE_REGEXP = ::T.let(nil, ::T.untyped)
  NAME_COMPILABLE_REGEXP = ::T.let(nil, ::T.untyped)
end

class ActiveModel::AttributeMutationTracker
  OPTION_NOT_GIVEN = ::T.let(nil, ::T.untyped)
end

module ActiveModel::Attributes
  def attribute_names(); end

  def attributes(); end

  def initialize(*_); end
end

module ActiveModel::Attributes::ClassMethods
  def attribute(name, type=T.unsafe(nil), **options); end

  def attribute_names(); end
end

module ActiveModel::Attributes::ClassMethods
end

module ActiveModel::Attributes
  extend ::ActiveSupport::Concern
end

class ActiveModel::Errors
  CALLBACKS_OPTIONS = ::T.let(nil, ::T.untyped)
  MESSAGE_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActiveModel::Lint
end

module ActiveModel::Lint::Tests
  def test_errors_aref(); end

  def test_model_naming(); end

  def test_persisted?(); end

  def test_to_key(); end

  def test_to_param(); end

  def test_to_partial_path(); end
end

module ActiveModel::Lint::Tests
end

module ActiveModel::Lint
end

module ActiveModel::Model
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  def initialize(attributes=T.unsafe(nil)); end

  def persisted?(); end
end

module ActiveModel::Model
  extend ::ActiveSupport::Concern
end

module ActiveModel::SecurePassword
  MAX_PASSWORD_LENGTH_ALLOWED = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Boolean
  FALSE_VALUES = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Date
  ISO_DATE = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Decimal
  BIGDECIMAL_PRECISION = ::T.let(nil, ::T.untyped)
end

module ActiveModel::Type::Helpers::TimeValue
  ISO_DATETIME = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Integer
  DEFAULT_LIMIT = ::T.let(nil, ::T.untyped)
end

module ActiveModel::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::AttributeMethods
  RESTRICTED_CLASS_METHODS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Base::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActiveRecord::Batches
  ORDER_IGNORE_MESSAGE = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Callbacks
  CALLBACKS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Coders::YAMLColumn
  def assert_valid_value(obj, action:); end

  def dump(obj); end

  def initialize(attr_name, object_class=T.unsafe(nil)); end

  def load(yaml); end

  def object_class(); end

  def object_class=(object_class); end
end

class ActiveRecord::Coders::YAMLColumn
end

class ActiveRecord::ConcurrentMigrationError
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
  RELEASE_LOCK_FAILED_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter
  include ::ActiveRecord::ConnectionAdapters::SchemaStatements
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::ConnectionAdapters::DatabaseStatements
  ADAPTER_NAME = ::T.let(nil, ::T.untyped)
  SIMPLE_INT = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::SQLite3Adapter
  ADAPTER_NAME = ::T.let(nil, ::T.untyped)
  COLLATE_REGEX = ::T.let(nil, ::T.untyped)
  NATIVE_DATABASE_TYPES = ::T.let(nil, ::T.untyped)
end

ActiveRecord::ConnectionAdapters::SchemaCreation = ActiveRecord::ConnectionAdapters::AbstractAdapter::SchemaCreation

class ActiveRecord::ConnectionAdapters::StatementPool
  DEFAULT_STATEMENT_LIMIT = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::TransactionManager
  NULL_TRANSACTION = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::ConnectionHandling
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
  RAILS_ENV = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ExplainSubscriber
  EXPLAINED_SQLS = ::T.let(nil, ::T.untyped)
  IGNORED_PAYLOADS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::FinderMethods
  ONE_AS_ONE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::FixtureSet
  MAX_ID = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::InternalMetadata::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActiveRecord::InternalMetadata::GeneratedRelationMethods
  extend ::Mutex_m
end

class ActiveRecord::Locking::LockingType
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::LogSubscriber
  def backtrace_cleaner(); end

  def backtrace_cleaner=(val); end

  def backtrace_cleaner?(); end

  def sql(event); end
  IGNORE_PAYLOAD_NAMES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Middleware::DatabaseSelector
  def call(env); end

  def context_klass(); end

  def initialize(app, resolver_klass=T.unsafe(nil), context_klass=T.unsafe(nil), options=T.unsafe(nil)); end

  def options(); end

  def resolver_klass(); end
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver
  def context(); end

  def delay(); end

  def initialize(context, options=T.unsafe(nil)); end

  def instrumenter(); end

  def read(&blk); end

  def write(&blk); end
  SEND_TO_REPLICA_DELAY = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver::Session
  def initialize(session); end

  def last_write_timestamp(); end

  def session(); end

  def update_last_write_timestamp(); end
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver::Session
  def self.call(request); end

  def self.convert_time_to_timestamp(time); end

  def self.convert_timestamp_to_time(timestamp); end
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver
  def self.call(context, options=T.unsafe(nil)); end
end

class ActiveRecord::Middleware::DatabaseSelector
end

class ActiveRecord::Migration
  MigrationFilenameRegexp = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Migration::CommandRecorder
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::Migration::CommandRecorder::StraightReversions
  def add_belongs_to(*args, &block); end

  def add_column(*args, &block); end

  def add_foreign_key(*args, &block); end

  def add_index(*args, &block); end

  def add_reference(*args, &block); end

  def add_timestamps(*args, &block); end

  def change_column(*args, &block); end

  def change_column_comment(*args, &block); end

  def change_column_default(*args, &block); end

  def change_column_null(*args, &block); end

  def change_table(table_name, options=T.unsafe(nil)); end

  def change_table_comment(*args, &block); end

  def commands(); end

  def commands=(commands); end

  def create_join_table(*args, &block); end

  def create_table(*args, &block); end

  def delegate(); end

  def delegate=(delegate); end

  def disable_extension(*args, &block); end

  def drop_join_table(*args, &block); end

  def drop_table(*args, &block); end

  def enable_extension(*args, &block); end

  def execute(*args, &block); end

  def execute_block(*args, &block); end

  def initialize(delegate=T.unsafe(nil)); end

  def inverse_of(command, args, &block); end

  def invert_add_belongs_to(args, &block); end

  def invert_remove_belongs_to(args, &block); end

  def record(*command, &block); end

  def remove_belongs_to(*args, &block); end

  def remove_column(*args, &block); end

  def remove_columns(*args, &block); end

  def remove_foreign_key(*args, &block); end

  def remove_index(*args, &block); end

  def remove_reference(*args, &block); end

  def remove_timestamps(*args, &block); end

  def rename_column(*args, &block); end

  def rename_index(*args, &block); end

  def rename_table(*args, &block); end

  def replay(migration); end

  def revert(); end

  def reverting(); end

  def reverting=(reverting); end

  def transaction(*args, &block); end
  ReversibleAndIrreversibleMethods = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Migration::CommandRecorder::StraightReversions
  def invert_add_column(args, &block); end

  def invert_add_reference(args, &block); end

  def invert_add_timestamps(args, &block); end

  def invert_create_join_table(args, &block); end

  def invert_create_table(args, &block); end

  def invert_disable_extension(args, &block); end

  def invert_drop_join_table(args, &block); end

  def invert_drop_table(args, &block); end

  def invert_enable_extension(args, &block); end

  def invert_execute_block(args, &block); end

  def invert_remove_column(args, &block); end

  def invert_remove_reference(args, &block); end

  def invert_remove_timestamps(args, &block); end
end

module ActiveRecord::Migration::CommandRecorder::StraightReversions
end

class ActiveRecord::Migration::CommandRecorder
end

class ActiveRecord::Migrator
  MIGRATOR_SALT = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::NestedAttributes
  UNASSIGNABLE_KEYS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::QueryMethods
  DEFAULT_VALUES = ::T.let(nil, ::T.untyped)
  FROZEN_EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  FROZEN_EMPTY_HASH = ::T.let(nil, ::T.untyped)
  STRUCTURAL_OR_METHODS = ::T.let(nil, ::T.untyped)
  VALID_DIRECTIONS = ::T.let(nil, ::T.untyped)
  VALID_UNSCOPING_VALUES = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Querying
  QUERYING_METHODS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Reflection
  extend ::ActiveStorage::Reflection::ReflectionExtension
end

class ActiveRecord::Relation
  include ::ActiveRecord::Delegation
  include ::ActiveRecord::Explain
  include ::ActiveRecord::Batches
  include ::ActiveRecord::QueryMethods
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveRecord::SpawnMethods
  include ::ActiveRecord::Calculations
  CLAUSE_METHODS = ::T.let(nil, ::T.untyped)
  INVALID_METHODS_FOR_DELETE_ALL = ::T.let(nil, ::T.untyped)
  MULTI_VALUE_METHODS = ::T.let(nil, ::T.untyped)
  SINGLE_VALUE_METHODS = ::T.let(nil, ::T.untyped)
  VALUE_METHODS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Schema
  def define(info, &block); end
end

module ActiveRecord::SchemaMigration::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActiveRecord::SchemaMigration::GeneratedRelationMethods
  extend ::Mutex_m
end

module ActiveRecord::Tasks::DatabaseTasks
  LOCAL_HOSTS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Tasks::MySQLDatabaseTasks
  def charset(); end

  def collation(); end

  def connection(*args, &block); end

  def create(); end

  def drop(); end

  def establish_connection(*args, &block); end

  def initialize(configuration); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
  ER_DB_CREATE_EXISTS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Tasks::MySQLDatabaseTasks
end

class ActiveRecord::Tasks::PostgreSQLDatabaseTasks
  def charset(); end

  def clear_active_connections!(*args, &block); end

  def collation(); end

  def connection(*args, &block); end

  def create(master_established=T.unsafe(nil)); end

  def drop(); end

  def establish_connection(*args, &block); end

  def initialize(configuration); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
  DEFAULT_ENCODING = ::T.let(nil, ::T.untyped)
  ON_ERROR_STOP_1 = ::T.let(nil, ::T.untyped)
  SQL_COMMENT_BEGIN = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Tasks::PostgreSQLDatabaseTasks
end

class ActiveRecord::Tasks::SQLiteDatabaseTasks
  def charset(); end

  def connection(*args, &block); end

  def create(); end

  def drop(); end

  def establish_connection(*args, &block); end

  def initialize(configuration, root=T.unsafe(nil)); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
end

class ActiveRecord::Tasks::SQLiteDatabaseTasks
end

module ActiveRecord::Transactions
  ACTIONS = ::T.let(nil, ::T.untyped)
end

ActiveRecord::Type::BigInteger = ActiveModel::Type::BigInteger

ActiveRecord::Type::Binary = ActiveModel::Type::Binary

ActiveRecord::Type::Decimal = ActiveModel::Type::Decimal

ActiveRecord::Type::Float = ActiveModel::Type::Float

ActiveRecord::Type::Integer = ActiveModel::Type::Integer

class ActiveRecord::Type::Serialized
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

ActiveRecord::Type::String = ActiveModel::Type::String

class ActiveRecord::Type::Time::Value
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class ActiveStorage::Attached::Changes::CreateMany
  def attachables(); end

  def attachments(); end

  def blobs(); end

  def initialize(name, record, attachables); end

  def name(); end

  def record(); end

  def save(); end

  def upload(); end
end

class ActiveStorage::Attached::Changes::CreateMany
end

class ActiveStorage::Attached::Changes::CreateOne
  def attachable(); end

  def attachment(); end

  def blob(); end

  def initialize(name, record, attachable); end

  def name(); end

  def record(); end

  def save(); end

  def upload(); end
end

class ActiveStorage::Attached::Changes::CreateOne
end

class ActiveStorage::Attached::Changes::CreateOneOfMany
end

class ActiveStorage::Attached::Changes::CreateOneOfMany
end

class ActiveStorage::Attached::Changes::DeleteMany
  def attachables(); end

  def attachments(); end

  def blobs(); end

  def initialize(name, record); end

  def name(); end

  def record(); end

  def save(); end
end

class ActiveStorage::Attached::Changes::DeleteMany
end

class ActiveStorage::Attached::Changes::DeleteOne
  def attachment(); end

  def initialize(name, record); end

  def name(); end

  def record(); end

  def save(); end
end

class ActiveStorage::Attached::Changes::DeleteOne
end

module ActiveStorage::Attachment::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActiveStorage::Attachment::GeneratedRelationMethods
  extend ::Mutex_m
end

module ActiveStorage::Blob::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActiveStorage::Blob::GeneratedRelationMethods
  extend ::Mutex_m
end

class ActiveStorage::LogSubscriber
  def service_delete(event); end

  def service_delete_prefixed(event); end

  def service_download(event); end

  def service_exist(event); end

  def service_streaming_download(event); end

  def service_upload(event); end

  def service_url(event); end
end

class ActiveStorage::Transformers::Transformer
  def initialize(transformations); end

  def transform(file, format:); end

  def transformations(); end
end

class ActiveStorage::Transformers::Transformer
end

module ActiveStorage::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class ActiveStorage::Variant
  WEB_IMAGE_CONTENT_TYPES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::BacktraceCleaner
  FORMATTED_GEMS_PATTERN = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache
  UNIVERSAL_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::Entry
  DEFAULT_COMPRESS_LIMIT = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::FileStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
  def cache_path(); end

  def initialize(cache_path, options=T.unsafe(nil)); end
  DIR_FORMATTER = ::T.let(nil, ::T.untyped)
  FILENAME_MAX_SIZE = ::T.let(nil, ::T.untyped)
  FILEPATH_MAX_SIZE = ::T.let(nil, ::T.untyped)
  GITKEEP_FILES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::FileStore
  def self.supports_cache_versioning?(); end
end

class ActiveSupport::Cache::MemoryStore
  PER_ENTRY_OVERHEAD = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::NullStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
end

module ActiveSupport::Callbacks
  CALLBACK_FILTER_TYPES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Dependencies
  Reference = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Dependencies
  extend ::Bootsnap::LoadPathCache::CoreExt::ActiveSupport::ClassMethods
  extend ::ActiveSupport::Dependencies::ZeitwerkIntegration::Decorations
end

class ActiveSupport::Deprecation
  def deprecation_horizon(); end

  def deprecation_horizon=(deprecation_horizon); end

  def initialize(deprecation_horizon=T.unsafe(nil), gem_name=T.unsafe(nil)); end
  DEFAULT_BEHAVIORS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Deprecation::Reporting
  RAILS_GEM_ROOT = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Deprecation
  extend ::ActiveSupport::Deprecation::InstanceDelegator::OverrideDelegators
end

class ActiveSupport::Duration
  PARTS = ::T.let(nil, ::T.untyped)
  PARTS_IN_SECONDS = ::T.let(nil, ::T.untyped)
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
  SECONDS_PER_HOUR = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MINUTE = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MONTH = ::T.let(nil, ::T.untyped)
  SECONDS_PER_WEEK = ::T.let(nil, ::T.untyped)
  SECONDS_PER_YEAR = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Parser
  def initialize(string); end

  def mode(); end

  def mode=(mode); end

  def parse!(); end

  def parts(); end

  def scanner(); end

  def sign(); end

  def sign=(sign); end
  COMMA = ::T.let(nil, ::T.untyped)
  DATE_COMPONENT = ::T.let(nil, ::T.untyped)
  DATE_COMPONENTS = ::T.let(nil, ::T.untyped)
  DATE_MARKER = ::T.let(nil, ::T.untyped)
  DATE_TO_PART = ::T.let(nil, ::T.untyped)
  PERIOD = ::T.let(nil, ::T.untyped)
  PERIOD_OR_COMMA = ::T.let(nil, ::T.untyped)
  SIGN_MARKER = ::T.let(nil, ::T.untyped)
  TIME_COMPONENT = ::T.let(nil, ::T.untyped)
  TIME_COMPONENTS = ::T.let(nil, ::T.untyped)
  TIME_MARKER = ::T.let(nil, ::T.untyped)
  TIME_TO_PART = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Parser::ParsingError
end

class ActiveSupport::Duration::ISO8601Parser::ParsingError
end

class ActiveSupport::Duration::ISO8601Parser
end

class ActiveSupport::Duration::ISO8601Serializer
  def initialize(duration, precision: T.unsafe(nil)); end

  def serialize(); end
end

class ActiveSupport::Duration::ISO8601Serializer
end

class ActiveSupport::EncryptedFile
  CIPHER = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::ExecutionWrapper
  Null = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::JSON
  DATETIME_REGEX = ::T.let(nil, ::T.untyped)
  DATE_REGEX = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::LogSubscriber
  def colorize_logging(); end

  def colorize_logging=(obj); end

  def debug(progname=T.unsafe(nil), &block); end

  def error(progname=T.unsafe(nil), &block); end

  def fatal(progname=T.unsafe(nil), &block); end

  def info(progname=T.unsafe(nil), &block); end

  def logger(); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::MessageEncryptor
  include ::ActiveSupport::Messages::Rotator::Encryptor
  include ::ActiveSupport::Messages::Rotator
end

ActiveSupport::MessageEncryptor::OpenSSLCipherError = OpenSSL::Cipher::CipherError

class ActiveSupport::MessageVerifier
  include ::ActiveSupport::Messages::Rotator::Verifier
  include ::ActiveSupport::Messages::Rotator
end

module ActiveSupport::Multibyte::Unicode
  NORMALIZATION_FORMS = ::T.let(nil, ::T.untyped)
  NORMALIZATION_FORM_ALIASES = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberConverter
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToDelimitedConverter
  DEFAULT_DELIMITER_REGEX = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanConverter
  DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
  INVERTED_DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanSizeConverter
  STORAGE_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::ParameterFilter
  FILTERED = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::RangeWithFormat
  RANGE_FORMATS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::SafeBuffer
  UNSAFE_STRING_METHODS = ::T.let(nil, ::T.untyped)
  UNSAFE_STRING_METHODS_WITH_BACKREF = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Subscriber
  def finish(name, id, payload); end

  def patterns(); end

  def start(name, id, payload); end
end

class ActiveSupport::TestCase
  include ::Minitest::Parallel::Test
  include ::ActiveSupport::Testing::SetupAndTeardown
end

module ActiveSupport::Testing::Assertions
  UNTRACKED = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Testing::Isolation::Subprocess
  ORIG_ARGV = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Testing::Parallelization::Server
  include ::DRb::DRbUndumped
end

class ActiveSupport::TimeWithZone
  include ::DateAndTime::Compatibility
  PRECISIONS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::TimeZone
  MAPPING = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::XMLConverter
  DISALLOWED_TYPES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini
  DEFAULT_ENCODINGS = ::T.let(nil, ::T.untyped)
  FORMATTING = ::T.let(nil, ::T.untyped)
  PARSING = ::T.let(nil, ::T.untyped)
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini_REXML
  CONTENT_KEY = ::T.let(nil, ::T.untyped)
end

module Addressable::IDNA
  ACE_MAX_LENGTH = ::T.let(nil, ::T.untyped)
  ACE_PREFIX = ::T.let(nil, ::T.untyped)
  COMPOSITION_TABLE = ::T.let(nil, ::T.untyped)
  HANGUL_LBASE = ::T.let(nil, ::T.untyped)
  HANGUL_LCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_NCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SBASE = ::T.let(nil, ::T.untyped)
  HANGUL_SCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_TBASE = ::T.let(nil, ::T.untyped)
  HANGUL_TCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_VBASE = ::T.let(nil, ::T.untyped)
  HANGUL_VCOUNT = ::T.let(nil, ::T.untyped)
  PUNYCODE_BASE = ::T.let(nil, ::T.untyped)
  PUNYCODE_DAMP = ::T.let(nil, ::T.untyped)
  PUNYCODE_DELIMITER = ::T.let(nil, ::T.untyped)
  PUNYCODE_INITIAL_BIAS = ::T.let(nil, ::T.untyped)
  PUNYCODE_INITIAL_N = ::T.let(nil, ::T.untyped)
  PUNYCODE_MAXINT = ::T.let(nil, ::T.untyped)
  PUNYCODE_PRINT_ASCII = ::T.let(nil, ::T.untyped)
  PUNYCODE_SKEW = ::T.let(nil, ::T.untyped)
  PUNYCODE_TMAX = ::T.let(nil, ::T.untyped)
  PUNYCODE_TMIN = ::T.let(nil, ::T.untyped)
  UNICODE_DATA = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_CANONICAL = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_COMBINING_CLASS = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_COMPATIBILITY = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_EXCLUSION = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_LOWERCASE = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_TITLECASE = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_UPPERCASE = ::T.let(nil, ::T.untyped)
  UNICODE_MAX_LENGTH = ::T.let(nil, ::T.untyped)
  UNICODE_TABLE = ::T.let(nil, ::T.untyped)
  UTF8_REGEX = ::T.let(nil, ::T.untyped)
  UTF8_REGEX_MULTIBYTE = ::T.let(nil, ::T.untyped)
end

class Addressable::URI
  EMPTY_STR = ::T.let(nil, ::T.untyped)
  NORMPATH = ::T.let(nil, ::T.untyped)
  PARENT = ::T.let(nil, ::T.untyped)
  PORT_MAPPING = ::T.let(nil, ::T.untyped)
  RULE_2A = ::T.let(nil, ::T.untyped)
  RULE_2B_2C = ::T.let(nil, ::T.untyped)
  RULE_2D = ::T.let(nil, ::T.untyped)
  RULE_PREFIXED_PARENT = ::T.let(nil, ::T.untyped)
  SELF_REF = ::T.let(nil, ::T.untyped)
  SEQUENCE_ENCODING_TABLE = ::T.let(nil, ::T.untyped)
  SEQUENCE_UPCASED_PERCENT_ENCODING_TABLE = ::T.let(nil, ::T.untyped)
  SLASH = ::T.let(nil, ::T.untyped)
  URIREGEX = ::T.let(nil, ::T.untyped)
end

module Addressable::URI::CharacterClasses
  ALPHA = ::T.let(nil, ::T.untyped)
  AUTHORITY = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  GEN_DELIMS = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  PCHAR = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  SUB_DELIMS = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
end

module Addressable::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

class ApplicationRecord
  include ::ApplicationRecord::GeneratedAttributeMethods
  include ::ApplicationRecord::GeneratedAssociationMethods
end

class ApplicationRecord::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ApplicationRecord::GeneratedRelationMethods
end

class ApplicationRecord::ActiveRecord_AssociationRelation
end

class ApplicationRecord::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ApplicationRecord::GeneratedRelationMethods
end

class ApplicationRecord::ActiveRecord_Associations_CollectionProxy
end

class ApplicationRecord::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ApplicationRecord::GeneratedRelationMethods
end

class ApplicationRecord::ActiveRecord_Relation
end

module ApplicationRecord::GeneratedAssociationMethods
end

module ApplicationRecord::GeneratedAssociationMethods
end

module ApplicationRecord::GeneratedAttributeMethods
end

module ApplicationRecord::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ApplicationRecord::GeneratedRelationMethods
end

module ApplicationRecord::GeneratedRelationMethods
  extend ::Mutex_m
end

module Arel
  VERSION = ::T.let(nil, ::T.untyped)
end

Arel::Attribute = Arel::Attributes::Attribute

Arel::Node = Arel::Nodes::Node

class Arel::SelectManager
  STRING_OR_SYMBOL_CLASS = ::T.let(nil, ::T.untyped)
end

class Arel::Visitors::DepthFirst
  DISPATCH = ::T.let(nil, ::T.untyped)
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def abbrev(pattern=T.unsafe(nil)); end

  def bsearch(); end

  def bsearch_index(); end

  def collect!(); end

  def deconstruct(); end

  def dig(*_); end

  def flatten!(*_); end

  def intersection(*_); end

  def pack(fmt, buffer: T.unsafe(nil)); end

  def place(*values); end

  def quote(); end

  def replace(_); end

  def replace_each_string(&block); end

  def shelljoin(); end

  def to_csv(**options); end

  def to_h(); end

end

class Array
  def self.try_convert(_); end

  def self.wrap(object); end
end

class AwesomePrint::Formatter
  CORE = ::T.let(nil, ::T.untyped)
end

class AwesomePrint::Formatters::BaseFormatter
  DEFAULT_LIMIT_SIZE = ::T.let(nil, ::T.untyped)
end

class AwesomePrint::Inspector
  AP = ::T.let(nil, ::T.untyped)
end

module Backport
  VERSION = ::T.let(nil, ::T.untyped)
end

class Backport::Adapter
  def close(); end

  def closed?(); end

  def closing(); end

  def initialize(output, remote=T.unsafe(nil)); end

  def opening(); end

  def receiving(data); end

  def remote(); end

  def write(data); end

  def write_line(data); end
end

class Backport::Adapter
end

class Backport::Client
  include ::Observable
  def adapter(); end

  def initialize(input, output, adapter, remote=T.unsafe(nil)); end

  def run(); end

  def start(); end

  def stop(); end

  def stopped?(); end

  def tick(); end
end

class Backport::Client
end

class Backport::Machine
  def prepare(server); end

  def run(); end

  def servers(); end

  def stop(); end

  def stopped?(); end

  def update(server); end
end

class Backport::Machine
end

module Backport::Server
end

class Backport::Server::Base
  include ::Observable
  def start(); end

  def started?(); end

  def starting(); end

  def stop(); end

  def stopped?(); end

  def stopping(); end

  def tick(); end
end

class Backport::Server::Base
end

module Backport::Server::Connectable
  def clients(); end

  def starting(); end

  def stopping(); end
end

module Backport::Server::Connectable
end

class Backport::Server::Interval
  def initialize(period, &block); end
end

class Backport::Server::Interval
end

class Backport::Server::Stdio
  include ::Backport::Server::Connectable
  def initialize(input: T.unsafe(nil), output: T.unsafe(nil), adapter: T.unsafe(nil)); end

  def update(client); end
end

class Backport::Server::Stdio
end

class Backport::Server::Tcpip
  include ::Backport::Server::Connectable
  def accept(); end

  def initialize(host: T.unsafe(nil), port: T.unsafe(nil), adapter: T.unsafe(nil), socket_class: T.unsafe(nil)); end

  def update(client); end
end

class Backport::Server::Tcpip
end

module Backport::Server
end

BasicObject::BasicObject = BasicObject

class Benchmark::Job
  def initialize(width); end

  def item(label=T.unsafe(nil), &blk); end

  def list(); end

  def report(label=T.unsafe(nil), &blk); end

  def width(); end
end

class Benchmark::Report
  def initialize(width=T.unsafe(nil), format=T.unsafe(nil)); end

  def item(label=T.unsafe(nil), *format, &blk); end

  def list(); end

  def report(label=T.unsafe(nil), *format, &blk); end
end

class Benchmark::Tms
  def *(x); end

  def +(other); end

  def -(other); end

  def /(x); end

  def add(&blk); end

  def add!(&blk); end

  def cstime(); end

  def cutime(); end

  def format(format=T.unsafe(nil), *args); end

  def initialize(utime=T.unsafe(nil), stime=T.unsafe(nil), cutime=T.unsafe(nil), cstime=T.unsafe(nil), real=T.unsafe(nil), label=T.unsafe(nil)); end

  def label(); end

  def memberwise(op, x); end

  def real(); end

  def stime(); end

  def to_a(); end

  def total(); end

  def utime(); end
end

class BigDecimal
  include ::ActiveSupport::BigDecimalWithDefaultFormat
  include ::ActiveSupport::NumericWithFormat
  def clone(); end

  def to_d(); end

  def to_digits(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  SIGN_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.interpret_loosely(_); end
end

Bindex = Skiptrace

class Binding
  def clone(); end

  def irb(); end
end

module Bootsnap
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bootsnap::CompileCache::Uncompilable
end

class Bootsnap::CompileCache::Uncompilable
end

module Bootsnap::ExplicitRequire
  ARCHDIR = ::T.let(nil, ::T.untyped)
  DLEXT = ::T.let(nil, ::T.untyped)
  RUBYLIBDIR = ::T.let(nil, ::T.untyped)
end

module Bootsnap::LoadPathCache
  CACHED_EXTENSIONS = ::T.let(nil, ::T.untyped)
  DLEXT = ::T.let(nil, ::T.untyped)
  DLEXT2 = ::T.let(nil, ::T.untyped)
  DL_EXTENSIONS = ::T.let(nil, ::T.untyped)
  DOT_RB = ::T.let(nil, ::T.untyped)
  DOT_SO = ::T.let(nil, ::T.untyped)
  ERROR_TAG_IVAR = ::T.let(nil, ::T.untyped)
  SLASH = ::T.let(nil, ::T.untyped)
end

class Bootsnap::LoadPathCache::Cache
  AGE_THRESHOLD = ::T.let(nil, ::T.untyped)
  BUILTIN_FEATURES = ::T.let(nil, ::T.untyped)
end

class Bootsnap::LoadPathCache::Path
  RUBY_LIBDIR = ::T.let(nil, ::T.untyped)
  RUBY_SITEDIR = ::T.let(nil, ::T.untyped)
  STABLE = ::T.let(nil, ::T.untyped)
  VOLATILE = ::T.let(nil, ::T.untyped)
end

module Bootsnap::LoadPathCache::PathScanner
  ALL_FILES = ::T.let(nil, ::T.untyped)
  ALTERNATIVE_NATIVE_EXTENSIONS_PATTERN = ::T.let(nil, ::T.untyped)
  BUNDLE_PATH = ::T.let(nil, ::T.untyped)
  NORMALIZE_NATIVE_EXTENSIONS = ::T.let(nil, ::T.untyped)
  REQUIRABLE_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class Bundler::Dependency
  def branch(); end

  def expanded_platforms(); end

  def git(); end
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
  def link(dest); end
end

module Bundler::FileUtils
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end
end

class Bundler::GemHelper
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_command(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_input(cmd); end

  def sh_with_status(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

class Bundler::Molinillo::DependencyGraph
  include ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Vertex
  def _recursive_predecessors(vertices=T.unsafe(nil)); end

  def _recursive_successors(vertices=T.unsafe(nil)); end
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index
  def installed_plugins(); end

  def plugin_commands(plugin); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  def self.list(); end
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubygemsIntegration
  def add_to_load_path(paths); end

  def all_specs(); end

  def backport_ext_builder_monitor(); end

  def correct_for_windows_path(path); end

  def default_stubs(); end

  def find_name(name); end

  def gem_remote_fetcher(); end

  def plain_specs(); end

  def plain_specs=(specs); end

  def stub_rubygems(specs); end

  def use_gemdeps(gemfile); end
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::Source::Git
  def glob(); end
end

class Bundler::SpecSet
  include ::Enumerable
end

class Bundler::Thor
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Actions::CapturableERB
end

class Bundler::Thor::Actions::CapturableERB
end

module Bundler::Thor::Actions::ClassMethods
  def add_runtime_options!(); end

  def source_paths(); end

  def source_paths_for_search(); end

  def source_root(path=T.unsafe(nil)); end
end

module Bundler::Thor::Actions::ClassMethods
end

class Bundler::Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Bundler::Thor::Actions::CreateFile
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::Directory
  def execute!(); end

  def file_level_lookup(previous_lookup); end

  def files(lookup); end

  def initialize(base, source, destination=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def source(); end
end

class Bundler::Thor::Actions::Directory
end

class Bundler::Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Bundler::Thor::Actions::EmptyDirectory
end

class Bundler::Thor::Actions::InjectIntoFile
  def behavior(); end

  def flag(); end

  def initialize(base, destination, data, config); end

  def replace!(regexp, string, force); end

  def replacement(); end

  def say_status(behavior, warning: T.unsafe(nil), color: T.unsafe(nil)); end
end

class Bundler::Thor::Actions::InjectIntoFile
end

module Bundler::Thor::Actions
  def self.included(base); end
end

class Bundler::Thor::AmbiguousCommandError
end

class Bundler::Thor::AmbiguousCommandError
end

Bundler::Thor::AmbiguousTaskError = Bundler::Thor::AmbiguousCommandError

class Bundler::Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Argument
end

class Bundler::Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

module Bundler::Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Bundler::Thor::Base::ClassMethods
  def all_commands(); end

  def all_tasks(); end

  def allow_incompatible_default_type!(); end

  def argument(name, options=T.unsafe(nil)); end

  def arguments(); end

  def attr_accessor(*_); end

  def attr_reader(*_); end

  def attr_writer(*_); end

  def baseclass(); end

  def basename(); end

  def build_option(name, options, scope); end

  def build_options(options, scope); end

  def check_default_type(); end

  def check_default_type!(); end

  def check_unknown_options(); end

  def check_unknown_options!(); end

  def check_unknown_options?(config); end

  def class_option(name, options=T.unsafe(nil)); end

  def class_options(options=T.unsafe(nil)); end

  def class_options_help(shell, groups=T.unsafe(nil)); end

  def commands(); end

  def create_command(meth); end

  def create_task(meth); end

  def disable_required_check?(command_name); end

  def dispatch(command, given_args, given_opts, config); end

  def exit_on_failure?(); end

  def find_and_refresh_command(name); end

  def find_and_refresh_task(name); end

  def from_superclass(method, default=T.unsafe(nil)); end

  def group(name=T.unsafe(nil)); end

  def handle_argument_error(command, error, args, arity); end

  def handle_no_command_error(command, has_namespace=T.unsafe(nil)); end

  def handle_no_task_error(command, has_namespace=T.unsafe(nil)); end

  def inherited(klass); end

  def initialize_added(); end

  def is_thor_reserved_word?(word, type); end

  def method_added(meth); end

  def namespace(name=T.unsafe(nil)); end

  def no_commands(&block); end

  def no_commands?(); end

  def no_commands_context(); end

  def no_tasks(&block); end

  def print_options(shell, options, group_name=T.unsafe(nil)); end

  def public_command(*names); end

  def public_task(*names); end

  def remove_argument(*names); end

  def remove_class_option(*names); end

  def remove_command(*names); end

  def remove_task(*names); end

  def start(given_args=T.unsafe(nil), config=T.unsafe(nil)); end

  def stop_on_unknown_option?(command_name); end

  def strict_args_position(); end

  def strict_args_position!(); end

  def strict_args_position?(config); end

  def tasks(); end
end

module Bundler::Thor::Base::ClassMethods
end

module Bundler::Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Bundler::Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, usage, options=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Command
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def values_at(*indices); end
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
end

module Bundler::Thor::CoreExt
end

Bundler::Thor::Correctable = DidYouMean::Correctable

class Bundler::Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Bundler::Thor::DynamicCommand
end

Bundler::Thor::DynamicTask = Bundler::Thor::DynamicCommand

class Bundler::Thor::Error
end

class Bundler::Thor::Error
end

class Bundler::Thor::Group
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Bundler::Thor::Group
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*_); end

  def self.printable_tasks(*_); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Bundler::Thor::HiddenCommand
end

class Bundler::Thor::HiddenCommand
end

Bundler::Thor::HiddenTask = Bundler::Thor::HiddenCommand

module Bundler::Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Bundler::Thor::Invocation::ClassMethods
  def prepare_for_invocation(key, name); end
end

module Bundler::Thor::Invocation::ClassMethods
end

module Bundler::Thor::Invocation
  def self.included(base); end
end

class Bundler::Thor::InvocationError
end

class Bundler::Thor::InvocationError
end

module Bundler::Thor::LineEditor
end

class Bundler::Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Bundler::Thor::LineEditor::Basic
  def self.available?(); end
end

class Bundler::Thor::LineEditor::Readline
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
end

class Bundler::Thor::LineEditor::Readline
end

module Bundler::Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Bundler::Thor::NestedContext
end

class Bundler::Thor::NoKwargSpellChecker
  def initialize(dictionary); end
end

class Bundler::Thor::NoKwargSpellChecker
end

class Bundler::Thor::Option
  def aliases(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Option
  def self.parse(key, value); end
end

class Bundler::Thor::Options
  def assign_result!(option, result); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Options
  def self.to_switches(options); end
end

module Bundler::Thor::RakeCompat
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Bundler::Thor::RakeCompat
  def self.included(base); end

  def self.rake_classes(); end
end

class Bundler::Thor::RequiredArgumentMissingError
end

class Bundler::Thor::RequiredArgumentMissingError
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
  def answer_match(possibilities, answer, case_insensitive); end

  def as_unicode(); end

  def ask(statement, *args); end

  def ask_filtered(statement, color, options); end

  def ask_simply(statement, color, options); end

  def base(); end

  def base=(base); end

  def can_display_colors?(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def error(statement); end

  def file_collision(destination); end

  def file_collision_help(); end

  def git_merge_tool(); end

  def indent(count=T.unsafe(nil)); end

  def is?(value); end

  def lookup_color(color); end

  def merge(destination, content); end

  def merge_tool(); end

  def mute(); end

  def mute?(); end

  def no?(statement, color=T.unsafe(nil)); end

  def padding(); end

  def padding=(value); end

  def prepare_message(message, *color); end

  def print_in_columns(array); end

  def print_table(array, options=T.unsafe(nil)); end

  def print_wrapped(message, options=T.unsafe(nil)); end

  def quiet?(); end

  def say(message=T.unsafe(nil), color=T.unsafe(nil), force_new_line=T.unsafe(nil)); end

  def say_status(status, message, log_status=T.unsafe(nil)); end

  def set_color(string, *_); end

  def show_diff(destination, content); end

  def stderr(); end

  def stdout(); end

  def terminal_width(); end

  def truncate(string, width); end

  def unix?(); end

  def yes?(statement, color=T.unsafe(nil)); end
  DEFAULT_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
end

class Bundler::Thor::Shell::Color
  def are_colors_disabled?(); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Color
end

class Bundler::Thor::Shell::HTML
  def ask(statement, color=T.unsafe(nil)); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::HTML
end

module Bundler::Thor::Shell
end

Bundler::Thor::Task = Bundler::Thor::Command

class Bundler::Thor::UndefinedCommandError
  include ::DidYouMean::Correctable
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
end

class Bundler::Thor::UndefinedCommandError
end

Bundler::Thor::UndefinedTaskError = Bundler::Thor::UndefinedCommandError

class Bundler::Thor::UnknownArgumentError
  include ::DidYouMean::Correctable
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
end

class Bundler::Thor::UnknownArgumentError
end

module Bundler::Thor::Util
end

module Bundler::Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Bundler::Thor
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ABS_URI_REF = ::T.let(nil, ::T.untyped)
  DEFAULT_PARSER = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  OPAQUE = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  REL_URI_REF = ::T.let(nil, ::T.untyped)
  RFC3986_PARSER = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TBLDECWWWCOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCWWWCOMP_ = ::T.let(nil, ::T.untyped)
  UNSAFE = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_CODE = ::T.let(nil, ::T.untyped)
  WEB_ENCODINGS_ = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::BadURIError
end

class Bundler::URI::BadURIError
end

class Bundler::URI::Error
end

class Bundler::URI::Error
end

module Bundler::URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

module Bundler::URI::Escape
end

class Bundler::URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  TYPECODE = ::T.let(nil, ::T.untyped)
  TYPECODE_PREFIX = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class Bundler::URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::File
end

class Bundler::URI::Generic
  include ::Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  USE_REGISTRY = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::Generic
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_proxy?(hostname, addr, port, no_proxy); end

  def self.use_registry(); end
end

class Bundler::URI::HTTP
  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTP
end

class Bundler::URI::HTTPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTPS
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  SCOPE = ::T.let(nil, ::T.untyped)
  SCOPE_BASE = ::T.let(nil, ::T.untyped)
  SCOPE_ONE = ::T.let(nil, ::T.untyped)
  SCOPE_SUB = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAP
end

class Bundler::URI::LDAPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAPS
end

class Bundler::URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EMAIL_REGEXP = ::T.let(nil, ::T.untyped)
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::MailTo
end

Bundler::URI::Parser = Bundler::URI::RFC2396_Parser

Bundler::URI::REGEXP = Bundler::URI::RFC2396_REGEXP

class Bundler::URI::RFC2396_Parser
  include ::Bundler::URI::RFC2396_REGEXP
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class Bundler::URI::RFC2396_Parser
end

module Bundler::URI::RFC2396_REGEXP
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ALNUM = ::T.let(nil, ::T.untyped)
  ALPHA = ::T.let(nil, ::T.untyped)
  DOMLABEL = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HEX = ::T.let(nil, ::T.untyped)
  HIER_PART = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  HOSTNAME = ::T.let(nil, ::T.untyped)
  HOSTPORT = ::T.let(nil, ::T.untyped)
  IPV4ADDR = ::T.let(nil, ::T.untyped)
  IPV6ADDR = ::T.let(nil, ::T.untyped)
  IPV6REF = ::T.let(nil, ::T.untyped)
  NET_PATH = ::T.let(nil, ::T.untyped)
  OPAQUE_PART = ::T.let(nil, ::T.untyped)
  PATH_SEGMENTS = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REG_NAME = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_SEGMENT = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TOPLABEL = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  URIC = ::T.let(nil, ::T.untyped)
  URIC_NO_SLASH = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  X_ABS_URI = ::T.let(nil, ::T.untyped)
  X_REL_URI = ::T.let(nil, ::T.untyped)
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
end

module Bundler::URI::RFC2396_REGEXP
end

class Bundler::URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_URI = ::T.let(nil, ::T.untyped)
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::RFC3986_Parser
end

module Bundler::URI::Util
end

module Bundler::URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module Bundler::URI
  extend ::Bundler::URI::Escape
  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.decode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.extract(str, schemes=T.unsafe(nil), &block); end

  def self.get_encoding(label); end

  def self.join(*str); end

  def self.parse(uri); end

  def self.regexp(schemes=T.unsafe(nil)); end

  def self.scheme_list(); end

  def self.split(uri); end
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module Bundler
  def self.original_exec(*args); end

  def self.original_system(*args); end

  def self.unbundled_env(); end

  def self.unbundled_exec(*args); end

  def self.unbundled_system(*args); end

  def self.with_unbundled_env(); end
end

module Byebug
  PORT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoirbSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutolistSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoprySetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutosaveSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::CallstyleSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::Command
  extend ::Byebug::Helpers::StringHelper
end

class Byebug::Context
  extend ::Byebug::Helpers::PathHelper
end

class Byebug::FullpathSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HistfileSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HistsizeSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::ListsizeSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::LocalInterface
  EOF_ALIAS = ::T.let(nil, ::T.untyped)
end

class Byebug::Printers::Base
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Byebug::SavefileSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::Setting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::ThreadsTable
end

class Byebug::ThreadsTable
end

class Byebug::WidthSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

class CSV
  def add_row(row); end

  def binmode(*args, &block); end

  def binmode?(); end

  def close(*args, &block); end

  def close_read(*args, &block); end

  def close_write(*args, &block); end

  def closed?(*args, &block); end

  def col_sep(); end

  def convert(name=T.unsafe(nil), &converter); end

  def converters(); end

  def each(&block); end

  def encoding(); end

  def eof(); end

  def eof?(); end

  def external_encoding(*args, &block); end

  def fcntl(*args, &block); end

  def field_size_limit(); end

  def fileno(*args, &block); end

  def flock(*args); end

  def flush(*args, &block); end

  def force_quotes?(); end

  def fsync(*args, &block); end

  def gets(); end

  def header_convert(name=T.unsafe(nil), &converter); end

  def header_converters(); end

  def header_row?(); end

  def headers(); end

  def internal_encoding(*args, &block); end

  def ioctl(*args); end

  def isatty(*args, &block); end

  def liberal_parsing?(); end

  def line(); end

  def lineno(); end

  def path(); end

  def pid(*args, &block); end

  def pos(*args, &block); end

  def pos=(*args, &block); end

  def puts(row); end

  def quote_char(); end

  def readlines(); end

  def reopen(*args, &block); end

  def return_headers?(); end

  def rewind(); end

  def row_sep(); end

  def seek(*args, &block); end

  def shift(); end

  def skip_blanks?(); end

  def skip_lines(); end

  def stat(*args); end

  def string(*args, &block); end

  def sync(*args, &block); end

  def sync=(*args, &block); end

  def tell(*args, &block); end

  def to_i(); end

  def to_io(); end

  def truncate(*args, &block); end

  def tty?(*args, &block); end

  def unconverted_fields?(); end

  def write_headers?(); end
  ConverterEncoding = ::T.let(nil, ::T.untyped)
  Converters = ::T.let(nil, ::T.untyped)
  DateMatcher = ::T.let(nil, ::T.untyped)
  DateTimeMatcher = ::T.let(nil, ::T.untyped)
  HeaderConverters = ::T.let(nil, ::T.untyped)
end

class CSV::FieldInfo
  def header(); end

  def header=(_); end

  def index(); end

  def index=(_); end

  def line(); end

  def line=(_); end
end

class CSV::FieldInfo
  def self.[](*_); end

  def self.members(); end
end

class CSV::FieldsConverter
  include ::Enumerable
  def add_converter(name=T.unsafe(nil), &converter); end

  def convert(fields, headers, lineno); end

  def each(&block); end

  def empty?(); end

  def initialize(options=T.unsafe(nil)); end
end

class CSV::FieldsConverter
end

class CSV::MalformedCSVError
  def initialize(message, line_number); end

  def line_number(); end

  def lineno(); end
end

class CSV::Parser
  def column_separator(); end

  def field_size_limit(); end

  def header_row?(); end

  def headers(); end

  def initialize(input, options); end

  def liberal_parsing?(); end

  def line(); end

  def lineno(); end

  def parse(&block); end

  def quote_character(); end

  def return_headers?(); end

  def row_separator(); end

  def skip_blanks?(); end

  def skip_lines(); end

  def unconverted_fields?(); end

  def use_headers?(); end
  SCANNER_TEST = ::T.let(nil, ::T.untyped)
end

class CSV::Parser::InputsScanner
  def each_line(row_separator); end

  def eos?(); end

  def initialize(inputs, encoding, chunk_size: T.unsafe(nil)); end

  def keep_back(); end

  def keep_drop(); end

  def keep_end(); end

  def keep_start(); end

  def rest(); end

  def scan(pattern); end

  def scan_all(pattern); end
end

class CSV::Parser::InputsScanner
end

class CSV::Parser::InvalidEncoding
end

class CSV::Parser::InvalidEncoding
end

class CSV::Parser::Scanner
  def each_line(row_separator); end

  def initialize(*args); end

  def keep_back(); end

  def keep_drop(); end

  def keep_end(); end

  def keep_start(); end

  def scan_all(_); end
end

class CSV::Parser::Scanner
end

class CSV::Parser
end

class CSV::Row
  def <<(arg); end

  def ==(other); end

  def [](header_or_index, minimum_index=T.unsafe(nil)); end

  def []=(*args); end

  def delete(header_or_index, minimum_index=T.unsafe(nil)); end

  def delete_if(&block); end

  def dig(index_or_header, *indexes); end

  def each(&block); end

  def each_pair(&block); end

  def empty?(*args, &block); end

  def fetch(header, *varargs); end

  def field(header_or_index, minimum_index=T.unsafe(nil)); end

  def field?(data); end

  def field_row?(); end

  def fields(*headers_and_or_indices); end

  def has_key?(header); end

  def header?(header); end

  def header_row?(); end

  def headers(); end

  def include?(header); end

  def index(header, minimum_index=T.unsafe(nil)); end

  def initialize(headers, fields, header_row=T.unsafe(nil)); end

  def key?(header); end

  def length(*args, &block); end

  def member?(header); end

  def push(*args); end

  def row(); end

  def size(*args, &block); end

  def to_ary(*_); end

  def to_csv(**options); end

  def to_h(); end

  def to_hash(); end

  def to_s(**options); end

  def values_at(*headers_and_or_indices); end
end

class CSV::Row
  extend ::Forwardable
end

class CSV::Table
  def <<(row_or_array); end

  def ==(other); end

  def [](index_or_header); end

  def []=(index_or_header, value); end

  def by_col(); end

  def by_col!(); end

  def by_col_or_row(); end

  def by_col_or_row!(); end

  def by_row(); end

  def by_row!(); end

  def delete(*indexes_or_headers); end

  def delete_if(&block); end

  def dig(index_or_header, *index_or_headers); end

  def each(&block); end

  def empty?(*args, &block); end

  def headers(); end

  def initialize(array_of_rows, headers: T.unsafe(nil)); end

  def length(*args, &block); end

  def mode(); end

  def push(*rows); end

  def size(*args, &block); end

  def table(); end

  def to_a(); end

  def to_csv(write_headers: T.unsafe(nil), **options); end

  def to_s(write_headers: T.unsafe(nil), **options); end

  def values_at(*indices_or_headers); end
end

class CSV::Table
  extend ::Forwardable
end

class CSV::Writer
  def <<(row); end

  def headers(); end

  def initialize(output, options); end

  def lineno(); end

  def rewind(); end
end

class CSV::Writer
end

class CSV
  extend ::Forwardable
  def self.filter(input=T.unsafe(nil), output=T.unsafe(nil), **options); end

  def self.generate_line(row, **options); end

  def self.instance(data=T.unsafe(nil), **options); end

  def self.open(filename, mode=T.unsafe(nil), **options); end

  def self.readlines(path, **options); end

  def self.table(path, **options); end
end

module Capybara
  VERSION = ::T.let(nil, ::T.untyped)
end

class Capybara::Config
  OPTIONS = ::T.let(nil, ::T.untyped)
end

module Capybara::DSL
  def accept_alert(*args, &block); end

  def accept_confirm(*args, &block); end

  def accept_prompt(*args, &block); end

  def all(*args, &block); end

  def assert_all_of_selectors(*args, &block); end

  def assert_any_of_selectors(*args, &block); end

  def assert_current_path(*args, &block); end

  def assert_no_current_path(*args, &block); end

  def assert_no_selector(*args, &block); end

  def assert_no_text(*args, &block); end

  def assert_no_title(*args, &block); end

  def assert_none_of_selectors(*args, &block); end

  def assert_selector(*args, &block); end

  def assert_text(*args, &block); end

  def assert_title(*args, &block); end

  def attach_file(*args, &block); end

  def body(*args, &block); end

  def check(*args, &block); end

  def choose(*args, &block); end

  def click_button(*args, &block); end

  def click_link(*args, &block); end

  def click_link_or_button(*args, &block); end

  def click_on(*args, &block); end

  def current_host(*args, &block); end

  def current_path(*args, &block); end

  def current_scope(*args, &block); end

  def current_url(*args, &block); end

  def current_window(*args, &block); end

  def dismiss_confirm(*args, &block); end

  def dismiss_prompt(*args, &block); end

  def evaluate_script(*args, &block); end

  def execute_script(*args, &block); end

  def fill_in(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_button(*args, &block); end

  def find_by_id(*args, &block); end

  def find_field(*args, &block); end

  def find_link(*args, &block); end

  def first(*args, &block); end

  def go_back(*args, &block); end

  def go_forward(*args, &block); end

  def has_button?(*args, &block); end

  def has_checked_field?(*args, &block); end

  def has_content?(*args, &block); end

  def has_css?(*args, &block); end

  def has_current_path?(*args, &block); end

  def has_field?(*args, &block); end

  def has_link?(*args, &block); end

  def has_no_button?(*args, &block); end

  def has_no_checked_field?(*args, &block); end

  def has_no_content?(*args, &block); end

  def has_no_css?(*args, &block); end

  def has_no_current_path?(*args, &block); end

  def has_no_field?(*args, &block); end

  def has_no_link?(*args, &block); end

  def has_no_select?(*args, &block); end

  def has_no_selector?(*args, &block); end

  def has_no_table?(*args, &block); end

  def has_no_text?(*args, &block); end

  def has_no_title?(*args, &block); end

  def has_no_unchecked_field?(*args, &block); end

  def has_no_xpath?(*args, &block); end

  def has_select?(*args, &block); end

  def has_selector?(*args, &block); end

  def has_table?(*args, &block); end

  def has_text?(*args, &block); end

  def has_title?(*args, &block); end

  def has_unchecked_field?(*args, &block); end

  def has_xpath?(*args, &block); end

  def html(*args, &block); end

  def open_new_window(*args, &block); end

  def page(); end

  def query(*args, &block); end

  def refresh(*args, &block); end

  def refute_selector(*args, &block); end

  def reset_session!(*args, &block); end

  def response_headers(*args, &block); end

  def save_and_open_page(*args, &block); end

  def save_and_open_screenshot(*args, &block); end

  def save_page(*args, &block); end

  def save_screenshot(*args, &block); end

  def scroll_by(*args, &block); end

  def scroll_to(*args, &block); end

  def select(*args, &block); end

  def source(*args, &block); end

  def status_code(*args, &block); end

  def switch_to_frame(*args, &block); end

  def switch_to_window(*args, &block); end

  def text(*args, &block); end

  def title(*args, &block); end

  def uncheck(*args, &block); end

  def unselect(*args, &block); end

  def using_session(name_or_session, &block); end

  def using_wait_time(seconds, &block); end

  def visit(*args, &block); end

  def window_opened_by(*args, &block); end

  def windows(*args, &block); end

  def within(*args, &block); end

  def within_element(*args, &block); end

  def within_fieldset(*args, &block); end

  def within_frame(*args, &block); end

  def within_table(*args, &block); end

  def within_window(*args, &block); end
end

module Capybara::DSL
  def self.extended(base); end

  def self.included(base); end
end

module Capybara::Minitest
end

module Capybara::Minitest::Assertions
  def assert_all_of_selectors(*args, &optional_filter_block); end

  def assert_ancestor(*args, &optional_filter_block); end

  def assert_any_of_selectors(*args, &optional_filter_block); end

  def assert_button(*args, &optional_filter_block); end

  def assert_checked_field(*args, &optional_filter_block); end

  def assert_content(*args); end

  def assert_css(*args, &optional_filter_block); end

  def assert_current_path(*args); end

  def assert_field(*args, &optional_filter_block); end

  def assert_link(*args, &optional_filter_block); end

  def assert_matches_css(*args, &optional_filter_block); end

  def assert_matches_selector(*args, &optional_filter_block); end

  def assert_matches_style(*args, &optional_filter_block); end

  def assert_matches_xpath(*args, &optional_filter_block); end

  def assert_no_ancestor(*args, &optional_filter_block); end

  def assert_no_button(*args, &optional_filter_block); end

  def assert_no_checked_field(*args, &optional_filter_block); end

  def assert_no_content(*args); end

  def assert_no_css(*args, &optional_filter_block); end

  def assert_no_current_path(*args); end

  def assert_no_field(*args, &optional_filter_block); end

  def assert_no_link(*args, &optional_filter_block); end

  def assert_no_select(*args, &optional_filter_block); end

  def assert_no_selector(*args, &optional_filter_block); end

  def assert_no_sibling(*args, &optional_filter_block); end

  def assert_no_table(*args, &optional_filter_block); end

  def assert_no_text(*args); end

  def assert_no_title(*args); end

  def assert_no_unchecked_field(*args, &optional_filter_block); end

  def assert_no_xpath(*args, &optional_filter_block); end

  def assert_none_of_selectors(*args, &optional_filter_block); end

  def assert_not_matches_css(*args, &optional_filter_block); end

  def assert_not_matches_selector(*args, &optional_filter_block); end

  def assert_not_matches_xpath(*args, &optional_filter_block); end

  def assert_select(*args, &optional_filter_block); end

  def assert_selector(*args, &optional_filter_block); end

  def assert_sibling(*args, &optional_filter_block); end

  def assert_table(*args, &optional_filter_block); end

  def assert_text(*args); end

  def assert_title(*args); end

  def assert_unchecked_field(*args, &optional_filter_block); end

  def assert_xpath(*args, &optional_filter_block); end

  def refute_ancestor(*args, &optional_filter_block); end

  def refute_button(*args, &optional_filter_block); end

  def refute_checked_field(*args, &optional_filter_block); end

  def refute_content(*args); end

  def refute_css(*args, &optional_filter_block); end

  def refute_current_path(*args); end

  def refute_field(*args, &optional_filter_block); end

  def refute_link(*args, &optional_filter_block); end

  def refute_matches_css(*args, &optional_filter_block); end

  def refute_matches_selector(*args, &optional_filter_block); end

  def refute_matches_xpath(*args, &optional_filter_block); end

  def refute_select(*args, &optional_filter_block); end

  def refute_selector(*args, &optional_filter_block); end

  def refute_sibling(*args, &optional_filter_block); end

  def refute_table(*args, &optional_filter_block); end

  def refute_text(*args); end

  def refute_title(*args); end

  def refute_unchecked_field(*args, &optional_filter_block); end

  def refute_xpath(*args, &optional_filter_block); end
end

module Capybara::Minitest::Assertions
end

module Capybara::Minitest
end

module Capybara::Node::Actions
  CAPTURE_FILE_ELEMENT_SCRIPT = ::T.let(nil, ::T.untyped)
  DATALIST_OPTIONS_SCRIPT = ::T.let(nil, ::T.untyped)
  RESET_STYLE_SCRIPT = ::T.let(nil, ::T.untyped)
  UPDATE_STYLE_SCRIPT = ::T.let(nil, ::T.untyped)
end

class Capybara::Node::Element
  STYLE_SCRIPT = ::T.let(nil, ::T.untyped)
end

class Capybara::Node::Simple
  VISIBILITY_XPATH = ::T.let(nil, ::T.untyped)
end

class Capybara::Queries::BaseQuery
  COUNT_KEYS = ::T.let(nil, ::T.untyped)
end

class Capybara::Queries::SelectorQuery
  SPATIAL_KEYS = ::T.let(nil, ::T.untyped)
  VALID_KEYS = ::T.let(nil, ::T.untyped)
  VALID_MATCH = ::T.let(nil, ::T.untyped)
end

class Capybara::RackTest::Driver
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Capybara::RackTest::Node
  BLOCK_ELEMENTS = ::T.let(nil, ::T.untyped)
  DISABLED_BY_FIELDSET_XPATH = ::T.let(nil, ::T.untyped)
  OPTION_OWNER_XPATH = ::T.let(nil, ::T.untyped)
end

class Capybara::ReadOnlySessionConfig
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Capybara::Selector
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Capybara::Selector::CSS
  ESCAPE = ::T.let(nil, ::T.untyped)
  H = ::T.let(nil, ::T.untyped)
  NMSTART = ::T.let(nil, ::T.untyped)
  NONASCII = ::T.let(nil, ::T.untyped)
  S = ::T.let(nil, ::T.untyped)
  UNICODE = ::T.let(nil, ::T.untyped)
end

module Capybara::Selenium::ChromeLogs
  COMMANDS = ::T.let(nil, ::T.untyped)
  LOG_MSG = ::T.let(nil, ::T.untyped)
end

class Capybara::Selenium::Driver
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  SPECIAL_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Capybara::Selenium::Node
  GET_XPATH_SCRIPT = ::T.let(nil, ::T.untyped)
  OBSCURED_OR_OFFSET_SCRIPT = ::T.let(nil, ::T.untyped)
end

module Capybara::Selenium::Node::Html5Drag
  ATTACH_FILE = ::T.let(nil, ::T.untyped)
  DROP_FILE = ::T.let(nil, ::T.untyped)
  DROP_STRING = ::T.let(nil, ::T.untyped)
  HTML5_DRAG_DROP_SCRIPT = ::T.let(nil, ::T.untyped)
  LEGACY_DRAG_CHECK = ::T.let(nil, ::T.untyped)
  MOUSEDOWN_TRACKER = ::T.let(nil, ::T.untyped)
end

class Capybara::Selenium::SafariNode
  MODIFIER_KEYS = ::T.let(nil, ::T.untyped)
end

class Capybara::Server::AnimationDisabler
  DISABLE_MARKUP_TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Capybara::Server::Checker
  TRY_HTTPS_ERRORS = ::T.let(nil, ::T.untyped)
end

class Capybara::Session
  DOCUMENT_METHODS = ::T.let(nil, ::T.untyped)
  DSL_METHODS = ::T.let(nil, ::T.untyped)
  MODAL_METHODS = ::T.let(nil, ::T.untyped)
  NODE_METHODS = ::T.let(nil, ::T.untyped)
  SESSION_METHODS = ::T.let(nil, ::T.untyped)
end

class Capybara::SessionConfig
  OPTIONS = ::T.let(nil, ::T.untyped)
end

module Capybara
  extend ::Capybara::DSL
end

class Category
  def after_add_for_tags(); end

  def after_add_for_tags=(val); end

  def after_add_for_tags?(); end

  def after_remove_for_tags(); end

  def after_remove_for_tags=(val); end

  def after_remove_for_tags?(); end

  def autosave_associated_records_for_tags(*args); end

  def before_add_for_tags(); end

  def before_add_for_tags=(val); end

  def before_add_for_tags?(); end

  def before_remove_for_tags(); end

  def before_remove_for_tags=(val); end

  def before_remove_for_tags?(); end

  def validate_associated_records_for_tags(*args); end
end

class Category::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Category::GeneratedRelationMethods
end

class Category::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Category::GeneratedRelationMethods
end

class Category::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Category::GeneratedRelationMethods
end

module Category::GeneratedAssociationMethods
  def tag_ids(); end

  def tag_ids=(ids); end

  def tags(); end

  def tags=(value); end
end

module Category::GeneratedAttributeMethods
  extend ::Mutex_m
end

module Category::GeneratedRelationMethods
  def eating_out(*args, &block); end

  def entertainment(*args, &block); end

  def grocries(*args, &block); end

  def housing_and_living_expenses(*args, &block); end

  def not_eating_out(*args, &block); end

  def not_entertainment(*args, &block); end

  def not_grocries(*args, &block); end

  def not_housing_and_living_expenses(*args, &block); end

  def not_shopping(*args, &block); end

  def not_transportation(*args, &block); end

  def not_vacations(*args, &block); end

  def shopping(*args, &block); end

  def transportation(*args, &block); end

  def vacations(*args, &block); end
end

module Category::GeneratedRelationMethods
  extend ::Mutex_m
end

class Category
  def self.after_add_for_tags(); end

  def self.after_add_for_tags=(val); end

  def self.after_add_for_tags?(); end

  def self.after_remove_for_tags(); end

  def self.after_remove_for_tags=(val); end

  def self.after_remove_for_tags?(); end

  def self.before_add_for_tags(); end

  def self.before_add_for_tags=(val); end

  def self.before_add_for_tags?(); end

  def self.before_remove_for_tags(); end

  def self.before_remove_for_tags=(val); end

  def self.before_remove_for_tags?(); end

  def self.eating_out(*args); end

  def self.entertainment(*args); end

  def self.grocries(*args); end

  def self.housing_and_living_expenses(*args); end

  def self.not_eating_out(*args); end

  def self.not_entertainment(*args); end

  def self.not_grocries(*args); end

  def self.not_housing_and_living_expenses(*args); end

  def self.not_shopping(*args); end

  def self.not_transportation(*args); end

  def self.not_vacations(*args); end

  def self.shopping(*args); end

  def self.transportation(*args); end

  def self.types(); end

  def self.vacations(*args); end
end

module Chartkick
  VERSION = ::T.let(nil, ::T.untyped)
end

module Chartkick::Helper
  JSON_ESCAPE = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE_REGEXP = ::T.let(nil, ::T.untyped)
end

module ChildProcess
  VERSION = ::T.let(nil, ::T.untyped)
end

class ChildProcess::AbstractProcess
  POLL_INTERVAL = ::T.let(nil, ::T.untyped)
end

class Class
  def json_creatable?(); end
end

class Complex
  def self.polar(*_); end

  def self.rect(*_); end

  def self.rectangular(*_); end
end

module Concurrent
  AtExit = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  NULL_LOGGER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Concurrent::AbstractExecutorService
  FALLBACK_POLICIES = ::T.let(nil, ::T.untyped)
end

Concurrent::Collection::MapImplementation = Concurrent::Collection::MriMapBackend

class Concurrent::ConcurrentUpdateError
  CONC_UP_ERR_BACKTRACE = ::T.let(nil, ::T.untyped)
end

class Concurrent::LockFreeStack
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Concurrent::MVar
  EMPTY = ::T.let(nil, ::T.untyped)
  TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::Maybe
  NONE = ::T.let(nil, ::T.untyped)
end

module Concurrent::Promises::InternalStates
  PENDING = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  RESOLVED = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReadWriteLock
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReentrantReadWriteLock
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  READER_BITS = ::T.let(nil, ::T.untyped)
  READ_LOCK_MASK = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
  WRITER_BITS = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_HELD = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_MASK = ::T.let(nil, ::T.untyped)
end

class Concurrent::RubyThreadPoolExecutor
  DEFAULT_MAX_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_QUEUE_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MIN_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_THREAD_IDLETIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::SerializedExecutionDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

Concurrent::Synchronization::Volatile = Concurrent::Synchronization::MriAttrVolatile

class Concurrent::SynchronizedDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Concurrent::ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

class Concurrent::TimerTask
  EXECUTION_INTERVAL = ::T.let(nil, ::T.untyped)
  TIMEOUT_INTERVAL = ::T.let(nil, ::T.untyped)
end

class Concurrent::Transaction
  ABORTED = ::T.let(nil, ::T.untyped)
end

module Concurrent::Utility::NativeInteger
  MAX_VALUE = ::T.let(nil, ::T.untyped)
  MIN_VALUE = ::T.let(nil, ::T.untyped)
end

class Crass::Parser
  BLOCK_END_TOKENS = ::T.let(nil, ::T.untyped)
end

class Crass::Tokenizer
  RE_COMMENT_CLOSE = ::T.let(nil, ::T.untyped)
  RE_DIGIT = ::T.let(nil, ::T.untyped)
  RE_ESCAPE = ::T.let(nil, ::T.untyped)
  RE_HEX = ::T.let(nil, ::T.untyped)
  RE_NAME = ::T.let(nil, ::T.untyped)
  RE_NAME_START = ::T.let(nil, ::T.untyped)
  RE_NON_PRINTABLE = ::T.let(nil, ::T.untyped)
  RE_NUMBER_DECIMAL = ::T.let(nil, ::T.untyped)
  RE_NUMBER_EXPONENT = ::T.let(nil, ::T.untyped)
  RE_NUMBER_SIGN = ::T.let(nil, ::T.untyped)
  RE_NUMBER_STR = ::T.let(nil, ::T.untyped)
  RE_QUOTED_URL_START = ::T.let(nil, ::T.untyped)
  RE_UNICODE_RANGE_END = ::T.let(nil, ::T.untyped)
  RE_UNICODE_RANGE_START = ::T.let(nil, ::T.untyped)
  RE_WHITESPACE = ::T.let(nil, ::T.untyped)
  RE_WHITESPACE_ANCHORED = ::T.let(nil, ::T.untyped)
end

module DRb
end

class DRb::DRbArray
  def _dump(lv); end

  def initialize(ary); end
end

class DRb::DRbArray
  def self._load(s); end
end

class DRb::DRbBadScheme
end

class DRb::DRbBadScheme
end

class DRb::DRbBadURI
end

class DRb::DRbBadURI
end

class DRb::DRbConn
  def alive?(); end

  def close(); end

  def initialize(remote_uri); end

  def send_message(ref, msg_id, arg, block); end

  def uri(); end
  POOL_SIZE = ::T.let(nil, ::T.untyped)
end

class DRb::DRbConn
  def self.make_pool(); end

  def self.open(remote_uri); end

  def self.stop_pool(); end
end

class DRb::DRbConnError
end

class DRb::DRbConnError
end

class DRb::DRbError
end

class DRb::DRbError
end

class DRb::DRbIdConv
  def to_id(obj); end

  def to_obj(ref); end
end

class DRb::DRbIdConv
end

class DRb::DRbMessage
  def dump(obj, error=T.unsafe(nil)); end

  def initialize(config); end

  def load(soc); end

  def recv_reply(stream); end

  def recv_request(stream); end

  def send_reply(stream, succ, result); end

  def send_request(stream, ref, msg_id, arg, b); end
end

class DRb::DRbMessage
end

class DRb::DRbObject
  def ==(other); end

  def __drbref(); end

  def __drburi(); end

  def _dump(lv); end

  def eql?(other); end

  def initialize(obj, uri=T.unsafe(nil)); end

  def method_missing(msg_id, *a, &b); end

  def respond_to?(msg_id, priv=T.unsafe(nil)); end
end

class DRb::DRbObject
  def self._load(s); end

  def self.new_with(uri, ref); end

  def self.new_with_uri(uri); end

  def self.prepare_backtrace(uri, result); end

  def self.with_friend(uri); end
end

module DRb::DRbProtocol
end

module DRb::DRbProtocol
  def self.add_protocol(prot); end

  def self.auto_load(uri); end

  def self.open(uri, config, first=T.unsafe(nil)); end

  def self.open_server(uri, config, first=T.unsafe(nil)); end

  def self.uri_option(uri, config, first=T.unsafe(nil)); end
end

class DRb::DRbRemoteError
  def initialize(error); end

  def reason(); end
end

class DRb::DRbRemoteError
end

class DRb::DRbServer
  def alive?(); end

  def check_insecure_method(obj, msg_id); end

  def config(); end

  def front(); end

  def here?(uri); end

  def initialize(uri=T.unsafe(nil), front=T.unsafe(nil), config_or_acl=T.unsafe(nil)); end

  def safe_level(); end

  def stop_service(); end

  def thread(); end

  def to_id(obj); end

  def to_obj(ref); end

  def uri(); end

  def verbose(); end

  def verbose=(v); end
  INSECURE_METHOD = ::T.let(nil, ::T.untyped)
end

class DRb::DRbServer::InvokeMethod
  include ::DRb::DRbServer::InvokeMethod18Mixin
  def initialize(drb_server, client); end

  def perform(); end
end

class DRb::DRbServer::InvokeMethod
end

module DRb::DRbServer::InvokeMethod18Mixin
  def block_yield(x); end

  def perform_with_block(); end
end

module DRb::DRbServer::InvokeMethod18Mixin
end

class DRb::DRbServer
  def self.default_acl(acl); end

  def self.default_argc_limit(argc); end

  def self.default_id_conv(idconv); end

  def self.default_load_limit(sz); end

  def self.default_safe_level(level); end

  def self.make_config(hash=T.unsafe(nil)); end

  def self.verbose(); end

  def self.verbose=(on); end
end

class DRb::DRbServerNotFound
end

class DRb::DRbServerNotFound
end

class DRb::DRbTCPSocket
  def accept(); end

  def alive?(); end

  def close(); end

  def initialize(uri, soc, config=T.unsafe(nil)); end

  def peeraddr(); end

  def recv_reply(); end

  def recv_request(); end

  def send_reply(succ, result); end

  def send_request(ref, msg_id, arg, b); end

  def set_sockopt(soc); end

  def shutdown(); end

  def stream(); end

  def uri(); end
end

class DRb::DRbTCPSocket
  def self.getservername(); end

  def self.open(uri, config); end

  def self.open_server(uri, config); end

  def self.open_server_inaddr_any(host, port); end

  def self.parse_uri(uri); end

  def self.uri_option(uri, config); end
end

class DRb::DRbUNIXSocket
  def initialize(uri, soc, config=T.unsafe(nil), server_mode=T.unsafe(nil)); end
  Max_try = ::T.let(nil, ::T.untyped)
end

class DRb::DRbUNIXSocket
  def self.temp_server(); end
end

class DRb::DRbURIOption
  def ==(other); end

  def eql?(other); end

  def initialize(option); end

  def option(); end
end

class DRb::DRbURIOption
end

module DRb::DRbUndumped
  def _dump(dummy); end
end

module DRb::DRbUndumped
end

class DRb::DRbUnknown
  def _dump(lv); end

  def buf(); end

  def exception(); end

  def initialize(err, buf); end

  def name(); end

  def reload(); end
end

class DRb::DRbUnknown
  def self._load(s); end
end

class DRb::DRbUnknownError
  def _dump(lv); end

  def initialize(unknown); end

  def unknown(); end
end

class DRb::DRbUnknownError
  def self._load(s); end
end

class DRb::ThreadObject
  include ::MonitorMixin
  def _execute(); end

  def alive?(); end

  def initialize(&blk); end

  def kill(); end

  def method_missing(msg, *arg, &blk); end
end

class DRb::ThreadObject
end

module DRb
  def self.config(); end

  def self.current_server(); end

  def self.fetch_server(uri); end

  def self.front(); end

  def self.here?(uri); end

  def self.install_acl(acl); end

  def self.install_id_conv(idconv); end

  def self.mutex(); end

  def self.primary_server(); end

  def self.primary_server=(primary_server); end

  def self.regist_server(server); end

  def self.remove_server(server); end

  def self.start_service(uri=T.unsafe(nil), front=T.unsafe(nil), config=T.unsafe(nil)); end

  def self.stop_service(); end

  def self.thread(); end

  def self.to_id(obj); end

  def self.to_obj(ref); end

  def self.uri(); end
end

DRbIdConv = DRb::DRbIdConv

DRbObject = DRb::DRbObject

DRbUndumped = DRb::DRbUndumped

class Date
  def infinite?(); end

  DATE_FORMATS = ::T.let(nil, ::T.untyped)
end

class Date::Error
end

class Date::Error
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

module DateAndTime::Calculations
  DAYS_INTO_WEEK = ::T.let(nil, ::T.untyped)
  WEEKEND_DAYS = ::T.let(nil, ::T.untyped)
end

class Delegator
  def !=(obj); end

  def ==(obj); end

  def __getobj__(); end

  def __setobj__(obj); end

  def eql?(obj); end

  def initialize(obj); end

  def marshal_dump(); end

  def marshal_load(data); end

  def method_missing(m, *args, &block); end

  def methods(all=T.unsafe(nil)); end

  def protected_methods(all=T.unsafe(nil)); end

  def public_methods(all=T.unsafe(nil)); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Delegator
  def self.const_missing(n); end

  def self.delegating_block(mid); end

  def self.public_api(); end
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

class DidYouMean::CorrectElement
  def call(names, element); end
end

class DidYouMean::CorrectElement
end

module DidYouMean::Correctable
  def corrections(); end

  def original_message(); end

  def spell_checker(); end

  def to_s(); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def names_to_exclude(); end

  def receiver(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*_); end
end

class DidYouMean::ParseDimensions
  def call(); end

  def initialize(dictionary, separator); end
end

class DidYouMean::ParseDimensions
end

class DidYouMean::PlainFormatter
  def message_for(corrections); end
end

class DidYouMean::PlainFormatter
end

class DidYouMean::TreeSpellChecker
  def augment(); end

  def correct(input); end

  def dictionary(); end

  def dimensions(); end

  def initialize(dictionary:, separator: T.unsafe(nil), augment: T.unsafe(nil)); end

  def separator(); end
end

class DidYouMean::TreeSpellChecker
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.correct_error(error_class, spell_checker); end

  def self.formatter(); end

  def self.formatter=(formatter); end
end

module Digest::UUID
  DNS_NAMESPACE = ::T.let(nil, ::T.untyped)
  OID_NAMESPACE = ::T.let(nil, ::T.untyped)
  URL_NAMESPACE = ::T.let(nil, ::T.untyped)
  X500_NAMESPACE = ::T.let(nil, ::T.untyped)
end

class Dir
  def children(); end

  def each_child(); end
end

module Dir::Tmpname
  UNUSABLE_CHARS = ::T.let(nil, ::T.untyped)
end

class Dir
  def self.children(*_); end

  def self.each_child(*_); end

  def self.empty?(_); end

  def self.exists?(_); end

  def self.tmpdir(); end
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end

  def result_with_hash(hash); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

module ERB::Util
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_ONCE_REGEXP = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE_REGEXP = ::T.let(nil, ::T.untyped)
end

Emitter = Psych::Stream::Emitter

class Encoding
  def _dump(*_); end
  CESU_8 = ::T.let(nil, ::T.untyped)
end

class Encoding::Converter
  def convert(_); end

  def convpath(); end

  def destination_encoding(); end

  def finish(); end

  def initialize(*_); end

  def insert_output(_); end

  def last_error(); end

  def primitive_convert(*_); end

  def primitive_errinfo(); end

  def putback(*_); end

  def replacement(); end

  def replacement=(replacement); end

  def source_encoding(); end
end

class Encoding::Converter
  def self.asciicompat_encoding(_); end

  def self.search_convpath(*_); end
end

class Encoding::InvalidByteSequenceError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_bytes(); end

  def incomplete_input?(); end

  def readagain_bytes(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding::UndefinedConversionError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_char(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding
  def self._load(_); end

  def self.locale_charmap(); end
end

module Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def chain(*_); end

  def chunk(); end

  def chunk_while(); end

  def each_entry(*_); end

  def filter_map(); end

  def grep_v(_); end

  def slice_after(*_); end

  def slice_before(*_); end

  def slice_when(); end

  def sum(identity=T.unsafe(nil), &block); end

  def tally(); end

  def to_set(klass=T.unsafe(nil), *args, &block); end

  def uniq(); end
end

class Enumerator
  def +(_); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*_); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Chain
end

class Enumerator::Chain
end

class Enumerator::Generator
  def each(*_, &blk); end

  def initialize(*_); end
end

class Enumerator::Lazy
  def chunk(*_); end

  def chunk_while(*_); end

  def eager(); end

  def force(*_); end

  def slice_when(*_); end
end

class Enumerator::Producer
  def each(&blk); end
end

class Enumerator::Producer
end

class Enumerator::Yielder
  def to_proc(); end
end

class Enumerator
  def self.produce(*_); end
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADARCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADARCH
end

class Errno::EBADEXEC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADEXEC
end

class Errno::EBADMACHO
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADMACHO
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::NOERROR

class Errno::EDEVERR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EDEVERR
end

Errno::EDOOFUS = Errno::NOERROR

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

Errno::EIPSEC = Errno::NOERROR

class Errno::ELAST
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ELAST
end

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

class Errno::ENOPOLICY
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOPOLICY
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::EPWROFF
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPWROFF
end

Errno::EQFULL = Errno::ELAST

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

class Errno::ESHLIBVERS
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ESHLIBVERS
end

module Erubi
  RANGE_ALL = ::T.let(nil, ::T.untyped)
  RANGE_FIRST = ::T.let(nil, ::T.untyped)
  RANGE_LAST = ::T.let(nil, ::T.untyped)
  TEXT_END = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Etc
  VERSION = ::T.let(nil, ::T.untyped)
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class ExcelParserManager
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Exception
  def full_message(*_); end
end

class Exception
  def self.exception(*_); end

  def self.to_tty?(); end
end

module ExceptionForMatrix
end

class ExceptionForMatrix::ErrDimensionMismatch
  def initialize(val=T.unsafe(nil)); end
end

class ExceptionForMatrix::ErrDimensionMismatch
end

class ExceptionForMatrix::ErrNotRegular
  def initialize(val=T.unsafe(nil)); end
end

class ExceptionForMatrix::ErrNotRegular
end

class ExceptionForMatrix::ErrOperationNotDefined
  def initialize(vals); end
end

class ExceptionForMatrix::ErrOperationNotDefined
end

class ExceptionForMatrix::ErrOperationNotImplemented
  def initialize(vals); end
end

class ExceptionForMatrix::ErrOperationNotImplemented
end

module ExceptionForMatrix
end

class ExitCalledError
end

class ExitCalledError
end

class FSEvent
  VERSION = ::T.let(nil, ::T.untyped)
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
end

module Fcntl
  FD_CLOEXEC = ::T.let(nil, ::T.untyped)
  F_DUPFD = ::T.let(nil, ::T.untyped)
  F_GETFD = ::T.let(nil, ::T.untyped)
  F_GETFL = ::T.let(nil, ::T.untyped)
  F_GETLK = ::T.let(nil, ::T.untyped)
  F_RDLCK = ::T.let(nil, ::T.untyped)
  F_SETFD = ::T.let(nil, ::T.untyped)
  F_SETFL = ::T.let(nil, ::T.untyped)
  F_SETLK = ::T.let(nil, ::T.untyped)
  F_SETLKW = ::T.let(nil, ::T.untyped)
  F_UNLCK = ::T.let(nil, ::T.untyped)
  F_WRLCK = ::T.let(nil, ::T.untyped)
  O_ACCMODE = ::T.let(nil, ::T.untyped)
  O_APPEND = ::T.let(nil, ::T.untyped)
  O_CREAT = ::T.let(nil, ::T.untyped)
  O_EXCL = ::T.let(nil, ::T.untyped)
  O_NDELAY = ::T.let(nil, ::T.untyped)
  O_NOCTTY = ::T.let(nil, ::T.untyped)
  O_NONBLOCK = ::T.let(nil, ::T.untyped)
  O_RDONLY = ::T.let(nil, ::T.untyped)
  O_RDWR = ::T.let(nil, ::T.untyped)
  O_TRUNC = ::T.let(nil, ::T.untyped)
  O_WRONLY = ::T.let(nil, ::T.untyped)
end

module Fcntl
end

class Fiber
  def initialize(*_); end

  def resume(*_); end

  def transfer(*_); end
end

class Fiber
  def self.current(); end

  def self.yield(*_); end
end

class File
  RELATIVE_PARENTDIR = ::T.let(nil, ::T.untyped)
  RELATIVE_SAMEDIR = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
end

class File::Stat
  def size?(); end
end

class File
  def self.absolute_path?(_); end

  def self.atomic_write(file_name, temp_dir=T.unsafe(nil)); end

  def self.cleanpath(path, rel_root=T.unsafe(nil)); end

  def self.empty?(_); end

  def self.exists?(_); end

  def self.lutime(*_); end

  def self.mkfifo(*_); end

  def self.open!(file, *args, &block); end

  def self.probe_stat_in(dir); end

  def self.read_binary(file); end

  def self.relative_path(from, to); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
  LN_SUPPORTED = ::T.let(nil, ::T.untyped)
  RUBY = ::T.let(nil, ::T.untyped)
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

module Find
end

module Find
  def self.find(*paths, ignore_error: T.unsafe(nil)); end

  def self.prune(); end
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
  include ::ActiveSupport::NumericWithFormat
  def to_d(precision=T.unsafe(nil)); end
end

module Forwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_instance_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_instance_delegators(accessor, *methods); end

  def delegate(hash); end

  def instance_delegate(hash); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

class FrozenError
  def receiver(); end
end

module GC
  def garbage_collect(full_mark: T.unsafe(nil), immediate_mark: T.unsafe(nil), immediate_sweep: T.unsafe(nil)); end
end

module GC
  def self.compact(); end

  def self.latest_gc_info(hash_or_key=T.unsafe(nil)); end

  def self.stress=(flag); end

  def self.verify_compaction_references(*_); end

  def self.verify_internal_consistency(); end

  def self.verify_transient_heap_internal_consistency(); end
end

module Gem
  UNTAINT = ::T.let(nil, ::T.untyped)
end

class Gem::BasicSpecification
  def self._deprecated_default_specifications_dir(); end
end

class Gem::Command
  def check_deprecated_options(options); end

  def deprecate_option(name, version: T.unsafe(nil), extra_msg: T.unsafe(nil)); end

end

class Gem::Dependency
  def identity(); end
end

class Gem::DependencyInstaller
  def _deprecated_available_set_for(dep_or_name, version); end

  def _deprecated_find_gems_with_sources(dep, best_only=T.unsafe(nil)); end

  def _deprecated_find_spec_by_name_and_version(gem_name, version=T.unsafe(nil), prerelease=T.unsafe(nil)); end
end

class Gem::Installer
  def _deprecated_unpack(directory); end

  def package(); end
end

class Gem::Package
  def gem(); end
end

class Gem::Package::TarHeader
  def self.oct_or_256based(str); end
end

class Gem::Package
  def self.raw_spec(path, security_policy=T.unsafe(nil)); end
end

class Gem::RemoteFetcher
  include ::Gem::UriParsing
  def _deprecated_fetch_size(uri); end

  def s3_uri_signer(uri); end
end

class Gem::RemoteFetcher::FetchError
  include ::Gem::UriParsing
  def initialize(message, uri); end

  def uri(); end

  def uri=(uri); end
end

class Gem::RemoteFetcher::FetchError
end

class Gem::RemoteFetcher::UnknownHostError
end

class Gem::RemoteFetcher::UnknownHostError
end

class Gem::RemoteFetcher
  extend ::Gem::Deprecate
end

class Gem::Requirement
  DefaultPrereleaseRequirement = ::T.let(nil, ::T.untyped)
end

class Gem::Requirement
  def self.default_prerelease(); end
end

class Gem::Resolver::ActivationRequest
  def platform(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::S3URISigner
  def initialize(uri); end

  def sign(expiration=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end
  BASE64_URI_TRANSLATE = ::T.let(nil, ::T.untyped)
  EC2_IAM_INFO = ::T.let(nil, ::T.untyped)
  EC2_IAM_SECURITY_CREDENTIALS = ::T.let(nil, ::T.untyped)
end

class Gem::S3URISigner::ConfigurationError
  def initialize(message); end
end

class Gem::S3URISigner::ConfigurationError
end

class Gem::S3URISigner::InstanceProfileError
  def initialize(message); end
end

class Gem::S3URISigner::InstanceProfileError
end

class Gem::S3URISigner::S3Config
  def access_key_id(); end

  def access_key_id=(_); end

  def region(); end

  def region=(_); end

  def secret_access_key(); end

  def secret_access_key=(_); end

  def security_token(); end

  def security_token=(_); end
end

class Gem::S3URISigner::S3Config
  def self.[](*_); end

  def self.members(); end
end

class Gem::S3URISigner
end

class Gem::Source
  include ::Gem::Text
  def typo_squatting?(host, distance_threshold=T.unsafe(nil)); end
end

class Gem::Specification
  def _deprecated_rubyforge_project=(_deprecated_rubyforge_project); end
  LOAD_CACHE_MUTEX = ::T.let(nil, ::T.untyped)
end

class Gem::Specification
  extend ::Enumerable
  def self.default_stubs(pattern=T.unsafe(nil)); end
end

class Gem::SpecificationPolicy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
end

class Gem::UriParser
  def parse(uri); end

  def parse!(uri); end
end

class Gem::UriParser
end

module Gem::UriParsing
end

module Gem::UriParsing
end

module Gem::Util
  def self.correct_for_windows_path(path); end
end

module Gem
  def self.add_to_load_path(*paths); end

  def self.default_specifications_dir(); end

  def self.java_platform?(); end

  def self.source_date_epoch(); end

  def self.source_index(); end

  def self.suffix_regexp(); end
end

module GlobalID::Locator
  DEFAULT_LOCATOR = ::T.let(nil, ::T.untyped)
end

module Groupdate
  METHODS = ::T.let(nil, ::T.untyped)
  PERIODS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Groupdate::SeriesBuilder
  CHECK_PERIODS = ::T.let(nil, ::T.untyped)
end

class HTMLSelector
  NO_STRIP = ::T.let(nil, ::T.untyped)
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  def <(_); end

  def <=(_); end

  def >(_); end

  def >=(_); end

  def compact(); end

  def compact!(); end

  def deconstruct_keys(_); end

  def default_proc(); end

  def default_proc=(default_proc); end

  def fetch_values(*_); end

  def flatten(*_); end

  def index(_); end

  def replace(_); end

  def slice(*_); end

  def to_h(); end

  def to_proc(); end

  def transform_keys(); end

  def transform_keys!(); end

  def transform_values(); end

  def transform_values!(); end

  def update(*_); end
end

class Hash
  def self.from_trusted_xml(xml); end

  def self.zip(keys, values); end
end

HashWithIndifferentAccess = ActiveSupport::HashWithIndifferentAccess

module I18n
  DEFAULT_INTERPOLATION_PATTERNS = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  INTERPOLATION_PATTERN = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS_PATTERN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Cache
  def _fetch(cache_key, &block); end

  def cache_key(locale, key, options); end

  def fetch(cache_key, &block); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Cache
end

module I18n::Backend::CacheFile
  def load_file(filename); end

  def normalized_path(file); end

  def path_roots(); end

  def path_roots=(path_roots); end
end

module I18n::Backend::CacheFile
end

module I18n::Backend::Cascade
  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end
end

module I18n::Backend::Cascade
end

class I18n::Backend::Chain
  include ::I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def backends(); end

  def backends=(backends); end

  def eager_load!(); end

  def exists?(locale, key); end

  def init_translations(); end

  def initialize(*backends); end

  def initialized?(); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def namespace_lookup?(result, options); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translate(locale, key, default_options=T.unsafe(nil)); end

  def translations(); end
end

module I18n::Backend::Chain::Implementation
end

class I18n::Backend::Chain
end

module I18n::Backend::Fallbacks
  def exists?(locale, key); end

  def extract_non_symbol_default!(options); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Fallbacks
end

module I18n::Backend::Flatten
  def escape_default_separator(key); end

  def find_link(locale, key); end

  def flatten_keys(hash, escape, prev_key=T.unsafe(nil), &block); end

  def flatten_translations(locale, data, escape, subtree); end

  def links(); end

  def normalize_flat_keys(locale, key, scope, separator); end

  def resolve_link(locale, key); end

  def store_link(locale, key, link); end
  FLATTEN_SEPARATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR_ESCAPE_CHAR = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Flatten
  def self.escape_default_separator(key); end

  def self.normalize_flat_keys(locale, key, scope, separator); end
end

module I18n::Backend::Gettext
  def load_po(filename); end

  def normalize(locale, data); end

  def normalize_pluralization(locale, key, value); end

  def parse(filename); end
end

class I18n::Backend::Gettext::PoData
  def set_comment(msgid_or_sym, comment); end
end

class I18n::Backend::Gettext::PoData
end

module I18n::Backend::Gettext
end

module I18n::Backend::InterpolationCompiler
  def compile_all_strings_in(data); end

  def interpolate(locale, string, values); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::InterpolationCompiler::Compiler
  def compile_if_an_interpolation(string); end

  def compile_interpolation_token(key); end

  def compiled_interpolation_body(str); end

  def direct_key(key); end

  def escape_key_sym(key); end

  def escape_plain_str(str); end

  def handle_interpolation_token(interpolation, matchdata); end

  def interpolate_key(key); end

  def interpolate_or_raise_missing(key); end

  def interpolated_str?(str); end

  def missing_key(key); end

  def nil_key(key); end

  def reserved_key(key); end

  def tokenize(str); end
  INTERPOLATION_SYNTAX_PATTERN = ::T.let(nil, ::T.untyped)
  TOKENIZER = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::InterpolationCompiler::Compiler
  extend ::I18n::Backend::InterpolationCompiler::Compiler
end

module I18n::Backend::InterpolationCompiler
end

class I18n::Backend::KeyValue
  include ::I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def init_translations(); end

  def initialize(store, subtrees=T.unsafe(nil)); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def store(); end

  def store=(store); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translations(); end
end

module I18n::Backend::KeyValue::Implementation
end

class I18n::Backend::KeyValue::SubtreeProxy
  def [](key); end

  def has_key?(key); end

  def initialize(master_key, store); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end
end

class I18n::Backend::KeyValue::SubtreeProxy
end

class I18n::Backend::KeyValue
end

module I18n::Backend::Memoize
  def available_locales(); end

  def eager_load!(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def memoized_lookup(); end

  def reload!(); end

  def reset_memoizations!(locale=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::Memoize
end

module I18n::Backend::Metadata
  def interpolate(locale, entry, values=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def with_metadata(metadata, &block); end
end

module I18n::Backend::Metadata
  def self.included(base); end
end

module I18n::Backend::Pluralization
  def pluralize(locale, entry, count); end

  def pluralizer(locale); end

  def pluralizers(); end
end

module I18n::Backend::Pluralization
end

module I18n::Backend::Transliterator
  DEFAULT_REPLACEMENT_CHAR = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
  DEFAULT_APPROXIMATIONS = ::T.let(nil, ::T.untyped)
end

module I18n::Gettext
  CONTEXT_SEPARATOR = ::T.let(nil, ::T.untyped)
  PLURAL_SEPARATOR = ::T.let(nil, ::T.untyped)
end

module I18n::Gettext::Helpers
  def N_(msgsid); end

  def _(msgid, options=T.unsafe(nil)); end

  def gettext(msgid, options=T.unsafe(nil)); end

  def n_(msgid, msgid_plural, n=T.unsafe(nil)); end

  def ngettext(msgid, msgid_plural, n=T.unsafe(nil)); end

  def np_(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def npgettext(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def ns_(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def nsgettext(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def p_(msgctxt, msgid); end

  def pgettext(msgctxt, msgid); end

  def s_(msgid, separator=T.unsafe(nil)); end

  def sgettext(msgid, separator=T.unsafe(nil)); end
end

module I18n::Gettext::Helpers
end

module I18n::Gettext
  def self.extract_scope(msgid, separator); end

  def self.plural_keys(*args); end
end

module I18n::Locale
end

class I18n::Locale::Fallbacks
  def [](locale); end

  def compute(tags, include_defaults=T.unsafe(nil), exclude=T.unsafe(nil)); end

  def defaults(); end

  def defaults=(defaults); end

  def initialize(*mappings); end

  def map(mappings); end
end

class I18n::Locale::Fallbacks
end

module I18n::Locale::Tag
  RFC4646_FORMATS = ::T.let(nil, ::T.untyped)
  RFC4646_SUBTAGS = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Parents
  def parent(); end

  def parents(); end

  def self_and_parents(); end
end

module I18n::Locale::Tag::Parents
end

class I18n::Locale::Tag::Rfc4646
  include ::I18n::Locale::Tag::Parents
  def to_sym(); end
end

module I18n::Locale::Tag::Rfc4646::Parser
  PATTERN = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Rfc4646::Parser
  def self.match(tag); end
end

class I18n::Locale::Tag::Rfc4646
  def self.parser(); end

  def self.parser=(parser); end

  def self.tag(tag); end
end

class I18n::Locale::Tag::Simple
  include ::I18n::Locale::Tag::Parents
  def initialize(*tag); end

  def subtags(); end

  def tag(); end

  def to_a(); end

  def to_sym(); end
end

class I18n::Locale::Tag::Simple
  def self.tag(tag); end
end

module I18n::Locale::Tag
  def self.implementation(); end

  def self.implementation=(implementation); end

  def self.tag(tag); end
end

module I18n::Locale
end

class I18n::Middleware
  def call(env); end

  def initialize(app); end
end

class I18n::Middleware
end

module I18n::Tests
end

module I18n::Tests::Localization
end

module I18n::Tests::Localization
  def self.included(base); end
end

module I18n::Tests
end

module I18n
  def self.cache_key_digest(); end

  def self.cache_key_digest=(key_digest); end

  def self.cache_namespace(); end

  def self.cache_namespace=(namespace); end

  def self.cache_store(); end

  def self.cache_store=(store); end

  def self.fallbacks(); end

  def self.fallbacks=(fallbacks); end

  def self.perform_caching?(); end
end

class IO
  def beep(); end

  def check_winsize_changed(); end

  def clear_screen(); end

  def console_mode(); end

  def console_mode=(console_mode); end

  def cooked(); end

  def cooked!(); end

  def cursor(); end

  def cursor=(cursor); end

  def cursor_down(_); end

  def cursor_left(_); end

  def cursor_right(_); end

  def cursor_up(_); end

  def echo=(echo); end

  def echo?(); end

  def erase_line(_); end

  def erase_screen(_); end

  def external_encoding(); end

  def getch(*_); end

  def getpass(*_); end

  def goto(_, _1); end

  def goto_column(_); end

  def iflush(); end

  def ioflush(); end

  def noecho(); end

  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def oflush(); end

  def pathconf(_); end

  def pread(*_); end

  def pressed?(); end

  def pwrite(_, _1); end

  def raw(*_); end

  def raw!(*_); end

  def ready?(); end

  def scroll_backward(_); end

  def scroll_forward(_); end

  def set_encoding_by_bom(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end

  def winsize(); end

  def winsize=(winsize); end

  def write_nonblock(buf, exception: T.unsafe(nil)); end
end

class IO::ConsoleMode
  def echo=(echo); end

  def raw(*_); end

  def raw!(*_); end
end

class IO::ConsoleMode
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO
  def self.console(*_); end

  def self.console_size(); end

  def self.default_console_size(); end

  def self.foreach(*_); end
end

class IPAddr
  include ::Comparable
  def &(other); end

  def <<(num); end

  def ==(other); end

  def ===(other); end

  def >>(num); end

  def eql?(other); end

  def family(); end

  def hton(); end

  def include?(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end

  def ip6_arpa(); end

  def ip6_int(); end

  def ipv4?(); end

  def ipv4_compat(); end

  def ipv4_compat?(); end

  def ipv4_mapped(); end

  def ipv4_mapped?(); end

  def ipv6?(); end

  def link_local?(); end

  def loopback?(); end

  def mask(prefixlen); end

  def mask!(mask); end

  def native(); end

  def prefix(); end

  def prefix=(prefix); end

  def private?(); end

  def reverse(); end

  def set(addr, *family); end

  def succ(); end

  def to_i(); end

  def to_range(); end

  def to_string(); end

  def |(other); end

  def ~(); end
  IN4MASK = ::T.let(nil, ::T.untyped)
  IN6FORMAT = ::T.let(nil, ::T.untyped)
  IN6MASK = ::T.let(nil, ::T.untyped)
  RE_IPV4ADDRLIKE = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_COMPRESSED = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_FULL = ::T.let(nil, ::T.untyped)
end

class IPAddr::AddressFamilyError
end

class IPAddr::AddressFamilyError
end

class IPAddr::Error
end

class IPAddr::Error
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidPrefixError
end

class IPAddr::InvalidPrefixError
end

class IPAddr
  def self.new_ntoh(addr); end

  def self.ntop(addr); end
end

module IRB
  IRBRC_EXT = ::T.let(nil, ::T.untyped)
  MagicFile = ::T.let(nil, ::T.untyped)
  STDIN_FILE_NAME = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class IRB::Abort
end

class IRB::Abort
end

module IRB::Color
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  REVERSE = ::T.let(nil, ::T.untyped)
  UNDERLINE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

module IRB::Color
  def self.clear(); end

  def self.colorable?(); end

  def self.colorize(text, seq); end

  def self.colorize_code(code, complete: T.unsafe(nil)); end

  def self.inspect_colorable?(obj, seen: T.unsafe(nil)); end
end

class IRB::Context
  def __exit__(*_); end

  def __inspect__(); end

  def __to_s__(); end

  def ap_name(); end

  def ap_name=(ap_name); end

  def auto_indent_mode(); end

  def auto_indent_mode=(auto_indent_mode); end

  def back_trace_limit(); end

  def back_trace_limit=(back_trace_limit); end

  def echo(); end

  def echo=(echo); end

  def echo?(); end

  def echo_on_assignment(); end

  def echo_on_assignment=(echo_on_assignment); end

  def echo_on_assignment?(); end

  def eval_history=(*opts, &b); end

  def evaluate(line, line_no, exception: T.unsafe(nil)); end

  def exit(ret=T.unsafe(nil)); end

  def file_input?(); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end

  def ignore_eof?(); end

  def ignore_sigint(); end

  def ignore_sigint=(ignore_sigint); end

  def ignore_sigint?(); end

  def initialize(irb, workspace=T.unsafe(nil), input_method=T.unsafe(nil)); end

  def inspect?(); end

  def inspect_last_value(); end

  def inspect_mode(); end

  def inspect_mode=(opt); end

  def io(); end

  def io=(io); end

  def irb(); end

  def irb=(irb); end

  def irb_name(); end

  def irb_name=(irb_name); end

  def irb_path(); end

  def irb_path=(irb_path); end

  def last_value(); end

  def load_modules(); end

  def load_modules=(load_modules); end

  def main(); end

  def prompt_c(); end

  def prompt_c=(prompt_c); end

  def prompt_i(); end

  def prompt_i=(prompt_i); end

  def prompt_mode(); end

  def prompt_mode=(mode); end

  def prompt_n(); end

  def prompt_n=(prompt_n); end

  def prompt_s(); end

  def prompt_s=(prompt_s); end

  def prompting?(); end

  def rc(); end

  def rc=(rc); end

  def rc?(); end

  def return_format(); end

  def return_format=(return_format); end

  def save_history=(*opts, &b); end

  def set_last_value(value); end

  def thread(); end

  def use_colorize(); end

  def use_colorize?(); end

  def use_loader=(*opts, &b); end

  def use_multiline(); end

  def use_multiline?(); end

  def use_readline(); end

  def use_readline?(); end

  def use_reidline(); end

  def use_reidline?(); end

  def use_singleline(); end

  def use_singleline?(); end

  def use_tracer=(*opts, &b); end

  def verbose(); end

  def verbose=(verbose); end

  def verbose?(); end

  def workspace(); end

  def workspace=(workspace); end

  def workspace_home(); end
  IDNAME_IVARS = ::T.let(nil, ::T.untyped)
  NOPRINTING_IVARS = ::T.let(nil, ::T.untyped)
  NO_INSPECTING_IVARS = ::T.let(nil, ::T.untyped)
end

class IRB::Context
end

module IRB::ContextExtender
end

IRB::ContextExtender::CE = IRB::ContextExtender

module IRB::ContextExtender
  def self.def_extend_command(cmd_name, load_file, *aliases); end

  def self.install_extend_commands(); end
end

class IRB::DefaultEncodings
  def external(); end

  def external=(_); end

  def internal(); end

  def internal=(_); end
end

class IRB::DefaultEncodings
  def self.[](*_); end

  def self.members(); end
end

module IRB::ExtendCommandBundle
  def install_alias_method(to, from, override=T.unsafe(nil)); end

  def irb(*opts, &b); end

  def irb_change_workspace(*opts, &b); end

  def irb_context(); end

  def irb_current_working_workspace(*opts, &b); end

  def irb_exit(ret=T.unsafe(nil)); end

  def irb_fg(*opts, &b); end

  def irb_help(*opts, &b); end

  def irb_jobs(*opts, &b); end

  def irb_kill(*opts, &b); end

  def irb_load(*opts, &b); end

  def irb_pop_workspace(*opts, &b); end

  def irb_push_workspace(*opts, &b); end

  def irb_require(*opts, &b); end

  def irb_source(*opts, &b); end

  def irb_workspaces(*opts, &b); end
  NO_OVERRIDE = ::T.let(nil, ::T.untyped)
  OVERRIDE_ALL = ::T.let(nil, ::T.untyped)
  OVERRIDE_PRIVATE_ONLY = ::T.let(nil, ::T.untyped)
end

IRB::ExtendCommandBundle::EXCB = IRB::ExtendCommandBundle

module IRB::ExtendCommandBundle
  def self.def_extend_command(cmd_name, cmd_class, load_file=T.unsafe(nil), *aliases); end

  def self.extend_object(obj); end

  def self.install_extend_commands(); end

  def self.irb_original_method_name(method_name); end
end

class IRB::FileInputMethod
  def encoding(); end

  def eof?(); end

  def initialize(file); end
end

class IRB::FileInputMethod
end

module IRB::InputCompletor
  BASIC_WORD_BREAK_CHARACTERS = ::T.let(nil, ::T.untyped)
  CompletionProc = ::T.let(nil, ::T.untyped)
  Operators = ::T.let(nil, ::T.untyped)
  PerfectMatchedProc = ::T.let(nil, ::T.untyped)
  ReservedWords = ::T.let(nil, ::T.untyped)
end

module IRB::InputCompletor
  def self.ignored_modules(); end

  def self.retrieve_completion_data(input, bind: T.unsafe(nil), doc_namespace: T.unsafe(nil)); end

  def self.select_message(receiver, message, candidates, sep=T.unsafe(nil)); end
end

class IRB::InputMethod
  def file_name(); end

  def gets(); end

  def initialize(file=T.unsafe(nil)); end

  def prompt(); end

  def prompt=(prompt); end

  def readable_after_eof?(); end
end

class IRB::InputMethod
end

class IRB::Inspector
  def init(); end

  def initialize(inspect_proc, init_proc=T.unsafe(nil)); end

  def inspect_value(v); end
  INSPECTORS = ::T.let(nil, ::T.untyped)
end

class IRB::Inspector
  def self.def_inspector(key, arg=T.unsafe(nil), &block); end

  def self.keys_with_inspector(inspector); end
end

class IRB::Irb
  def assignment_expression?(line); end

  def context(); end

  def eval_input(); end

  def handle_exception(exc); end

  def initialize(workspace=T.unsafe(nil), input_method=T.unsafe(nil)); end

  def output_value(); end

  def prompt(prompt, ltype, indent, line_no); end

  def run(conf=T.unsafe(nil)); end

  def scanner(); end

  def scanner=(scanner); end

  def signal_handle(); end

  def signal_status(status); end

  def suspend_context(context); end

  def suspend_input_method(input_method); end

  def suspend_name(path=T.unsafe(nil), name=T.unsafe(nil)); end

  def suspend_workspace(workspace); end
  ASSIGNMENT_NODE_TYPES = ::T.let(nil, ::T.untyped)
  ATTR_PLAIN = ::T.let(nil, ::T.untyped)
  ATTR_TTY = ::T.let(nil, ::T.untyped)
end

class IRB::Irb
end

class IRB::Locale
  def String(mes); end

  def encoding(); end

  def find(file, paths=T.unsafe(nil)); end

  def format(*opts); end

  def gets(*rs); end

  def initialize(locale=T.unsafe(nil)); end

  def lang(); end

  def load(file, priv=T.unsafe(nil)); end

  def modifier(); end

  def print(*opts); end

  def printf(*opts); end

  def puts(*opts); end

  def readline(*rs); end

  def require(file, priv=T.unsafe(nil)); end

  def territory(); end
  LOCALE_DIR = ::T.let(nil, ::T.untyped)
  LOCALE_NAME_RE = ::T.let(nil, ::T.untyped)
end

class IRB::Locale
end

module IRB::MethodExtender
  def def_post_proc(base_method, extend_method); end

  def def_pre_proc(base_method, extend_method); end

  def new_alias_name(name, prefix=T.unsafe(nil), postfix=T.unsafe(nil)); end
end

module IRB::MethodExtender
end

class IRB::OutputMethod
  def parse_printf_format(format, opts); end

  def ppx(prefix, *objs); end

  def print(*opts); end

  def printf(format, *opts); end

  def printn(*opts); end

  def puts(*objs); end
end

class IRB::OutputMethod::NotImplementedError
  def initialize(val); end
end

class IRB::OutputMethod::NotImplementedError
end

class IRB::OutputMethod
end

class IRB::ReadlineInputMethod
  include ::Readline
  def encoding(); end

  def eof?(); end

  def initialize(); end

  def line(line_no); end
end

class IRB::ReadlineInputMethod
end

class IRB::ReidlineInputMethod
  include ::Reline
  def auto_indent(&block); end

  def check_termination(&block); end

  def dynamic_prompt(&block); end

  def encoding(); end

  def eof?(); end

  def initialize(); end

  def line(line_no); end
end

class IRB::ReidlineInputMethod
end

class IRB::StdioInputMethod
  def encoding(); end

  def eof?(); end

  def initialize(); end

  def line(line_no); end
end

class IRB::StdioInputMethod
end

class IRB::StdioOutputMethod
end

class IRB::StdioOutputMethod
end

class IRB::WorkSpace
  def code_around_binding(); end

  def evaluate(context, statements, file=T.unsafe(nil), line=T.unsafe(nil)); end

  def filter_backtrace(bt); end

  def initialize(*main); end

  def local_variable_get(name); end

  def local_variable_set(name, value); end

  def main(); end
end

class IRB::WorkSpace
end

module IRB
  def self.CurrentContext(); end

  def self.Inspector(inspect, init=T.unsafe(nil)); end

  def self.conf(); end

  def self.default_src_encoding(); end

  def self.delete_caller(); end

  def self.init_config(ap_path); end

  def self.init_error(); end

  def self.irb_abort(irb, exception=T.unsafe(nil)); end

  def self.irb_at_exit(); end

  def self.irb_exit(irb, ret); end

  def self.load_modules(); end

  def self.parse_opts(argv: T.unsafe(nil)); end

  def self.rc_file(ext=T.unsafe(nil)); end

  def self.rc_file_generators(); end

  def self.run_config(); end

  def self.setup(ap_path, argv: T.unsafe(nil)); end

  def self.start(ap_path=T.unsafe(nil)); end

  def self.version(); end
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  include ::ActiveSupport::NumericWithFormat
  def allbits?(_); end

  def anybits?(_); end

  def digits(*_); end

  def nobits?(_); end

  def pow(*_); end

  def to_bn(); end

  def to_d(); end
end

class Integer
  def self.sqrt(_); end
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

class JSON::Ext::Parser
  def initialize(*_); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

JSONTree = Psych::Visitors::JSONTree

class Jbuilder
  BLANK = ::T.let(nil, ::T.untyped)
  NON_ENUMERABLES = ::T.let(nil, ::T.untyped)
end

module Jbuilder::DependencyTrackerMethods
  DIRECT_RENDERS = ::T.let(nil, ::T.untyped)
  INDIRECT_RENDERS = ::T.let(nil, ::T.untyped)
end

module Kernel
  def gem(dep, *reqs); end

  def itself(); end

  def object_id(); end

  def pretty_inspect(); end

  def respond_to?(*_); end

  def then(); end

  def yield_self(); end
end

module Kernel
  def self.at_exit(); end

  def self.autoload(_, _1); end
end

class KeyError
  include ::DidYouMean::Correctable
  def key(); end

  def receiver(); end
end

module Listen
  VERSION = ::T.let(nil, ::T.untyped)
end

module Listen::Adapter
  OPTIMIZED_ADAPTERS = ::T.let(nil, ::T.untyped)
  POLLING_FALLBACK_MESSAGE = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::BSD
  BUNDLER_DECLARE_GEM = ::T.let(nil, ::T.untyped)
  DEFAULTS = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Base
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Darwin
  DEFAULTS = ::T.let(nil, ::T.untyped)
  INCOMPATIBLE_GEM_VERSION = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Linux
  DEFAULTS = ::T.let(nil, ::T.untyped)
  INOTIFY_LIMIT_MESSAGE = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
  WIKI_URL = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Polling
  DEFAULTS = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Windows
  BUNDLER_DECLARE_GEM = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

module Listen::FSM
  DEFAULT_STATE = ::T.let(nil, ::T.untyped)
end

class Listen::Listener::Config
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Listen::Record::SymlinkDetector
  SYMLINK_LOOP_ERROR = ::T.let(nil, ::T.untyped)
  WIKI = ::T.let(nil, ::T.untyped)
end

class Listen::Silencer
  DEFAULT_IGNORED_DIRECTORIES = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORED_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class LoadError
  def path(); end
end

class LocalJumpError
  def exit_value(); end

  def reason(); end
end

class Location
  include ::Location::GeneratedAttributeMethods
  include ::Location::GeneratedAssociationMethods
  def after_add_for_categories(); end

  def after_add_for_categories=(val); end

  def after_add_for_categories?(); end

  def after_add_for_categories_locations(); end

  def after_add_for_categories_locations=(val); end

  def after_add_for_categories_locations?(); end

  def after_add_for_mtransactions(); end

  def after_add_for_mtransactions=(val); end

  def after_add_for_mtransactions?(); end

  def after_remove_for_categories(); end

  def after_remove_for_categories=(val); end

  def after_remove_for_categories?(); end

  def after_remove_for_categories_locations(); end

  def after_remove_for_categories_locations=(val); end

  def after_remove_for_categories_locations?(); end

  def after_remove_for_mtransactions(); end

  def after_remove_for_mtransactions=(val); end

  def after_remove_for_mtransactions?(); end

  def autosave_associated_records_for_categories(*args); end

  def autosave_associated_records_for_categories_locations(*args); end

  def autosave_associated_records_for_mtransactions(*args); end

  def before_add_for_categories(); end

  def before_add_for_categories=(val); end

  def before_add_for_categories?(); end

  def before_add_for_categories_locations(); end

  def before_add_for_categories_locations=(val); end

  def before_add_for_categories_locations?(); end

  def before_add_for_mtransactions(); end

  def before_add_for_mtransactions=(val); end

  def before_add_for_mtransactions?(); end

  def before_remove_for_categories(); end

  def before_remove_for_categories=(val); end

  def before_remove_for_categories?(); end

  def before_remove_for_categories_locations(); end

  def before_remove_for_categories_locations=(val); end

  def before_remove_for_categories_locations?(); end

  def before_remove_for_mtransactions(); end

  def before_remove_for_mtransactions=(val); end

  def before_remove_for_mtransactions?(); end

  def validate_associated_records_for_categories(*args); end

  def validate_associated_records_for_categories_locations(*args); end

  def validate_associated_records_for_mtransactions(*args); end
end

class Location::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Location::GeneratedRelationMethods
end

class Location::ActiveRecord_AssociationRelation
end

class Location::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Location::GeneratedRelationMethods
end

class Location::ActiveRecord_Associations_CollectionProxy
end

class Location::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Location::GeneratedRelationMethods
end

class Location::ActiveRecord_Relation
end

module Location::GeneratedAssociationMethods
  def categories(); end

  def categories=(value); end

  def category_ids(); end

  def category_ids=(ids); end

  def mtransaction_ids(); end

  def mtransaction_ids=(ids); end

  def mtransactions(); end

  def mtransactions=(value); end
end

module Location::GeneratedAssociationMethods
end

module Location::GeneratedAttributeMethods
end

module Location::GeneratedAttributeMethods
  extend ::Mutex_m
end

module Location::GeneratedRelationMethods
end

module Location::GeneratedRelationMethods
  extend ::Mutex_m
end

class Location
  def self.after_add_for_categories(); end

  def self.after_add_for_categories=(val); end

  def self.after_add_for_categories?(); end

  def self.after_add_for_categories_locations(); end

  def self.after_add_for_categories_locations=(val); end

  def self.after_add_for_categories_locations?(); end

  def self.after_add_for_mtransactions(); end

  def self.after_add_for_mtransactions=(val); end

  def self.after_add_for_mtransactions?(); end

  def self.after_remove_for_categories(); end

  def self.after_remove_for_categories=(val); end

  def self.after_remove_for_categories?(); end

  def self.after_remove_for_categories_locations(); end

  def self.after_remove_for_categories_locations=(val); end

  def self.after_remove_for_categories_locations?(); end

  def self.after_remove_for_mtransactions(); end

  def self.after_remove_for_mtransactions=(val); end

  def self.after_remove_for_mtransactions?(); end

  def self.before_add_for_categories(); end

  def self.before_add_for_categories=(val); end

  def self.before_add_for_categories?(); end

  def self.before_add_for_categories_locations(); end

  def self.before_add_for_categories_locations=(val); end

  def self.before_add_for_categories_locations?(); end

  def self.before_add_for_mtransactions(); end

  def self.before_add_for_mtransactions=(val); end

  def self.before_add_for_mtransactions?(); end

  def self.before_remove_for_categories(); end

  def self.before_remove_for_categories=(val); end

  def self.before_remove_for_categories?(); end

  def self.before_remove_for_categories_locations(); end

  def self.before_remove_for_categories_locations=(val); end

  def self.before_remove_for_categories_locations?(); end

  def self.before_remove_for_mtransactions(); end

  def self.before_remove_for_mtransactions=(val); end

  def self.before_remove_for_mtransactions?(); end
end

class Logger
  def debug!(); end

  def error!(); end

  def fatal!(); end

  def info!(); end

  def warn!(); end
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

module Loofah
  VERSION = ::T.let(nil, ::T.untyped)
end

module Loofah::Elements
  BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  LOOSE_BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL_HTML4 = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL_HTML5 = ::T.let(nil, ::T.untyped)
end

module Loofah::HTML5::SafeList
  ACCEPTABLE_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_FUNCTIONS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_KEYWORDS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_ELEMENTS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_PROTOCOLS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_SVG_PROPERTIES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_URI_DATA_MEDIATYPES = ::T.let(nil, ::T.untyped)
  ALLOWED_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_FUNCTIONS = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_KEYWORDS = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  ALLOWED_ELEMENTS = ::T.let(nil, ::T.untyped)
  ALLOWED_ELEMENTS_WITH_LIBXML2 = ::T.let(nil, ::T.untyped)
  ALLOWED_PROTOCOLS = ::T.let(nil, ::T.untyped)
  ALLOWED_SVG_PROPERTIES = ::T.let(nil, ::T.untyped)
  ALLOWED_URI_DATA_MEDIATYPES = ::T.let(nil, ::T.untyped)
  ATTR_VAL_IS_URI = ::T.let(nil, ::T.untyped)
  MATHML_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  MATHML_ELEMENTS = ::T.let(nil, ::T.untyped)
  PROTOCOL_SEPARATOR = ::T.let(nil, ::T.untyped)
  SHORTHAND_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  SVG_ALLOW_LOCAL_HREF = ::T.let(nil, ::T.untyped)
  SVG_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SVG_ATTR_VAL_ALLOWS_REF = ::T.let(nil, ::T.untyped)
  SVG_ELEMENTS = ::T.let(nil, ::T.untyped)
  TAGS_SAFE_WITH_LIBXML2 = ::T.let(nil, ::T.untyped)
  VOID_ELEMENTS = ::T.let(nil, ::T.untyped)
end

module Loofah::HTML5::Scrub
  CONTROL_CHARACTERS = ::T.let(nil, ::T.untyped)
  CRASS_SEMICOLON = ::T.let(nil, ::T.untyped)
  CSS_KEYWORDISH = ::T.let(nil, ::T.untyped)
end

Loofah::HTML5::WhiteList = Loofah::HTML5::SafeList

module Loofah::LibxmlWorkarounds
  BROKEN_ESCAPING_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  BROKEN_ESCAPING_ATTRIBUTES_QUALIFYING_TAG = ::T.let(nil, ::T.untyped)
end

class Loofah::Scrubber
  CONTINUE = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

module Loofah::Scrubbers
  MAP = ::T.let(nil, ::T.untyped)
end

module Mail
  RANDOM_TAG = ::T.let(nil, ::T.untyped)
end

class Mail::BccField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::CcField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::CommentsField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

module Mail::CommonField
  FILENAME_RE = ::T.let(nil, ::T.untyped)
end

module Mail::Constants
  ASTERISK = ::T.let(nil, ::T.untyped)
  ATOM_UNSAFE = ::T.let(nil, ::T.untyped)
  B_VALUES = ::T.let(nil, ::T.untyped)
  CAPITAL_M = ::T.let(nil, ::T.untyped)
  COLON = ::T.let(nil, ::T.untyped)
  CONTROL_CHAR = ::T.let(nil, ::T.untyped)
  CR = ::T.let(nil, ::T.untyped)
  CRLF = ::T.let(nil, ::T.untyped)
  CR_ENCODED = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ENCODED_VALUE = ::T.let(nil, ::T.untyped)
  EQUAL_LF = ::T.let(nil, ::T.untyped)
  FIELD_BODY = ::T.let(nil, ::T.untyped)
  FIELD_LINE = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
  FIELD_PREFIX = ::T.let(nil, ::T.untyped)
  FIELD_SPLIT = ::T.let(nil, ::T.untyped)
  FULL_ENCODED_VALUE = ::T.let(nil, ::T.untyped)
  FWS = ::T.let(nil, ::T.untyped)
  HEADER_LINE = ::T.let(nil, ::T.untyped)
  HEADER_SPLIT = ::T.let(nil, ::T.untyped)
  HYPHEN = ::T.let(nil, ::T.untyped)
  LF = ::T.let(nil, ::T.untyped)
  LF_ENCODED = ::T.let(nil, ::T.untyped)
  NULL_SENDER = ::T.let(nil, ::T.untyped)
  PHRASE_UNSAFE = ::T.let(nil, ::T.untyped)
  QP_SAFE = ::T.let(nil, ::T.untyped)
  QP_UNSAFE = ::T.let(nil, ::T.untyped)
  Q_VALUES = ::T.let(nil, ::T.untyped)
  SPACE = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  TOKEN_UNSAFE = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
  WSP = ::T.let(nil, ::T.untyped)
end

class Mail::ContentDescriptionField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentDispositionField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentIdField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentLocationField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentTransferEncodingField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentTypeField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::DateField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::Base64
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::Binary
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::EightBit
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::QuotedPrintable
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::SevenBit
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::TransferEncoding
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::UnixToUnix
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::Exim
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::Field
  FIELDS_MAP = ::T.let(nil, ::T.untyped)
  FIELD_NAME_MAP = ::T.let(nil, ::T.untyped)
  FIELD_ORDER = ::T.let(nil, ::T.untyped)
  FIELD_ORDER_LOOKUP = ::T.let(nil, ::T.untyped)
  KNOWN_FIELDS = ::T.let(nil, ::T.untyped)
  STRUCTURED_FIELDS = ::T.let(nil, ::T.untyped)
end

class Mail::FromField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::Header
  LIMITED_FIELDS = ::T.let(nil, ::T.untyped)
end

class Mail::InReplyToField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::KeywordsField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::Message
  HEADER_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Mail::MessageIdField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::MimeVersionField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

module Mail::Multibyte
  VALID_CHARACTER = ::T.let(nil, ::T.untyped)
end

module Mail::Multibyte::Unicode
  HANGUL_JAMO_FIRST = ::T.let(nil, ::T.untyped)
  HANGUL_JAMO_LAST = ::T.let(nil, ::T.untyped)
  HANGUL_LBASE = ::T.let(nil, ::T.untyped)
  HANGUL_LCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_NCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SBASE = ::T.let(nil, ::T.untyped)
  HANGUL_SCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SLAST = ::T.let(nil, ::T.untyped)
  HANGUL_TBASE = ::T.let(nil, ::T.untyped)
  HANGUL_TCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_VBASE = ::T.let(nil, ::T.untyped)
  HANGUL_VCOUNT = ::T.let(nil, ::T.untyped)
  LEADERS_AND_TRAILERS = ::T.let(nil, ::T.untyped)
  LEADERS_PAT = ::T.let(nil, ::T.untyped)
  NORMALIZATION_FORMS = ::T.let(nil, ::T.untyped)
  TRAILERS_PAT = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  WHITESPACE = ::T.let(nil, ::T.untyped)
end

class Mail::Multibyte::Unicode::UnicodeDatabase
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class Mail::PartsList
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mail::ReceivedField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReferencesField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReplyToField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentBccField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentCcField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentDateField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentFromField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentMessageIdField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentSenderField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentToField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReturnPathField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

Mail::RubyVer = Mail::Ruby19

class Mail::SMTP
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::SenderField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::Sendmail
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::SubjectField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ToField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

module Mail::Utilities
  CRLF = ::T.let(nil, ::T.untyped)
  LF = ::T.let(nil, ::T.untyped)
  TO_CRLF_REGEX = ::T.let(nil, ::T.untyped)
end

module Mail::VERSION
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
end

module MakeMakefile
  def append_cflags(flags, *opts); end

  def append_cppflags(flags, *opts); end

  def append_ldflags(flags, *opts); end

  def append_library(libs, lib); end

  def arg_config(config, default=T.unsafe(nil), &block); end

  def cc_command(opt=T.unsafe(nil)); end

  def cc_config(opt=T.unsafe(nil)); end

  def check_signedness(type, headers=T.unsafe(nil), opts=T.unsafe(nil), &b); end

  def check_sizeof(type, headers=T.unsafe(nil), opts=T.unsafe(nil), &b); end

  def checking_for(m, fmt=T.unsafe(nil)); end

  def checking_message(target, place=T.unsafe(nil), opt=T.unsafe(nil)); end

  def configuration(srcdir); end

  def conftest_source(); end

  def convertible_int(type, headers=T.unsafe(nil), opts=T.unsafe(nil), &b); end

  def cpp_command(outfile, opt=T.unsafe(nil)); end

  def cpp_include(header); end

  def create_header(header=T.unsafe(nil)); end

  def create_makefile(target, srcprefix=T.unsafe(nil)); end

  def create_tmpsrc(src); end

  def depend_rules(depend); end

  def dir_config(target, idefault=T.unsafe(nil), ldefault=T.unsafe(nil)); end

  def dummy_makefile(srcdir); end

  def each_compile_rules(); end

  def egrep_cpp(pat, src, opt=T.unsafe(nil), &b); end

  def enable_config(config, default=T.unsafe(nil)); end

  def find_executable(bin, path=T.unsafe(nil)); end

  def find_executable0(bin, path=T.unsafe(nil)); end

  def find_header(header, *paths); end

  def find_library(lib, func, *paths, &b); end

  def find_type(type, opt, *headers, &b); end

  def have_const(const, headers=T.unsafe(nil), opt=T.unsafe(nil), &b); end

  def have_devel?(); end

  def have_framework(fw, &b); end

  def have_func(func, headers=T.unsafe(nil), opt=T.unsafe(nil), &b); end

  def have_header(header, preheaders=T.unsafe(nil), opt=T.unsafe(nil), &b); end

  def have_library(lib, func=T.unsafe(nil), headers=T.unsafe(nil), opt=T.unsafe(nil), &b); end

  def have_macro(macro, headers=T.unsafe(nil), opt=T.unsafe(nil), &b); end

  def have_struct_member(type, member, headers=T.unsafe(nil), opt=T.unsafe(nil), &b); end

  def have_type(type, headers=T.unsafe(nil), opt=T.unsafe(nil), &b); end

  def have_typeof?(); end

  def have_var(var, headers=T.unsafe(nil), opt=T.unsafe(nil), &b); end

  def init_mkmf(config=T.unsafe(nil), rbconfig=T.unsafe(nil)); end

  def install_dirs(target_prefix=T.unsafe(nil)); end

  def install_files(mfile, ifiles, map=T.unsafe(nil), srcprefix=T.unsafe(nil)); end

  def install_rb(mfile, dest, srcdir=T.unsafe(nil)); end

  def libpath_env(); end

  def libpathflag(libpath=T.unsafe(nil)); end

  def link_command(ldflags, *opts); end

  def link_config(ldflags, opt=T.unsafe(nil), libpath=T.unsafe(nil)); end

  def log_src(src, heading=T.unsafe(nil)); end

  def macro_defined?(macro, src, opt=T.unsafe(nil), &b); end

  def map_dir(dir, map=T.unsafe(nil)); end

  def merge_libs(*libs); end

  def message(*s); end

  def mkintpath(path); end

  def mkmf_failed(path); end

  def modified?(target, times); end

  def pkg_config(pkg, option=T.unsafe(nil)); end

  def relative_from(path, base); end

  def scalar_ptr_type?(type, member=T.unsafe(nil), headers=T.unsafe(nil), &b); end

  def scalar_type?(type, member=T.unsafe(nil), headers=T.unsafe(nil), &b); end

  def split_libs(*strs); end

  def timestamp_file(name, target_prefix=T.unsafe(nil)); end

  def try_cflags(flags, opts=T.unsafe(nil)); end

  def try_compile(src, opt=T.unsafe(nil), *opts, &b); end

  def try_const(const, headers=T.unsafe(nil), opt=T.unsafe(nil), &b); end

  def try_constant(const, headers=T.unsafe(nil), opt=T.unsafe(nil), &b); end

  def try_cpp(src, opt=T.unsafe(nil), *opts, &b); end

  def try_cppflags(flags, opts=T.unsafe(nil)); end

  def try_do(src, command, *opts, &b); end

  def try_func(func, libs, headers=T.unsafe(nil), opt=T.unsafe(nil), &b); end

  def try_header(src, opt=T.unsafe(nil), *opts, &b); end

  def try_ldflags(flags, opts=T.unsafe(nil)); end

  def try_link(src, opt=T.unsafe(nil), *opts, &b); end

  def try_link0(src, opt=T.unsafe(nil), *opts, &b); end

  def try_run(src, opt=T.unsafe(nil), &b); end

  def try_signedness(type, member, headers=T.unsafe(nil), opts=T.unsafe(nil)); end

  def try_static_assert(expr, headers=T.unsafe(nil), opt=T.unsafe(nil), &b); end

  def try_type(type, headers=T.unsafe(nil), opt=T.unsafe(nil), &b); end

  def try_var(var, headers=T.unsafe(nil), opt=T.unsafe(nil), &b); end

  def typedef_expr(type, headers); end

  def what_type?(type, member=T.unsafe(nil), headers=T.unsafe(nil), &b); end

  def winsep(s); end

  def with_cflags(flags); end

  def with_config(config, default=T.unsafe(nil)); end

  def with_cppflags(flags); end

  def with_destdir(dir); end

  def with_ldflags(flags); end

  def with_werror(opt, opts=T.unsafe(nil)); end

  def xpopen(command, *mode, &block); end

  def xsystem(command, opts=T.unsafe(nil)); end
  ASSEMBLE_C = ::T.let(nil, ::T.untyped)
  ASSEMBLE_CXX = ::T.let(nil, ::T.untyped)
  CLEANINGS = ::T.let(nil, ::T.untyped)
  COMMON_HEADERS = ::T.let(nil, ::T.untyped)
  COMMON_LIBS = ::T.let(nil, ::T.untyped)
  COMPILE_C = ::T.let(nil, ::T.untyped)
  COMPILE_CXX = ::T.let(nil, ::T.untyped)
  COMPILE_RULES = ::T.let(nil, ::T.untyped)
  CONFIG = ::T.let(nil, ::T.untyped)
  CONFTEST = ::T.let(nil, ::T.untyped)
  CONFTEST_C = ::T.let(nil, ::T.untyped)
  CONFTEST_CXX = ::T.let(nil, ::T.untyped)
  COUTFLAG = ::T.let(nil, ::T.untyped)
  CPPOUTFILE = ::T.let(nil, ::T.untyped)
  CSRCFLAG = ::T.let(nil, ::T.untyped)
  CXX_EXT = ::T.let(nil, ::T.untyped)
  C_EXT = ::T.let(nil, ::T.untyped)
  EXPORT_PREFIX = ::T.let(nil, ::T.untyped)
  FailedMessage = ::T.let(nil, ::T.untyped)
  HDR_EXT = ::T.let(nil, ::T.untyped)
  INSTALL_DIRS = ::T.let(nil, ::T.untyped)
  LIBARG = ::T.let(nil, ::T.untyped)
  LIBPATHFLAG = ::T.let(nil, ::T.untyped)
  LINK_SO = ::T.let(nil, ::T.untyped)
  MAIN_DOES_NOTHING = ::T.let(nil, ::T.untyped)
  ORIG_LIBPATH = ::T.let(nil, ::T.untyped)
  OUTFLAG = ::T.let(nil, ::T.untyped)
  RPATHFLAG = ::T.let(nil, ::T.untyped)
  RULE_SUBST = ::T.let(nil, ::T.untyped)
  SRC_EXT = ::T.let(nil, ::T.untyped)
  STRING_OR_FAILED_FORMAT = ::T.let(nil, ::T.untyped)
  TRY_LINK = ::T.let(nil, ::T.untyped)
  TRY_LINK_CXX = ::T.let(nil, ::T.untyped)
  UNIVERSAL_INTS = ::T.let(nil, ::T.untyped)
end

module MakeMakefile::Logging
end

module MakeMakefile::Logging
  def self.log_close(); end

  def self.log_open(); end

  def self.log_opened?(); end

  def self.logfile(file); end

  def self.open(); end

  def self.postpone(); end

  def self.quiet(); end

  def self.quiet=(quiet); end
end

module MakeMakefile
  def self.[](name); end

  def self.[]=(name, mod); end
end

module Marcel
  VERSION = ::T.let(nil, ::T.untyped)
end

class Marcel::MimeType
  BINARY = ::T.let(nil, ::T.untyped)
end

class Marcel::MimeType
  def self.extend(type, extensions: T.unsafe(nil), parents: T.unsafe(nil), magic: T.unsafe(nil)); end

  def self.for(pathname_or_io=T.unsafe(nil), name: T.unsafe(nil), extension: T.unsafe(nil), declared_type: T.unsafe(nil)); end
end

module Marshal
  extend ::ActiveSupport::MarshalWithAutoloading
  def self.restore(*_); end
end

class Matrix
  include ::Enumerable
  include ::ExceptionForMatrix
  include ::Matrix::CoercionHelper
  def *(m); end

  def **(other); end

  def +(m); end

  def +@(); end

  def -(m); end

  def -@(); end

  def /(other); end

  def ==(other); end

  def [](i, j); end

  def []=(i, j, v); end

  def abs(); end

  def adjugate(); end

  def antisymmetric?(); end

  def coerce(other); end

  def cofactor(row, column); end

  def cofactor_expansion(row: T.unsafe(nil), column: T.unsafe(nil)); end

  def collect(which=T.unsafe(nil), &block); end

  def collect!(which=T.unsafe(nil)); end

  def column(j); end

  def column_count(); end

  def column_size(); end

  def column_vectors(); end

  def combine(*matrices, &block); end

  def component(i, j); end

  def conj(); end

  def conjugate(); end

  def det(); end

  def det_e(); end

  def determinant(); end

  def determinant_e(); end

  def diagonal?(); end

  def each(which=T.unsafe(nil), &block); end

  def each_with_index(which=T.unsafe(nil)); end

  def eigen(); end

  def eigensystem(); end

  def element(i, j); end

  def elements_to_f(); end

  def elements_to_i(); end

  def elements_to_r(); end

  def empty?(); end

  def entrywise_product(m); end

  def eql?(other); end

  def find_index(*args); end

  def first_minor(row, column); end

  def hadamard_product(m); end

  def hermitian?(); end

  def hstack(*matrices); end

  def imag(); end

  def imaginary(); end

  def index(*args); end

  def initialize(rows, column_count=T.unsafe(nil)); end

  def inv(); end

  def inverse(); end

  def laplace_expansion(row: T.unsafe(nil), column: T.unsafe(nil)); end

  def lower_triangular?(); end

  def lup(); end

  def lup_decomposition(); end

  def map(which=T.unsafe(nil), &block); end

  def map!(which=T.unsafe(nil)); end

  def minor(*param); end

  def normal?(); end

  def orthogonal?(); end

  def permutation?(); end

  def rank(); end

  def rank_e(); end

  def real(); end

  def real?(); end

  def rect(); end

  def rectangular(); end

  def regular?(); end

  def round(ndigits=T.unsafe(nil)); end

  def row(i, &block); end

  def row_count(); end

  def row_size(); end

  def row_vectors(); end

  def rows(); end

  def singular?(); end

  def skew_symmetric?(); end

  def square?(); end

  def symmetric?(); end

  def t(); end

  def to_a(); end

  def to_matrix(); end

  def tr(); end

  def trace(); end

  def transpose(); end

  def unitary?(); end

  def upper_triangular?(); end

  def vstack(*matrices); end

  def zero?(); end
  SELECTORS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Matrix::CoercionHelper
end

module Matrix::CoercionHelper
  def self.check_int(val, count, kind); end

  def self.check_range(val, count, kind); end

  def self.coerce_to(obj, cls, meth); end

  def self.coerce_to_int(obj); end

  def self.coerce_to_matrix(obj); end
end

module Matrix::ConversionHelper
end

module Matrix::ConversionHelper
end

class Matrix::EigenvalueDecomposition
  def d(); end

  def eigenvalue_matrix(); end

  def eigenvalues(); end

  def eigenvector_matrix(); end

  def eigenvector_matrix_inv(); end

  def eigenvectors(); end

  def initialize(a); end

  def to_a(); end

  def to_ary(); end

  def v(); end

  def v_inv(); end
end

class Matrix::EigenvalueDecomposition
end

class Matrix::LUPDecomposition
  include ::Matrix::ConversionHelper
  def det(); end

  def determinant(); end

  def initialize(a); end

  def l(); end

  def p(); end

  def pivots(); end

  def singular?(); end

  def solve(b); end

  def to_a(); end

  def to_ary(); end

  def u(); end
end

class Matrix::LUPDecomposition
end

class Matrix::Scalar
  include ::ExceptionForMatrix
  include ::Matrix::CoercionHelper
  def *(other); end

  def **(other); end

  def +(other); end

  def -(other); end

  def /(other); end

  def initialize(value); end
end

class Matrix::Scalar
end

class Matrix
  extend ::Matrix::ConversionHelper
  def self.I(n); end

  def self.[](*rows); end

  def self.build(row_count, column_count=T.unsafe(nil)); end

  def self.column_vector(column); end

  def self.columns(columns); end

  def self.combine(*matrices); end

  def self.diagonal(*values); end

  def self.empty(row_count=T.unsafe(nil), column_count=T.unsafe(nil)); end

  def self.hstack(x, *matrices); end

  def self.identity(n); end

  def self.row_vector(row); end

  def self.rows(rows, copy=T.unsafe(nil)); end

  def self.scalar(n, value); end

  def self.unit(n); end

  def self.vstack(x, *matrices); end

  def self.zero(row_count, column_count=T.unsafe(nil)); end
end

module MessagePack
  DEFAULT_EMPTY_PARAMS = ::T.let(nil, ::T.untyped)
end

module MessagePack::Time
  Packer = ::T.let(nil, ::T.untyped)
  TIME_AT_3_AVAILABLE = ::T.let(nil, ::T.untyped)
  Unpacker = ::T.let(nil, ::T.untyped)
end

class MessagePack::Timestamp
  TIMESTAMP32_MAX_SEC = ::T.let(nil, ::T.untyped)
  TIMESTAMP64_MAX_SEC = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
end

module MethodSource
  VERSION = ::T.let(nil, ::T.untyped)
end

module MethodSource::CodeHelpers::IncompleteExpression
  GENERIC_REGEXPS = ::T.let(nil, ::T.untyped)
  RBX_ONLY_REGEXPS = ::T.let(nil, ::T.untyped)
end

Methods = T::Private::Methods

module Mime
  ALL = ::T.let(nil, ::T.untyped)
  EXTENSION_LOOKUP = ::T.let(nil, ::T.untyped)
  LOOKUP = ::T.let(nil, ::T.untyped)
  SET = ::T.let(nil, ::T.untyped)
end

class Mime::Type
  MIME_NAME = ::T.let(nil, ::T.untyped)
  MIME_PARAMETER = ::T.let(nil, ::T.untyped)
  MIME_PARAMETER_KEY = ::T.let(nil, ::T.untyped)
  MIME_PARAMETER_VALUE = ::T.let(nil, ::T.untyped)
  MIME_REGEXP = ::T.let(nil, ::T.untyped)
end

module MiniMime
  VERSION = ::T.let(nil, ::T.untyped)
end

class MiniMime::Db
  LOCK = ::T.let(nil, ::T.untyped)
end

class MiniMime::Db::RandomAccessDb
  MAX_CACHED = ::T.let(nil, ::T.untyped)
end

class MiniMime::Info
  BINARY_ENCODINGS = ::T.let(nil, ::T.untyped)
end

module Minitest
end

MiniTest::Assertions = Minitest::Assertions

MiniTest::Guard = Minitest::Guard

MiniTest::Reportable = Minitest::Reportable

MiniTest::Runnable = Minitest::Runnable

MiniTest::Test = Minitest::Test

module Minitest
end

module Minitest
  ENCS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Minitest::Assertions
  E = ::T.let(nil, ::T.untyped)
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

class Minitest::BacktraceFilter
  MT_RE = ::T.let(nil, ::T.untyped)
end

class Minitest::Runnable
  SIGNALS = ::T.let(nil, ::T.untyped)
end

class Minitest::Test
  PASSTHROUGH_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  TEARDOWN_METHODS = ::T.let(nil, ::T.untyped)
end

class Minitest::Unit
  VERSION = ::T.let(nil, ::T.untyped)
end

class Module
  def class_name(); end

  def const_source_location(*_); end

  def deprecate_constant(*_); end

  def undef_method(*_); end
  DELEGATION_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
  DELEGATION_RESERVED_METHOD_NAMES = ::T.let(nil, ::T.untyped)
  RUBY_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
end

class Module
  def self.used_modules(); end
end

class Monitor
  def enter(); end

  def exit(); end

  def mon_check_owner(); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_enter(); end

  def try_mon_enter(); end

  def wait_for_cond(_, _1); end
end

module MonitorMixin
  def initialize(*args); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(&b); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(&b); end

  def try_mon_enter(); end
end

class MonitorMixin::ConditionVariable
  def broadcast(); end

  def initialize(monitor); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(); end

  def wait_while(); end
end

module MonitorMixin
  def self.extend_object(obj); end
end

class Mtransaction
  def after_add_for_categories(); end

  def after_add_for_categories=(val); end

  def after_add_for_categories?(); end

  def after_remove_for_categories(); end

  def after_remove_for_categories=(val); end

  def after_remove_for_categories?(); end

  def autosave_associated_records_for_account(*args); end

  def autosave_associated_records_for_categories(*args); end

  def autosave_associated_records_for_location(*args); end

  def before_add_for_categories(); end

  def before_add_for_categories=(val); end

  def before_add_for_categories?(); end

  def before_remove_for_categories(); end

  def before_remove_for_categories=(val); end

  def before_remove_for_categories?(); end

  def validate_associated_records_for_categories(*args); end
end

class Mtransaction::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Mtransaction::GeneratedRelationMethods
end

class Mtransaction::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Mtransaction::GeneratedRelationMethods
end

class Mtransaction::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Mtransaction::GeneratedRelationMethods
end

module Mtransaction::GeneratedAssociationMethods
  def build_account(*args, &block); end

  def build_location(*args, &block); end

  def categories(); end

  def categories=(value); end

  def category_ids(); end

  def category_ids=(ids); end

  def create_account(*args, &block); end

  def create_account!(*args, &block); end

  def create_location(*args, &block); end

  def create_location!(*args, &block); end

  def location(); end

  def location=(value); end

  def reload_account(); end

  def reload_location(); end
end

module Mtransaction::GeneratedAttributeMethods
  extend ::Mutex_m
end

module Mtransaction::GeneratedRelationMethods
end

module Mtransaction::GeneratedRelationMethods
  extend ::Mutex_m
end

class Mtransaction
  def self.after_add_for_categories(); end

  def self.after_add_for_categories=(val); end

  def self.after_add_for_categories?(); end

  def self.after_remove_for_categories(); end

  def self.after_remove_for_categories=(val); end

  def self.after_remove_for_categories?(); end

  def self.before_add_for_categories(); end

  def self.before_add_for_categories=(val); end

  def self.before_add_for_categories?(); end

  def self.before_remove_for_categories(); end

  def self.before_remove_for_categories=(val); end

  def self.before_remove_for_categories?(); end
end

module Mutex_m
  VERSION = ::T.let(nil, ::T.untyped)
end

class NameError
  include ::DidYouMean::Correctable
  def name(); end

  def receiver(); end
end

class Net::APOP
end

class Net::APOP
end

Net::APOPSession = Net::APOP

class Net::BufferedIO
  def write_timeout(); end

  def write_timeout=(write_timeout); end
end

class Net::HTTP
  def ipaddr(); end

  def ipaddr=(addr); end

  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def write_timeout(); end

  def write_timeout=(sec); end
  ENVIRONMENT_VARIABLE_IS_MULTIUSER_SAFE = ::T.let(nil, ::T.untyped)
end

Net::HTTP::ProxyMod = Net::HTTP::ProxyDelta

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

Net::HTTPClientError::EXCEPTION_TYPE = Net::HTTPServerException

Net::HTTPClientErrorCode = Net::HTTPClientError

Net::HTTPClientException = Net::HTTPServerException

class Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPEarlyHints
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

class Net::HTTPGatewayTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPGatewayTimeout
end

class Net::HTTPInformation
end

Net::HTTPInformationCode::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPInformation
end

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPayloadTooLarge
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRangeNotSatisfiable
end

Net::HTTPRedirection::EXCEPTION_TYPE = Net::HTTPRetriableError

Net::HTTPRedirectionCode = Net::HTTPRedirection

class Net::HTTPRequestTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRequestTimeout
end

Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

Net::HTTPRetriableCode = Net::HTTPRedirection

Net::HTTPServerError::EXCEPTION_TYPE = Net::HTTPFatalError

Net::HTTPServerErrorCode = Net::HTTPServerError

Net::HTTPSession = Net::HTTP

Net::HTTPSuccess::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPSuccessCode = Net::HTTPSuccess

class Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPURITooLong
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

class Net::IMAP
  def open_timeout(); end

  RESPONSE_ERRORS = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::NumValidator
  def self.ensure_mod_sequence_value(num); end

  def self.valid_mod_sequence_value?(num); end
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::POP = Net::POP3

class Net::POP3
  def active?(); end

  def address(); end

  def apop?(); end

  def auth_only(account, password); end

  def delete_all(); end

  def disable_ssl(); end

  def each(&block); end

  def each_mail(&block); end

  def enable_ssl(verify_or_params=T.unsafe(nil), certs=T.unsafe(nil), port=T.unsafe(nil)); end

  def finish(); end

  def initialize(addr, port=T.unsafe(nil), isapop=T.unsafe(nil)); end

  def logging(msg); end

  def mails(); end

  def n_bytes(); end

  def n_mails(); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def port(); end

  def read_timeout(); end

  def read_timeout=(sec); end

  def reset(); end

  def set_all_uids(); end

  def set_debug_output(arg); end

  def start(account, password); end

  def started?(); end

  def use_ssl?(); end
  Revision = ::T.let(nil, ::T.untyped)
end

class Net::POP3
  def self.APOP(isapop); end

  def self.auth_only(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil)); end

  def self.certs(); end

  def self.create_ssl_params(verify_or_params=T.unsafe(nil), certs=T.unsafe(nil)); end

  def self.default_pop3_port(); end

  def self.default_pop3s_port(); end

  def self.default_port(); end

  def self.delete_all(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.disable_ssl(); end

  def self.enable_ssl(*args); end

  def self.foreach(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.socket_type(); end

  def self.ssl_params(); end

  def self.start(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.use_ssl?(); end

  def self.verify(); end
end

class Net::POP3Command
  def apop(account, password); end

  def auth(account, password); end

  def dele(num); end

  def initialize(sock); end

  def list(); end

  def quit(); end

  def retr(num, &block); end

  def rset(); end

  def socket(); end

  def stat(); end

  def top(num, lines=T.unsafe(nil), &block); end

  def uidl(num=T.unsafe(nil)); end
end

class Net::POP3Command
end

Net::POP3Session = Net::POP3

class Net::POPAuthenticationError
end

class Net::POPAuthenticationError
end

class Net::POPBadResponse
end

class Net::POPBadResponse
end

class Net::POPError
end

class Net::POPError
end

class Net::POPMail
  def all(dest=T.unsafe(nil), &block); end

  def delete(); end

  def delete!(); end

  def deleted?(); end

  def header(dest=T.unsafe(nil)); end

  def initialize(num, len, pop, cmd); end

  def length(); end

  def mail(dest=T.unsafe(nil), &block); end

  def number(); end

  def pop(dest=T.unsafe(nil), &block); end

  def size(); end

  def top(lines, dest=T.unsafe(nil)); end

  def uid=(uid); end

  def uidl(); end

  def unique_id(); end
end

class Net::POPMail
end

Net::POPSession = Net::POP3

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

Net::SMTPSession = Net::SMTP

class Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Net::WriteTimeout
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  def to_d(); end

  def to_i(); end
end

class NoMatchingPatternError
end

class NoMatchingPatternError
end

class NoMethodError
  def args(); end

  def private_call?(); end
end

module Nokogiri
  LIBXML_ICONV_ENABLED = ::T.let(nil, ::T.untyped)
  LIBXML_PARSER_VERSION = ::T.let(nil, ::T.untyped)
  LIBXML_VERSION = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXML2_PATCHES = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXML2_PATH = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXSLT_PATCHES = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXSLT_PATH = ::T.let(nil, ::T.untyped)
  NOKOGIRI_USE_PACKAGED_LIBRARIES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_INFO = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Node
  ALLOW_COMBINATOR_ON_SELF = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Parser
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

module Nokogiri::Decorators::Slop
  XPATH_PREFIX = ::T.let(nil, ::T.untyped)
end

module Nokogiri::HTML
  NamedCharacters = ::T.let(nil, ::T.untyped)
end

class Nokogiri::HTML::ElementDescription
  ACTION_ATTR = ::T.let(nil, ::T.untyped)
  ALIGN_ATTR = ::T.let(nil, ::T.untyped)
  ALT_ATTR = ::T.let(nil, ::T.untyped)
  APPLET_ATTRS = ::T.let(nil, ::T.untyped)
  AREA_ATTRS = ::T.let(nil, ::T.untyped)
  ATTRS = ::T.let(nil, ::T.untyped)
  A_ATTRS = ::T.let(nil, ::T.untyped)
  BASEFONT_ATTRS = ::T.let(nil, ::T.untyped)
  BGCOLOR_ATTR = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  BLOCKLI_ELT = ::T.let(nil, ::T.untyped)
  BODY_ATTRS = ::T.let(nil, ::T.untyped)
  BODY_CONTENTS = ::T.let(nil, ::T.untyped)
  BODY_DEPR = ::T.let(nil, ::T.untyped)
  BUTTON_ATTRS = ::T.let(nil, ::T.untyped)
  CELLHALIGN = ::T.let(nil, ::T.untyped)
  CELLVALIGN = ::T.let(nil, ::T.untyped)
  CLEAR_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ELT = ::T.let(nil, ::T.untyped)
  COMPACT_ATTR = ::T.let(nil, ::T.untyped)
  COMPACT_ATTRS = ::T.let(nil, ::T.untyped)
  CONTENT_ATTR = ::T.let(nil, ::T.untyped)
  COREATTRS = ::T.let(nil, ::T.untyped)
  CORE_ATTRS = ::T.let(nil, ::T.untyped)
  CORE_I18N_ATTRS = ::T.let(nil, ::T.untyped)
  DIR_ATTR = ::T.let(nil, ::T.untyped)
  DL_CONTENTS = ::T.let(nil, ::T.untyped)
  DefaultDescriptions = ::T.let(nil, ::T.untyped)
  EDIT_ATTRS = ::T.let(nil, ::T.untyped)
  EMBED_ATTRS = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  EVENTS = ::T.let(nil, ::T.untyped)
  FIELDSET_CONTENTS = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
  FLOW_PARAM = ::T.let(nil, ::T.untyped)
  FONTSTYLE = ::T.let(nil, ::T.untyped)
  FONT_ATTRS = ::T.let(nil, ::T.untyped)
  FORMCTRL = ::T.let(nil, ::T.untyped)
  FORM_ATTRS = ::T.let(nil, ::T.untyped)
  FORM_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAMESET_ATTRS = ::T.let(nil, ::T.untyped)
  FRAMESET_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAME_ATTRS = ::T.let(nil, ::T.untyped)
  HEADING = ::T.let(nil, ::T.untyped)
  HEAD_ATTRS = ::T.let(nil, ::T.untyped)
  HEAD_CONTENTS = ::T.let(nil, ::T.untyped)
  HREF_ATTRS = ::T.let(nil, ::T.untyped)
  HR_DEPR = ::T.let(nil, ::T.untyped)
  HTML_ATTRS = ::T.let(nil, ::T.untyped)
  HTML_CDATA = ::T.let(nil, ::T.untyped)
  HTML_CONTENT = ::T.let(nil, ::T.untyped)
  HTML_FLOW = ::T.let(nil, ::T.untyped)
  HTML_INLINE = ::T.let(nil, ::T.untyped)
  HTML_PCDATA = ::T.let(nil, ::T.untyped)
  I18N = ::T.let(nil, ::T.untyped)
  I18N_ATTRS = ::T.let(nil, ::T.untyped)
  IFRAME_ATTRS = ::T.let(nil, ::T.untyped)
  IMG_ATTRS = ::T.let(nil, ::T.untyped)
  INLINE = ::T.let(nil, ::T.untyped)
  INLINE_P = ::T.let(nil, ::T.untyped)
  INPUT_ATTRS = ::T.let(nil, ::T.untyped)
  LABEL_ATTR = ::T.let(nil, ::T.untyped)
  LABEL_ATTRS = ::T.let(nil, ::T.untyped)
  LANGUAGE_ATTR = ::T.let(nil, ::T.untyped)
  LEGEND_ATTRS = ::T.let(nil, ::T.untyped)
  LINK_ATTRS = ::T.let(nil, ::T.untyped)
  LIST = ::T.let(nil, ::T.untyped)
  LI_ELT = ::T.let(nil, ::T.untyped)
  MAP_CONTENTS = ::T.let(nil, ::T.untyped)
  META_ATTRS = ::T.let(nil, ::T.untyped)
  MODIFIER = ::T.let(nil, ::T.untyped)
  NAME_ATTR = ::T.let(nil, ::T.untyped)
  NOFRAMES_CONTENT = ::T.let(nil, ::T.untyped)
  OBJECT_ATTRS = ::T.let(nil, ::T.untyped)
  OBJECT_CONTENTS = ::T.let(nil, ::T.untyped)
  OBJECT_DEPR = ::T.let(nil, ::T.untyped)
  OL_ATTRS = ::T.let(nil, ::T.untyped)
  OPTGROUP_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ELT = ::T.let(nil, ::T.untyped)
  PARAM_ATTRS = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PHRASE = ::T.let(nil, ::T.untyped)
  PRE_CONTENT = ::T.let(nil, ::T.untyped)
  PROMPT_ATTRS = ::T.let(nil, ::T.untyped)
  QUOTE_ATTRS = ::T.let(nil, ::T.untyped)
  ROWS_COLS_ATTR = ::T.let(nil, ::T.untyped)
  SCRIPT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_CONTENT = ::T.let(nil, ::T.untyped)
  SPECIAL = ::T.let(nil, ::T.untyped)
  SRC_ALT_ATTRS = ::T.let(nil, ::T.untyped)
  STYLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_CONTENTS = ::T.let(nil, ::T.untyped)
  TABLE_DEPR = ::T.let(nil, ::T.untyped)
  TALIGN_ATTRS = ::T.let(nil, ::T.untyped)
  TARGET_ATTR = ::T.let(nil, ::T.untyped)
  TEXTAREA_ATTRS = ::T.let(nil, ::T.untyped)
  TH_TD_ATTR = ::T.let(nil, ::T.untyped)
  TH_TD_DEPR = ::T.let(nil, ::T.untyped)
  TR_CONTENTS = ::T.let(nil, ::T.untyped)
  TR_ELT = ::T.let(nil, ::T.untyped)
  TYPE_ATTR = ::T.let(nil, ::T.untyped)
  UL_DEPR = ::T.let(nil, ::T.untyped)
  VERSION_ATTR = ::T.let(nil, ::T.untyped)
  WIDTH_ATTR = ::T.let(nil, ::T.untyped)
end

Nokogiri::HTML::ElementDescription::Desc = Struct::HTMLElementDescription

module Nokogiri::XML
  XML_C14N_1_0 = ::T.let(nil, ::T.untyped)
  XML_C14N_1_1 = ::T.let(nil, ::T.untyped)
  XML_C14N_EXCLUSIVE_1_0 = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Document
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NCNAME_CHAR = ::T.let(nil, ::T.untyped)
  NCNAME_RE = ::T.let(nil, ::T.untyped)
  NCNAME_START_CHAR = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::ElementContent
  ELEMENT = ::T.let(nil, ::T.untyped)
  MULT = ::T.let(nil, ::T.untyped)
  ONCE = ::T.let(nil, ::T.untyped)
  OPT = ::T.let(nil, ::T.untyped)
  OR = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PLUS = ::T.let(nil, ::T.untyped)
  SEQ = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::EntityDecl
  EXTERNAL_GENERAL_PARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_GENERAL_UNPARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_GENERAL = ::T.let(nil, ::T.untyped)
  INTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_PREDEFINED = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Node
  ATTRIBUTE_DECL = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_NODE = ::T.let(nil, ::T.untyped)
  CDATA_SECTION_NODE = ::T.let(nil, ::T.untyped)
  COMMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCB_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_FRAG_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_TYPE_NODE = ::T.let(nil, ::T.untyped)
  DTD_NODE = ::T.let(nil, ::T.untyped)
  ELEMENT_DECL = ::T.let(nil, ::T.untyped)
  ELEMENT_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_DECL = ::T.let(nil, ::T.untyped)
  ENTITY_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_REF_NODE = ::T.let(nil, ::T.untyped)
  HTML_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NAMESPACE_DECL = ::T.let(nil, ::T.untyped)
  NOTATION_NODE = ::T.let(nil, ::T.untyped)
  PI_NODE = ::T.let(nil, ::T.untyped)
  TEXT_NODE = ::T.let(nil, ::T.untyped)
  XINCLUDE_END = ::T.let(nil, ::T.untyped)
  XINCLUDE_START = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::NodeSet
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::ParseOptions
  COMPACT = ::T.let(nil, ::T.untyped)
  DEFAULT_HTML = ::T.let(nil, ::T.untyped)
  DEFAULT_XML = ::T.let(nil, ::T.untyped)
  DTDATTR = ::T.let(nil, ::T.untyped)
  DTDLOAD = ::T.let(nil, ::T.untyped)
  DTDVALID = ::T.let(nil, ::T.untyped)
  HUGE = ::T.let(nil, ::T.untyped)
  NOBASEFIX = ::T.let(nil, ::T.untyped)
  NOBLANKS = ::T.let(nil, ::T.untyped)
  NOCDATA = ::T.let(nil, ::T.untyped)
  NODICT = ::T.let(nil, ::T.untyped)
  NOENT = ::T.let(nil, ::T.untyped)
  NOERROR = ::T.let(nil, ::T.untyped)
  NONET = ::T.let(nil, ::T.untyped)
  NOWARNING = ::T.let(nil, ::T.untyped)
  NOXINCNODE = ::T.let(nil, ::T.untyped)
  NSCLEAN = ::T.let(nil, ::T.untyped)
  OLD10 = ::T.let(nil, ::T.untyped)
  PEDANTIC = ::T.let(nil, ::T.untyped)
  RECOVER = ::T.let(nil, ::T.untyped)
  SAX1 = ::T.let(nil, ::T.untyped)
  STRICT = ::T.let(nil, ::T.untyped)
  XINCLUDE = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Reader
  TYPE_ATTRIBUTE = ::T.let(nil, ::T.untyped)
  TYPE_CDATA = ::T.let(nil, ::T.untyped)
  TYPE_COMMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_FRAGMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_TYPE = ::T.let(nil, ::T.untyped)
  TYPE_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY_REFERENCE = ::T.let(nil, ::T.untyped)
  TYPE_NONE = ::T.let(nil, ::T.untyped)
  TYPE_NOTATION = ::T.let(nil, ::T.untyped)
  TYPE_PROCESSING_INSTRUCTION = ::T.let(nil, ::T.untyped)
  TYPE_SIGNIFICANT_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_TEXT = ::T.let(nil, ::T.untyped)
  TYPE_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_XML_DECLARATION = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::SAX::Parser
  ENCODINGS = ::T.let(nil, ::T.untyped)
end

module Nokogiri::XML::Searchable
  LOOKS_LIKE_XPATH = ::T.let(nil, ::T.untyped)
end

class Numeric
  EXABYTE = ::T.let(nil, ::T.untyped)
  GIGABYTE = ::T.let(nil, ::T.untyped)
  KILOBYTE = ::T.let(nil, ::T.untyped)
  MEGABYTE = ::T.let(nil, ::T.untyped)
  PETABYTE = ::T.let(nil, ::T.untyped)
  TERABYTE = ::T.let(nil, ::T.untyped)
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::PP::ObjectMixin
  include ::MakeMakefile
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::ActiveSupport::Dependencies::ZeitwerkIntegration::RequireDependency
  def dclone(); end

  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  CloseDiv = ::T.let(nil, ::T.untyped)
  DecorativeClosing = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  OpenDiv = ::T.let(nil, ::T.untyped)
  RUBY18 = ::T.let(nil, ::T.untyped)
  RUBY19 = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  StartPipe = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class ObjectSpace::WeakMap
  def [](_); end

  def []=(_, _1); end

  def each(&blk); end

  def each_key(); end

  def each_pair(); end

  def each_value(); end

  def key?(_); end

  def keys(); end

  def length(); end

  def size(); end

  def values(); end
end

module ObjectSpace
  def self.count_objects(*_); end

  def self.define_finalizer(*_); end

  def self.garbage_collect(full_mark: T.unsafe(nil), immediate_mark: T.unsafe(nil), immediate_sweep: T.unsafe(nil)); end

  def self.undefine_finalizer(_); end
end

module Observable
  def add_observer(observer, func=T.unsafe(nil)); end

  def changed(state=T.unsafe(nil)); end

  def changed?(); end

  def count_observers(); end

  def delete_observer(observer); end

  def delete_observers(); end

  def notify_observers(*arg); end
end

module Observable
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(_); end

  def negative?(); end
end

module OpenSSL::Buffering
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

module OpenSSL::KDF
end

class OpenSSL::KDF::KDFError
end

class OpenSSL::KDF::KDFError
end

module OpenSSL::KDF
  def self.hkdf(*_); end

  def self.pbkdf2_hmac(*_); end

  def self.scrypt(*_); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::EC
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Point
  def to_octet_string(_); end
end

class OpenSSL::PKey::RSA
  def sign_pss(*_); end

  def verify_pss(*_); end
end

module OpenSSL::SSL
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

module OpenSSL::X509
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  def ==(other); end
end

class OpenSSL::X509::CRL
  def ==(other); end
end

class OpenSSL::X509::Extension
  def ==(other); end
end

class OpenSSL::X509::Name
  def to_utf8(); end
end

class OpenSSL::X509::Request
  def ==(other); end
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end
end

class OpenStruct
  VERSION = ::T.let(nil, ::T.untyped)
end

class OptionParser
  def additional_message(typ, opt); end
end

class OptionParser::List
  def get_candidates(id); end
end

class OptionParser::ParseError
  def additional(); end

  def additional=(additional); end

end

module Parlour
  VERSION = ::T.let(nil, ::T.untyped)
end

module Parlour::Debugging::Tree
  INDENT_SPACES = ::T.let(nil, ::T.untyped)
end

class Parlour::RbiGenerator::Parameter
  PREFIXES = ::T.let(nil, ::T.untyped)
end

ParseError = Racc::ParseError

class Parser::Builders::Default
  def __ENCODING__(__ENCODING__t); end

  def __FILE__(__FILE__t); end

  def __LINE__(__LINE__t); end

  def accessible(node); end

  def alias(alias_t, to, from); end

  def arg(name_t); end

  def arg_expr(expr); end

  def args(begin_t, args, end_t, check_args=T.unsafe(nil)); end

  def array(begin_t, elements, end_t); end

  def array_pattern(lbrack_t, elements, rbrack_t); end

  def assign(lhs, eql_t, rhs); end

  def assignable(node); end

  def associate(begin_t, pairs, end_t); end

  def attr_asgn(receiver, dot_t, selector_t); end

  def back_ref(token); end

  def begin(begin_t, body, end_t); end

  def begin_body(compound_stmt, rescue_bodies=T.unsafe(nil), else_t=T.unsafe(nil), else_=T.unsafe(nil), ensure_t=T.unsafe(nil), ensure_=T.unsafe(nil)); end

  def begin_keyword(begin_t, body, end_t); end

  def binary_op(receiver, operator_t, arg); end

  def block(method_call, begin_t, args, body, end_t); end

  def block_pass(amper_t, arg); end

  def blockarg(amper_t, name_t); end

  def blockarg_expr(amper_t, expr); end

  def call_lambda(lambda_t); end

  def call_method(receiver, dot_t, selector_t, lparen_t=T.unsafe(nil), args=T.unsafe(nil), rparen_t=T.unsafe(nil)); end

  def call_type_for_dot(dot_t); end

  def case(case_t, expr, when_bodies, else_t, else_body, end_t); end

  def case_match(case_t, expr, in_bodies, else_t, else_body, end_t); end

  def character(char_t); end

  def complex(complex_t); end

  def compstmt(statements); end

  def condition(cond_t, cond, then_t, if_true, else_t, if_false, end_t); end

  def condition_mod(if_true, if_false, cond_t, cond); end

  def const(name_t); end

  def const_fetch(scope, t_colon2, name_t); end

  def const_global(t_colon3, name_t); end

  def const_op_assignable(node); end

  def const_pattern(const, ldelim_t, pattern, rdelim_t); end

  def cvar(token); end

  def dedent_string(node, dedent_level); end

  def def_class(class_t, name, lt_t, superclass, body, end_t); end

  def def_method(def_t, name_t, args, body, end_t); end

  def def_module(module_t, name, body, end_t); end

  def def_sclass(class_t, lshft_t, expr, body, end_t); end

  def def_singleton(def_t, definee, dot_t, name_t, args, body, end_t); end

  def emit_file_line_as_literals(); end

  def emit_file_line_as_literals=(emit_file_line_as_literals); end

  def false(false_t); end

  def float(float_t); end

  def for(for_t, iterator, in_t, iteratee, do_t, body, end_t); end

  def forward_args(begin_t, dots_t, end_t); end

  def forwarded_args(dots_t); end

  def gvar(token); end

  def hash_pattern(lbrace_t, kwargs, rbrace_t); end

  def ident(token); end

  def if_guard(if_t, if_body); end

  def in_match(lhs, in_t, rhs); end

  def in_pattern(in_t, pattern, guard, then_t, body); end

  def index(receiver, lbrack_t, indexes, rbrack_t); end

  def index_asgn(receiver, lbrack_t, indexes, rbrack_t); end

  def integer(integer_t); end

  def ivar(token); end

  def keyword_cmd(type, keyword_t, lparen_t=T.unsafe(nil), args=T.unsafe(nil), rparen_t=T.unsafe(nil)); end

  def kwarg(name_t); end

  def kwnilarg(dstar_t, nil_t); end

  def kwoptarg(name_t, value); end

  def kwrestarg(dstar_t, name_t=T.unsafe(nil)); end

  def kwsplat(dstar_t, arg); end

  def logical_op(type, lhs, op_t, rhs); end

  def loop(type, keyword_t, cond, do_t, body, end_t); end

  def loop_mod(type, body, keyword_t, cond); end

  def match_alt(left, pipe_t, right); end

  def match_as(value, assoc_t, as); end

  def match_hash_var(name_t); end

  def match_hash_var_from_str(begin_t, strings, end_t); end

  def match_label(label_type, label); end

  def match_nil_pattern(dstar_t, nil_t); end

  def match_op(receiver, match_t, arg); end

  def match_pair(label_type, label, value); end

  def match_rest(star_t, name_t=T.unsafe(nil)); end

  def match_var(name_t); end

  def match_with_trailing_comma(match); end

  def multi_assign(lhs, eql_t, rhs); end

  def multi_lhs(begin_t, items, end_t); end

  def nil(nil_t); end

  def not_op(not_t, begin_t=T.unsafe(nil), receiver=T.unsafe(nil), end_t=T.unsafe(nil)); end

  def nth_ref(token); end

  def numargs(max_numparam); end

  def objc_kwarg(kwname_t, assoc_t, name_t); end

  def objc_restarg(star_t, name=T.unsafe(nil)); end

  def objc_varargs(pair, rest_of_varargs); end

  def op_assign(lhs, op_t, rhs); end

  def optarg(name_t, eql_t, value); end

  def pair(key, assoc_t, value); end

  def pair_keyword(key_t, value); end

  def pair_list_18(list); end

  def pair_quoted(begin_t, parts, end_t, value); end

  def parser(); end

  def parser=(parser); end

  def pin(pin_t, var); end

  def postexe(postexe_t, lbrace_t, compstmt, rbrace_t); end

  def preexe(preexe_t, lbrace_t, compstmt, rbrace_t); end

  def procarg0(arg); end

  def range_exclusive(lhs, dot3_t, rhs); end

  def range_inclusive(lhs, dot2_t, rhs); end

  def rational(rational_t); end

  def regexp_compose(begin_t, parts, end_t, options); end

  def regexp_options(regopt_t); end

  def rescue_body(rescue_t, exc_list, assoc_t, exc_var, then_t, compound_stmt); end

  def restarg(star_t, name_t=T.unsafe(nil)); end

  def restarg_expr(star_t, expr=T.unsafe(nil)); end

  def self(token); end

  def shadowarg(name_t); end

  def splat(star_t, arg=T.unsafe(nil)); end

  def string(string_t); end

  def string_compose(begin_t, parts, end_t); end

  def string_internal(string_t); end

  def symbol(symbol_t); end

  def symbol_compose(begin_t, parts, end_t); end

  def symbol_internal(symbol_t); end

  def symbols_compose(begin_t, parts, end_t); end

  def ternary(cond, question_t, if_true, colon_t, if_false); end

  def true(true_t); end

  def unary_num(unary_t, numeric); end

  def unary_op(op_t, receiver); end

  def undef_method(undef_t, names); end

  def unless_guard(unless_t, unless_body); end

  def when(when_t, patterns, then_t, body); end

  def word(parts); end

  def words_compose(begin_t, parts, end_t); end

  def xstring_compose(begin_t, parts, end_t); end
end

class Parser::Builders::Default
  def self.emit_arg_inside_procarg0(); end

  def self.emit_arg_inside_procarg0=(emit_arg_inside_procarg0); end

  def self.emit_encoding(); end

  def self.emit_encoding=(emit_encoding); end

  def self.emit_index(); end

  def self.emit_index=(emit_index); end

  def self.emit_lambda(); end

  def self.emit_lambda=(emit_lambda); end

  def self.emit_procarg0(); end

  def self.emit_procarg0=(emit_procarg0); end

  def self.modernize(); end
end

class Parsers::ExcelParser
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Pathname
  def empty?(); end

  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end
end

class Proc
  def <<(_); end

  def ===(*_); end

  def >>(_); end

  def clone(); end

  def ruby2_keywords(); end

  def yield(*_); end
end

module Process
  CLOCK_MONOTONIC_RAW_APPROX = ::T.let(nil, ::T.untyped)
  CLOCK_UPTIME_RAW = ::T.let(nil, ::T.untyped)
  CLOCK_UPTIME_RAW_APPROX = ::T.let(nil, ::T.untyped)
end

module Process::Sys
  def self.getegid(); end
end

class Process::Tms
  def cstime(); end

  def cstime=(_); end

  def cutime(); end

  def cutime=(_); end

  def stime(); end

  def stime=(_); end

  def utime(); end

  def utime=(_); end
end

class Process::Tms
  def self.[](*_); end

  def self.members(); end
end

module Process
  def self.last_status(); end

  def self.setpgrp(); end
end

module Psych
  LIBYAML_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Psych::BadAlias
end

class Psych::BadAlias
end

class Psych::ClassLoader
  def big_decimal(); end

  def complex(); end

  def date(); end

  def date_time(); end

  def exception(); end

  def load(klassname); end

  def object(); end

  def psych_omap(); end

  def psych_set(); end

  def range(); end

  def rational(); end

  def regexp(); end

  def struct(); end

  def symbol(); end

  def symbolize(sym); end
  BIG_DECIMAL = ::T.let(nil, ::T.untyped)
  CACHE = ::T.let(nil, ::T.untyped)
  COMPLEX = ::T.let(nil, ::T.untyped)
  DATE = ::T.let(nil, ::T.untyped)
  DATE_TIME = ::T.let(nil, ::T.untyped)
  EXCEPTION = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  PSYCH_OMAP = ::T.let(nil, ::T.untyped)
  PSYCH_SET = ::T.let(nil, ::T.untyped)
  RANGE = ::T.let(nil, ::T.untyped)
  RATIONAL = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
end

class Psych::ClassLoader::Restricted
  def initialize(classes, symbols); end
end

class Psych::ClassLoader::Restricted
end

class Psych::ClassLoader
end

class Psych::Coder
  def [](k); end

  def []=(k, v); end

  def add(k, v); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(tag); end

  def map(tag=T.unsafe(nil), style=T.unsafe(nil)); end

  def map=(map); end

  def object(); end

  def object=(object); end

  def represent_map(tag, map); end

  def represent_object(tag, obj); end

  def represent_scalar(tag, value); end

  def represent_seq(tag, list); end

  def scalar(*args); end

  def scalar=(value); end

  def seq(); end

  def seq=(list); end

  def style(); end

  def style=(style); end

  def tag(); end

  def tag=(tag); end

  def type(); end
end

class Psych::Coder
end

class Psych::DisallowedClass
  def initialize(klass_name); end
end

class Psych::DisallowedClass
end

class Psych::Emitter
  def alias(_); end

  def canonical(); end

  def canonical=(canonical); end

  def end_document(_); end

  def indentation(); end

  def indentation=(indentation); end

  def initialize(*_); end

  def line_width(); end

  def line_width=(line_width); end

  def scalar(_, _1, _2, _3, _4, _5); end

  def start_document(_, _1, _2); end

  def start_mapping(_, _1, _2, _3); end

  def start_sequence(_, _1, _2, _3); end

  def start_stream(_); end
end

class Psych::Emitter
end

class Psych::Exception
end

class Psych::Exception
end

class Psych::Handler
  def alias(anchor); end

  def empty(); end

  def end_document(implicit); end

  def end_mapping(); end

  def end_sequence(); end

  def end_stream(); end

  def event_location(start_line, start_column, end_line, end_column); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end

  def start_stream(encoding); end

  def streaming?(); end
  EVENTS = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Psych::Handler::DumperOptions
  def canonical(); end

  def canonical=(canonical); end

  def indentation(); end

  def indentation=(indentation); end

  def line_width(); end

  def line_width=(line_width); end
end

class Psych::Handler::DumperOptions
end

class Psych::Handler
end

module Psych::Handlers
end

class Psych::Handlers::DocumentStream
  def initialize(&block); end
end

class Psych::Handlers::DocumentStream
end

module Psych::Handlers
end

module Psych::JSON
end

module Psych::JSON::RubyEvents
  def visit_DateTime(o); end

  def visit_String(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end
end

module Psych::JSON::RubyEvents
end

class Psych::JSON::Stream
  include ::Psych::Streaming
end

class Psych::JSON::Stream::Emitter
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::Stream::Emitter
end

class Psych::JSON::Stream
  extend ::Psych::Streaming::ClassMethods
end

class Psych::JSON::TreeBuilder
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::TreeBuilder
end

module Psych::JSON::YAMLEvents
  def end_document(implicit_end=T.unsafe(nil)); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end
end

module Psych::JSON::YAMLEvents
end

module Psych::JSON
end

module Psych::Nodes
end

class Psych::Nodes::Alias
  def anchor(); end

  def anchor=(anchor); end

  def initialize(anchor); end
end

class Psych::Nodes::Alias
end

class Psych::Nodes::Document
  def implicit(); end

  def implicit=(implicit); end

  def implicit_end(); end

  def implicit_end=(implicit_end); end

  def initialize(version=T.unsafe(nil), tag_directives=T.unsafe(nil), implicit=T.unsafe(nil)); end

  def root(); end

  def tag_directives(); end

  def tag_directives=(tag_directives); end

  def version(); end

  def version=(version); end
end

class Psych::Nodes::Document
end

class Psych::Nodes::Mapping
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Mapping
end

class Psych::Nodes::Node
  include ::Enumerable
  def alias?(); end

  def children(); end

  def document?(); end

  def each(&block); end

  def end_column(); end

  def end_column=(end_column); end

  def end_line(); end

  def end_line=(end_line); end

  def mapping?(); end

  def scalar?(); end

  def sequence?(); end

  def start_column(); end

  def start_column=(start_column); end

  def start_line(); end

  def start_line=(start_line); end

  def stream?(); end

  def tag(); end

  def to_ruby(); end

  def to_yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end

  def transform(); end

  def yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Psych::Nodes::Node
end

class Psych::Nodes::Scalar
  def anchor(); end

  def anchor=(anchor); end

  def initialize(value, anchor=T.unsafe(nil), tag=T.unsafe(nil), plain=T.unsafe(nil), quoted=T.unsafe(nil), style=T.unsafe(nil)); end

  def plain(); end

  def plain=(plain); end

  def quoted(); end

  def quoted=(quoted); end

  def style(); end

  def style=(style); end

  def tag=(tag); end

  def value(); end

  def value=(value); end
  ANY = ::T.let(nil, ::T.untyped)
  DOUBLE_QUOTED = ::T.let(nil, ::T.untyped)
  FOLDED = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
  PLAIN = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTED = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Scalar
end

class Psych::Nodes::Sequence
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Sequence
end

class Psych::Nodes::Stream
  def encoding(); end

  def encoding=(encoding); end

  def initialize(encoding=T.unsafe(nil)); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Stream
end

module Psych::Nodes
end

class Psych::Omap
end

class Psych::Omap
end

class Psych::Parser
  def external_encoding=(external_encoding); end

  def handler(); end

  def handler=(handler); end

  def initialize(handler=T.unsafe(nil)); end

  def mark(); end

  def parse(*_); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Parser::Mark
end

class Psych::Parser::Mark
end

class Psych::Parser
end

class Psych::ScalarScanner
  def class_loader(); end

  def initialize(class_loader); end

  def parse_int(string); end

  def parse_time(string); end

  def tokenize(string); end
  FLOAT = ::T.let(nil, ::T.untyped)
  INTEGER = ::T.let(nil, ::T.untyped)
  TIME = ::T.let(nil, ::T.untyped)
end

class Psych::ScalarScanner
end

class Psych::Set
end

class Psych::Set
end

class Psych::Stream
  include ::Psych::Streaming
end

class Psych::Stream::Emitter
  def end_document(implicit_end=T.unsafe(nil)); end
end

class Psych::Stream::Emitter
end

class Psych::Stream
  extend ::Psych::Streaming::ClassMethods
end

module Psych::Streaming
  def start(encoding=T.unsafe(nil)); end
end

module Psych::Streaming::ClassMethods
  def new(io); end
end

module Psych::Streaming::ClassMethods
end

module Psych::Streaming
end

class Psych::SyntaxError
  def column(); end

  def context(); end

  def file(); end

  def initialize(file, line, col, offset, problem, context); end

  def line(); end

  def offset(); end

  def problem(); end
end

class Psych::SyntaxError
end

class Psych::TreeBuilder
  def end_document(implicit_end=T.unsafe(nil)); end

  def root(); end
end

class Psych::TreeBuilder
end

module Psych::Visitors
end

class Psych::Visitors::DepthFirst
  def initialize(block); end
end

class Psych::Visitors::DepthFirst
end

class Psych::Visitors::Emitter
  def initialize(io, options=T.unsafe(nil)); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
end

class Psych::Visitors::Emitter
end

class Psych::Visitors::JSONTree
  include ::Psych::JSON::RubyEvents
end

class Psych::Visitors::JSONTree
  def self.create(options=T.unsafe(nil)); end
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::ToRuby
  def class_loader(); end

  def initialize(ss, class_loader); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
  SHOVEL = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::ToRuby
  def self.create(); end
end

class Psych::Visitors::Visitor
  def accept(target); end
  DISPATCH = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::Visitor
end

class Psych::Visitors::YAMLTree
  def <<(object); end

  def finish(); end

  def finished(); end

  def finished?(); end

  def initialize(emitter, ss, options); end

  def push(object); end

  def start(encoding=T.unsafe(nil)); end

  def started(); end

  def started?(); end

  def tree(); end

  def visit_Array(o); end

  def visit_BasicObject(o); end

  def visit_BigDecimal(o); end

  def visit_Class(o); end

  def visit_Complex(o); end

  def visit_Date(o); end

  def visit_DateTime(o); end

  def visit_Delegator(o); end

  def visit_Encoding(o); end

  def visit_Enumerator(o); end

  def visit_Exception(o); end

  def visit_FalseClass(o); end

  def visit_Float(o); end

  def visit_Hash(o); end

  def visit_Integer(o); end

  def visit_Module(o); end

  def visit_NameError(o); end

  def visit_NilClass(o); end

  def visit_Object(o); end

  def visit_Psych_Omap(o); end

  def visit_Psych_Set(o); end

  def visit_Range(o); end

  def visit_Rational(o); end

  def visit_Regexp(o); end

  def visit_String(o); end

  def visit_Struct(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end

  def visit_TrueClass(o); end
end

class Psych::Visitors::YAMLTree
  def self.create(options=T.unsafe(nil), emitter=T.unsafe(nil)); end
end

module Psych::Visitors
end

module Psych
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump(o, io=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.dump_stream(*objects); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil)); end

  def self.load_file(path); end

  def self.load_stream(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil)); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.parse(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil)); end

  def self.parse_file(filename, fallback: T.unsafe(nil)); end

  def self.parse_stream(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), &block); end

  def self.parser(); end

  def self.remove_type(type_tag); end

  def self.safe_load(yaml, legacy_permitted_classes=T.unsafe(nil), legacy_permitted_symbols=T.unsafe(nil), legacy_aliases=T.unsafe(nil), legacy_filename=T.unsafe(nil), permitted_classes: T.unsafe(nil), permitted_symbols: T.unsafe(nil), aliases: T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil)); end

  def self.to_json(object); end
end

module PublicSuffix
  BANG = ::T.let(nil, ::T.untyped)
  DOT = ::T.let(nil, ::T.untyped)
  STAR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class PublicSuffix::List
  DEFAULT_LIST_PATH = ::T.let(nil, ::T.untyped)
end

module Puma
  HTTP_STATUS_CODES = ::T.let(nil, ::T.untyped)
  IS_JRUBY = ::T.let(nil, ::T.untyped)
  IS_WINDOWS = ::T.let(nil, ::T.untyped)
  Plugins = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
end

class Puma::Binder
  RACK_VERSION = ::T.let(nil, ::T.untyped)
end

class Puma::Client
  EmptyBody = ::T.let(nil, ::T.untyped)
end

class Puma::Cluster
  WORKER_CHECK_INTERVAL = ::T.let(nil, ::T.untyped)
end

module Puma::ConfigDefault
  DefaultRackup = ::T.let(nil, ::T.untyped)
  DefaultTCPHost = ::T.let(nil, ::T.untyped)
  DefaultTCPPort = ::T.let(nil, ::T.untyped)
  DefaultWorkerShutdownTimeout = ::T.let(nil, ::T.untyped)
  DefaultWorkerTimeout = ::T.let(nil, ::T.untyped)
end

module Puma::Const
  CGI_VER = ::T.let(nil, ::T.untyped)
  CHUNKED = ::T.let(nil, ::T.untyped)
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
  CLOSE = ::T.let(nil, ::T.untyped)
  CLOSE_CHUNKED = ::T.let(nil, ::T.untyped)
  CODE_NAME = ::T.let(nil, ::T.untyped)
  COLON = ::T.let(nil, ::T.untyped)
  CONNECTION_CLOSE = ::T.let(nil, ::T.untyped)
  CONNECTION_KEEP_ALIVE = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH2 = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH_S = ::T.let(nil, ::T.untyped)
  CONTINUE = ::T.let(nil, ::T.untyped)
  EARLY_HINTS = ::T.let(nil, ::T.untyped)
  ERROR_400_RESPONSE = ::T.let(nil, ::T.untyped)
  ERROR_404_RESPONSE = ::T.let(nil, ::T.untyped)
  ERROR_408_RESPONSE = ::T.let(nil, ::T.untyped)
  ERROR_500_RESPONSE = ::T.let(nil, ::T.untyped)
  ERROR_503_RESPONSE = ::T.let(nil, ::T.untyped)
  FAST_TRACK_KA_TIMEOUT = ::T.let(nil, ::T.untyped)
  FIRST_DATA_TIMEOUT = ::T.let(nil, ::T.untyped)
  GATEWAY_INTERFACE = ::T.let(nil, ::T.untyped)
  HALT_COMMAND = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  HIJACK = ::T.let(nil, ::T.untyped)
  HIJACK_IO = ::T.let(nil, ::T.untyped)
  HIJACK_P = ::T.let(nil, ::T.untyped)
  HTTP = ::T.let(nil, ::T.untyped)
  HTTPS = ::T.let(nil, ::T.untyped)
  HTTPS_KEY = ::T.let(nil, ::T.untyped)
  HTTP_10_200 = ::T.let(nil, ::T.untyped)
  HTTP_11 = ::T.let(nil, ::T.untyped)
  HTTP_11_100 = ::T.let(nil, ::T.untyped)
  HTTP_11_200 = ::T.let(nil, ::T.untyped)
  HTTP_CONNECTION = ::T.let(nil, ::T.untyped)
  HTTP_EXPECT = ::T.let(nil, ::T.untyped)
  HTTP_HOST = ::T.let(nil, ::T.untyped)
  HTTP_VERSION = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_FOR = ::T.let(nil, ::T.untyped)
  KEEP_ALIVE = ::T.let(nil, ::T.untyped)
  LINE_END = ::T.let(nil, ::T.untyped)
  LOCALHOST = ::T.let(nil, ::T.untyped)
  LOCALHOST_ADDR = ::T.let(nil, ::T.untyped)
  LOCALHOST_IP = ::T.let(nil, ::T.untyped)
  MAX_BODY = ::T.let(nil, ::T.untyped)
  MAX_FAST_INLINE = ::T.let(nil, ::T.untyped)
  MAX_HEADER = ::T.let(nil, ::T.untyped)
  NEWLINE = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  PERSISTENT_TIMEOUT = ::T.let(nil, ::T.untyped)
  PORT_443 = ::T.let(nil, ::T.untyped)
  PORT_80 = ::T.let(nil, ::T.untyped)
  PUMA_CONFIG = ::T.let(nil, ::T.untyped)
  PUMA_PEERCERT = ::T.let(nil, ::T.untyped)
  PUMA_SERVER_STRING = ::T.let(nil, ::T.untyped)
  PUMA_SOCKET = ::T.let(nil, ::T.untyped)
  PUMA_TMP_BASE = ::T.let(nil, ::T.untyped)
  PUMA_VERSION = ::T.let(nil, ::T.untyped)
  QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_AFTER_REPLY = ::T.let(nil, ::T.untyped)
  RACK_INPUT = ::T.let(nil, ::T.untyped)
  RACK_URL_SCHEME = ::T.let(nil, ::T.untyped)
  REMOTE_ADDR = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_PATH = ::T.let(nil, ::T.untyped)
  REQUEST_URI = ::T.let(nil, ::T.untyped)
  RESTART_COMMAND = ::T.let(nil, ::T.untyped)
  SERVER_NAME = ::T.let(nil, ::T.untyped)
  SERVER_PORT = ::T.let(nil, ::T.untyped)
  SERVER_PROTOCOL = ::T.let(nil, ::T.untyped)
  SERVER_SOFTWARE = ::T.let(nil, ::T.untyped)
  STOP_COMMAND = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING2 = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING_CHUNKED = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  WRITE_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Puma::Events
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puma::HttpParserError
end

class Puma::HttpParserError
end

class Puma::Launcher
  KEYS_NOT_TO_PERSIST_IN_STATE = ::T.let(nil, ::T.untyped)
end

module Puma::MiniSSL
  OPENSSL_LIBRARY_VERSION = ::T.let(nil, ::T.untyped)
  OPENSSL_VERSION = ::T.let(nil, ::T.untyped)
  VERIFY_FAIL_IF_NO_PEER_CERT = ::T.let(nil, ::T.untyped)
  VERIFY_NONE = ::T.let(nil, ::T.untyped)
  VERIFY_PEER = ::T.let(nil, ::T.untyped)
end

class Puma::MiniSSL::SSLError
end

class Puma::MiniSSL::SSLError
end

class Puma::Plugin
  CALLER_FILE = ::T.let(nil, ::T.untyped)
end

class Puma::Reactor
  DefaultSleepFor = ::T.let(nil, ::T.untyped)
end

class Puma::Server
  ThreadLocalKey = ::T.let(nil, ::T.untyped)
end

class Puma::ThreadPool
  SHUTDOWN_GRACE_TIME = ::T.let(nil, ::T.untyped)
end

module Puma::Util
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
end

module RDoc
  ATTR_MODIFIERS = ::T.let(nil, ::T.untyped)
  CLASS_MODIFIERS = ::T.let(nil, ::T.untyped)
  CONSTANT_MODIFIERS = ::T.let(nil, ::T.untyped)
  DOT_DOC_FILENAME = ::T.let(nil, ::T.untyped)
  GENERAL_MODIFIERS = ::T.let(nil, ::T.untyped)
  KNOWN_CLASSES = ::T.let(nil, ::T.untyped)
  METHOD_MODIFIERS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VISIBILITIES = ::T.let(nil, ::T.untyped)
end

class RDoc::Alias
  def aref(); end

  def full_old_name(); end

  def html_name(); end

  def initialize(text, old_name, new_name, comment, singleton=T.unsafe(nil)); end

  def name(); end

  def name_prefix(); end

  def new_name(); end

  def old_name(); end

  def pretty_name(); end

  def pretty_new_name(); end

  def pretty_old_name(); end

  def singleton(); end

  def singleton=(singleton); end

  def text(); end
end

class RDoc::Alias
end

class RDoc::AnonClass
end

class RDoc::AnonClass
end

class RDoc::AnyMethod
  include ::RDoc::TokenStream
  def add_alias(an_alias, context=T.unsafe(nil)); end

  def c_function(); end

  def c_function=(c_function); end

  def call_seq=(call_seq); end

  def calls_super(); end

  def calls_super=(calls_super); end

  def dont_rename_initialize(); end

  def dont_rename_initialize=(dont_rename_initialize); end

  def marshal_dump(); end

  def marshal_load(array); end

  def param_list(); end

  def superclass_method(); end
  MARSHAL_VERSION = ::T.let(nil, ::T.untyped)
end

class RDoc::AnyMethod
end

class RDoc::Attr
  def calls_super(); end

  def definition(); end

  def initialize(text, name, rw, comment, singleton=T.unsafe(nil)); end

  def marshal_dump(); end

  def marshal_load(array); end

  def rw(); end

  def rw=(rw); end

  def token_stream(); end
  MARSHAL_VERSION = ::T.let(nil, ::T.untyped)
end

class RDoc::Attr
end

class RDoc::ClassModule
  def add_comment(comment, location); end

  def add_things(my_things, other_things); end

  def ancestors(); end

  def aref(); end

  def aref_prefix(); end

  def clear_comment(); end

  def comment_location(); end

  def comment_location=(comment_location); end

  def complete(min_visibility); end

  def constant_aliases(); end

  def constant_aliases=(constant_aliases); end

  def diagram(); end

  def diagram=(diagram); end

  def direct_ancestors(); end

  def document_self_or_methods(); end

  def find_ancestor_local_symbol(symbol); end

  def find_class_named(name); end

  def initialize(name, superclass=T.unsafe(nil)); end

  def is_alias_for(); end

  def is_alias_for=(is_alias_for); end

  def marshal_dump(); end

  def marshal_load(array); end

  def merge(class_module); end

  def merge_collections(mine, other, other_files, &block); end

  def merge_sections(cm); end

  def module?(); end

  def name=(new_name); end

  def non_aliases(); end

  def parse(comment_location); end

  def path(); end

  def remove_nodoc_children(); end

  def remove_things(my_things, other_files); end

  def search_record(); end

  def superclass(); end

  def superclass=(superclass); end

  def type(); end

  def update_aliases(); end

  def update_extends(); end

  def update_includes(); end
  MARSHAL_VERSION = ::T.let(nil, ::T.untyped)
end

class RDoc::ClassModule
  def self.from_module(class_type, mod); end
end

class RDoc::CodeObject
  include ::RDoc::Text
  include ::RDoc::Generator::Markup
  def comment(); end

  def comment=(comment); end

  def display?(); end

  def document_children(); end

  def document_children=(document_children); end

  def document_self(); end

  def document_self=(document_self); end

  def documented?(); end

  def done_documenting(); end

  def done_documenting=(value); end

  def each_parent(); end

  def file(); end

  def file_name(); end

  def force_documentation(); end

  def force_documentation=(value); end

  def full_name=(full_name); end

  def ignore(); end

  def ignored?(); end

  def initialize_visibility(); end

  def line(); end

  def line=(line); end

  def metadata(); end

  def options(); end

  def parent(); end

  def parent=(parent); end

  def parent_file_name(); end

  def parent_name(); end

  def received_nodoc(); end

  def record_location(top_level); end

  def section(); end

  def section=(section); end

  def start_doc(); end

  def stop_doc(); end

  def store(); end

  def store=(store); end

  def suppress(); end

  def suppressed?(); end

  def viewer(); end

  def viewer=(viewer); end
end

class RDoc::CodeObject
end

class RDoc::Comment
  include ::RDoc::Text
  def ==(other); end

  def document=(document); end

  def empty?(); end

  def encode!(encoding); end

  def extract_call_seq(method); end

  def file(); end

  def format(); end

  def format=(format); end

  def initialize(text=T.unsafe(nil), location=T.unsafe(nil), language=T.unsafe(nil)); end

  def line(); end

  def line=(line); end

  def location(); end

  def location=(location); end

  def normalize(); end

  def normalized?(); end

  def parse(); end

  def remove_private(); end

  def text(); end

  def text=(text); end

  def tomdoc?(); end
end

class RDoc::Comment
end

class RDoc::Constant
  def ==(other); end

  def full_name(); end

  def initialize(name, value, comment); end

  def is_alias_for(); end

  def is_alias_for=(is_alias_for); end

  def marshal_dump(); end

  def marshal_load(array); end

  def name(); end

  def name=(name); end

  def path(); end

  def value(); end

  def value=(value); end

  def visibility(); end

  def visibility=(visibility); end
  MARSHAL_VERSION = ::T.let(nil, ::T.untyped)
end

class RDoc::Constant
end

class RDoc::Context
  include ::Comparable
  def add(klass, name, comment); end

  def add_alias(an_alias); end

  def add_attribute(attribute); end

  def add_class(class_type, given_name, superclass=T.unsafe(nil)); end

  def add_class_or_module(mod, self_hash, all_hash); end

  def add_constant(constant); end

  def add_extend(ext); end

  def add_include(include); end

  def add_method(method); end

  def add_module(class_type, name); end

  def add_module_alias(from, from_name, to, file); end

  def add_module_by_normal_module(mod); end

  def add_require(require); end

  def add_section(title, comment=T.unsafe(nil)); end

  def add_to(array, thing); end

  def aliases(); end

  def any_content(includes=T.unsafe(nil)); end

  def attributes(); end

  def block_params(); end

  def block_params=(block_params); end

  def child_name(name); end

  def class_attributes(); end

  def class_method_list(); end

  def classes(); end

  def classes_and_modules(); end

  def classes_hash(); end

  def constants(); end

  def constants_hash(); end

  def current_line_visibility=(current_line_visibility); end

  def current_section(); end

  def current_section=(current_section); end

  def defined_in?(file); end

  def display(method_attr); end

  def each_ancestor(); end

  def each_attribute(); end

  def each_classmodule(&block); end

  def each_constant(); end

  def each_extend(); end

  def each_include(); end

  def each_method(); end

  def each_section(); end

  def extends(); end

  def external_aliases(); end

  def find_attribute(name, singleton); end

  def find_attribute_named(name); end

  def find_class_method_named(name); end

  def find_constant_named(name); end

  def find_enclosing_module_named(name); end

  def find_external_alias(name, singleton); end

  def find_external_alias_named(name); end

  def find_file_named(name); end

  def find_instance_method_named(name); end

  def find_local_symbol(symbol); end

  def find_method(name, singleton); end

  def find_method_named(name); end

  def find_module_named(name); end

  def find_symbol(symbol); end

  def find_symbol_module(symbol); end

  def full_name(); end

  def fully_documented?(); end

  def http_url(prefix); end

  def in_files(); end

  def includes(); end

  def initialize_methods_etc(); end

  def instance_attributes(); end

  def instance_method_list(); end

  def method_list(); end

  def methods_by_type(section=T.unsafe(nil)); end

  def methods_hash(); end

  def methods_matching(methods, singleton=T.unsafe(nil), &block); end

  def modules(); end

  def modules_hash(); end

  def name(); end

  def name_for_path(); end

  def ongoing_visibility=(visibility); end

  def params(); end

  def params=(params); end

  def remove_from_documentation?(); end

  def remove_invisible(min_visibility); end

  def remove_invisible_in(array, min_visibility); end

  def requires(); end

  def resolve_aliases(added); end

  def section_contents(); end

  def sections(); end

  def sections_hash(); end

  def set_constant_visibility_for(names, visibility); end

  def set_current_section(title, comment); end

  def set_visibility_for(methods, visibility, singleton=T.unsafe(nil)); end

  def sort_sections(); end

  def temporary_section(); end

  def temporary_section=(temporary_section); end

  def top_level(); end

  def unmatched_alias_lists(); end

  def unmatched_alias_lists=(unmatched_alias_lists); end

  def upgrade_to_class(mod, class_type, enclosing); end

  def visibility(); end

  def visibility=(visibility); end
  TOMDOC_TITLES = ::T.let(nil, ::T.untyped)
  TOMDOC_TITLES_SORT = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class RDoc::Context::Section
  include ::RDoc::Text
  include ::RDoc::Generator::Markup
  def ==(other); end

  def add_comment(comment); end

  def aref(); end

  def comment(); end

  def comments(); end

  def eql?(other); end

  def extract_comment(comment); end

  def in_files(); end

  def initialize(parent, title, comment); end

  def marshal_dump(); end

  def marshal_load(array); end

  def parent(); end

  def parse(); end

  def plain_html(); end

  def remove_comment(comment); end

  def sequence(); end

  def title(); end
  MARSHAL_VERSION = ::T.let(nil, ::T.untyped)
end

class RDoc::Context::Section
end

class RDoc::Context
end

class RDoc::CrossReference
  def initialize(context); end

  def resolve(name, text); end

  def seen(); end

  def seen=(seen); end
  ALL_CROSSREF_REGEXP = ::T.let(nil, ::T.untyped)
  CLASS_REGEXP_STR = ::T.let(nil, ::T.untyped)
  CROSSREF_REGEXP = ::T.let(nil, ::T.untyped)
  METHOD_REGEXP_STR = ::T.let(nil, ::T.untyped)
end

class RDoc::CrossReference
end

class RDoc::ERBIO
  def initialize(str, safe_level=T.unsafe(nil), trim_mode=T.unsafe(nil), eoutvar=T.unsafe(nil)); end

  def set_eoutvar(compiler, io_variable); end
end

class RDoc::ERBIO
end

class RDoc::ERBPartial
end

class RDoc::ERBPartial
end

module RDoc::Encoding
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

module RDoc::Encoding
  def self.change_encoding(text, encoding); end

  def self.detect_encoding(string); end

  def self.read_file(filename, encoding, force_transcode=T.unsafe(nil)); end

  def self.remove_frozen_string_literal(string); end

  def self.remove_magic_comment(string); end
end

class RDoc::Error
end

class RDoc::Error
end

class RDoc::Extend
end

class RDoc::Extend
end

module RDoc::Generator
end

class RDoc::Generator::Darkfish
  include ::ERB::Util
  def assemble_template(body_file); end

  def asset_rel_path(); end

  def asset_rel_path=(asset_rel_path); end

  def base_dir(); end

  def class_dir(); end

  def classes(); end

  def copy_static(); end

  def debug_msg(*msg); end

  def dry_run(); end

  def dry_run=(dry_run); end

  def file_dir(); end

  def file_output(); end

  def file_output=(file_output); end

  def files(); end

  def gen_sub_directories(); end

  def generate(); end

  def generate_class(klass, template_file=T.unsafe(nil)); end

  def generate_class_files(); end

  def generate_file_files(); end

  def generate_index(); end

  def generate_page(file); end

  def generate_servlet_not_found(message); end

  def generate_servlet_root(installed); end

  def generate_table_of_contents(); end

  def get_sorted_module_list(classes); end

  def get_svninfo(klass); end

  def initialize(store, options); end

  def install_rdoc_static_file(source, destination, options); end

  def json_index(); end

  def methods(); end

  def modsort(); end

  def outputdir(); end

  def render(file_name); end

  def render_template(template_file, out_file=T.unsafe(nil)); end

  def setup(); end

  def store(); end

  def template_dir(); end

  def template_for(file, page=T.unsafe(nil), klass=T.unsafe(nil)); end

  def template_result(template, context, template_file); end

  def time_delta_string(seconds); end

  def write_style_sheet(); end
  BUILTIN_STYLE_ITEMS = ::T.let(nil, ::T.untyped)
  DESCRIPTION = ::T.let(nil, ::T.untyped)
  GENERATOR_DIR = ::T.let(nil, ::T.untyped)
  SVNID_PATTERN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class RDoc::Generator::Darkfish
end

class RDoc::Generator::JsonIndex
  include ::RDoc::Text
  def build_index(); end

  def class_dir(); end

  def debug_msg(*msg); end

  def file_dir(); end

  def generate(); end

  def generate_gzipped(); end

  def index(); end

  def index_classes(); end

  def index_methods(); end

  def index_pages(); end

  def initialize(parent_generator, options); end

  def reset(files, classes); end

  def search_string(string); end
  SEARCH_INDEX_FILE = ::T.let(nil, ::T.untyped)
end

class RDoc::Generator::JsonIndex
end

module RDoc::Generator::Markup
  def aref_to(target_path); end

  def as_href(from_path); end

  def cvs_url(url, full_path); end

  def description(); end

  def formatter(); end
end

module RDoc::Generator::Markup
end

class RDoc::Generator::POT
  def class_dir(); end

  def generate(); end

  def initialize(store, options); end
  DESCRIPTION = ::T.let(nil, ::T.untyped)
end

class RDoc::Generator::POT::MessageExtractor
  def extract(); end

  def initialize(store); end
end

class RDoc::Generator::POT::MessageExtractor
end

class RDoc::Generator::POT::PO
  def add(entry); end
end

class RDoc::Generator::POT::PO
end

class RDoc::Generator::POT::POEntry
  def extracted_comment(); end

  def flags(); end

  def initialize(msgid, options=T.unsafe(nil)); end

  def merge(other_entry); end

  def msgid(); end

  def msgstr(); end

  def references(); end

  def translator_comment(); end
end

class RDoc::Generator::POT::POEntry
end

class RDoc::Generator::POT
end

class RDoc::Generator::RI
  def generate(); end

  def initialize(store, options); end
  DESCRIPTION = ::T.let(nil, ::T.untyped)
end

class RDoc::Generator::RI
end

module RDoc::Generator
end

class RDoc::GhostMethod
end

class RDoc::GhostMethod
end

module RDoc::I18n
end

class RDoc::I18n::Locale
  def initialize(name); end

  def load(locale_directory); end

  def name(); end

  def translate(message); end
end

class RDoc::I18n::Locale
  def self.[](locale_name); end

  def self.[]=(locale_name, locale); end
end

class RDoc::I18n::Text
  def extract_messages(); end

  def initialize(raw); end

  def translate(locale); end
end

class RDoc::I18n::Text
end

module RDoc::I18n
end

class RDoc::Include
end

class RDoc::Include
end

class RDoc::Markdown
  def _Alphanumeric(); end

  def _AlphanumericAscii(); end

  def _AtxHeading(); end

  def _AtxInline(); end

  def _AtxStart(); end

  def _AutoLink(); end

  def _AutoLinkEmail(); end

  def _AutoLinkUrl(); end

  def _BOM(); end

  def _BlankLine(); end

  def _Block(); end

  def _BlockQuote(); end

  def _BlockQuoteRaw(); end

  def _Bullet(); end

  def _BulletList(); end

  def _CharEntity(); end

  def _Code(); end

  def _CodeFence(); end

  def _DecEntity(); end

  def _DefinitionList(); end

  def _DefinitionListDefinition(); end

  def _DefinitionListItem(); end

  def _DefinitionListLabel(); end

  def _Digit(); end

  def _Doc(); end

  def _Emph(); end

  def _EmphStar(); end

  def _EmphUl(); end

  def _EmptyTitle(); end

  def _Endline(); end

  def _Entity(); end

  def _Enumerator(); end

  def _Eof(); end

  def _EscapedChar(); end

  def _ExplicitLink(); end

  def _ExtendedSpecialChar(); end

  def _Heading(); end

  def _HexEntity(); end

  def _HorizontalRule(); end

  def _HtmlAnchor(); end

  def _HtmlAttribute(); end

  def _HtmlBlock(); end

  def _HtmlBlockAddress(); end

  def _HtmlBlockBlockquote(); end

  def _HtmlBlockCenter(); end

  def _HtmlBlockCloseAddress(); end

  def _HtmlBlockCloseBlockquote(); end

  def _HtmlBlockCloseCenter(); end

  def _HtmlBlockCloseDd(); end

  def _HtmlBlockCloseDir(); end

  def _HtmlBlockCloseDiv(); end

  def _HtmlBlockCloseDl(); end

  def _HtmlBlockCloseDt(); end

  def _HtmlBlockCloseFieldset(); end

  def _HtmlBlockCloseForm(); end

  def _HtmlBlockCloseFrameset(); end

  def _HtmlBlockCloseH1(); end

  def _HtmlBlockCloseH2(); end

  def _HtmlBlockCloseH3(); end

  def _HtmlBlockCloseH4(); end

  def _HtmlBlockCloseH5(); end

  def _HtmlBlockCloseH6(); end

  def _HtmlBlockCloseHead(); end

  def _HtmlBlockCloseLi(); end

  def _HtmlBlockCloseMenu(); end

  def _HtmlBlockCloseNoframes(); end

  def _HtmlBlockCloseNoscript(); end

  def _HtmlBlockCloseOl(); end

  def _HtmlBlockCloseP(); end

  def _HtmlBlockClosePre(); end

  def _HtmlBlockCloseScript(); end

  def _HtmlBlockCloseTable(); end

  def _HtmlBlockCloseTbody(); end

  def _HtmlBlockCloseTd(); end

  def _HtmlBlockCloseTfoot(); end

  def _HtmlBlockCloseTh(); end

  def _HtmlBlockCloseThead(); end

  def _HtmlBlockCloseTr(); end

  def _HtmlBlockCloseUl(); end

  def _HtmlBlockDd(); end

  def _HtmlBlockDir(); end

  def _HtmlBlockDiv(); end

  def _HtmlBlockDl(); end

  def _HtmlBlockDt(); end

  def _HtmlBlockFieldset(); end

  def _HtmlBlockForm(); end

  def _HtmlBlockFrameset(); end

  def _HtmlBlockH1(); end

  def _HtmlBlockH2(); end

  def _HtmlBlockH3(); end

  def _HtmlBlockH4(); end

  def _HtmlBlockH5(); end

  def _HtmlBlockH6(); end

  def _HtmlBlockHead(); end

  def _HtmlBlockInTags(); end

  def _HtmlBlockLi(); end

  def _HtmlBlockMenu(); end

  def _HtmlBlockNoframes(); end

  def _HtmlBlockNoscript(); end

  def _HtmlBlockOl(); end

  def _HtmlBlockOpenAddress(); end

  def _HtmlBlockOpenBlockquote(); end

  def _HtmlBlockOpenCenter(); end

  def _HtmlBlockOpenDd(); end

  def _HtmlBlockOpenDir(); end

  def _HtmlBlockOpenDiv(); end

  def _HtmlBlockOpenDl(); end

  def _HtmlBlockOpenDt(); end

  def _HtmlBlockOpenFieldset(); end

  def _HtmlBlockOpenForm(); end

  def _HtmlBlockOpenFrameset(); end

  def _HtmlBlockOpenH1(); end

  def _HtmlBlockOpenH2(); end

  def _HtmlBlockOpenH3(); end

  def _HtmlBlockOpenH4(); end

  def _HtmlBlockOpenH5(); end

  def _HtmlBlockOpenH6(); end

  def _HtmlBlockOpenHead(); end

  def _HtmlBlockOpenLi(); end

  def _HtmlBlockOpenMenu(); end

  def _HtmlBlockOpenNoframes(); end

  def _HtmlBlockOpenNoscript(); end

  def _HtmlBlockOpenOl(); end

  def _HtmlBlockOpenP(); end

  def _HtmlBlockOpenPre(); end

  def _HtmlBlockOpenScript(); end

  def _HtmlBlockOpenTable(); end

  def _HtmlBlockOpenTbody(); end

  def _HtmlBlockOpenTd(); end

  def _HtmlBlockOpenTfoot(); end

  def _HtmlBlockOpenTh(); end

  def _HtmlBlockOpenThead(); end

  def _HtmlBlockOpenTr(); end

  def _HtmlBlockOpenUl(); end

  def _HtmlBlockP(); end

  def _HtmlBlockPre(); end

  def _HtmlBlockScript(); end

  def _HtmlBlockSelfClosing(); end

  def _HtmlBlockTable(); end

  def _HtmlBlockTbody(); end

  def _HtmlBlockTd(); end

  def _HtmlBlockTfoot(); end

  def _HtmlBlockTh(); end

  def _HtmlBlockThead(); end

  def _HtmlBlockTr(); end

  def _HtmlBlockType(); end

  def _HtmlBlockUl(); end

  def _HtmlCloseAnchor(); end

  def _HtmlComment(); end

  def _HtmlOpenAnchor(); end

  def _HtmlTag(); end

  def _HtmlUnclosed(); end

  def _HtmlUnclosedType(); end

  def _Image(); end

  def _InStyleTags(); end

  def _Indent(); end

  def _IndentedLine(); end

  def _Inline(); end

  def _InlineNote(); end

  def _Inlines(); end

  def _Label(); end

  def _Line(); end

  def _LineBreak(); end

  def _Link(); end

  def _ListBlock(); end

  def _ListBlockLine(); end

  def _ListContinuationBlock(); end

  def _ListItem(); end

  def _ListItemTight(); end

  def _ListLoose(); end

  def _ListTight(); end

  def _Newline(); end

  def _NonblankIndentedLine(); end

  def _NonindentSpace(); end

  def _Nonspacechar(); end

  def _NormalChar(); end

  def _NormalEndline(); end

  def _Note(); end

  def _NoteReference(); end

  def _Notes(); end

  def _OptionallyIndentedLine(); end

  def _OrderedList(); end

  def _Para(); end

  def _Plain(); end

  def _Quoted(); end

  def _RawHtml(); end

  def _RawLine(); end

  def _RawNoteBlock(); end

  def _RawNoteReference(); end

  def _RefSrc(); end

  def _RefTitle(); end

  def _RefTitleDouble(); end

  def _RefTitleParens(); end

  def _RefTitleSingle(); end

  def _Reference(); end

  def _ReferenceLink(); end

  def _ReferenceLinkDouble(); end

  def _ReferenceLinkSingle(); end

  def _References(); end

  def _SetextBottom1(); end

  def _SetextBottom2(); end

  def _SetextHeading(); end

  def _SetextHeading1(); end

  def _SetextHeading2(); end

  def _SkipBlock(); end

  def _Source(); end

  def _SourceContents(); end

  def _Sp(); end

  def _Space(); end

  def _Spacechar(); end

  def _SpecialChar(); end

  def _Spnl(); end

  def _StarLine(); end

  def _StartList(); end

  def _Str(); end

  def _StrChunk(); end

  def _Strike(); end

  def _Strong(); end

  def _StrongStar(); end

  def _StrongUl(); end

  def _StyleBlock(); end

  def _StyleClose(); end

  def _StyleOpen(); end

  def _Symbol(); end

  def _TerminalEndline(); end

  def _Ticks1(); end

  def _Ticks2(); end

  def _Ticks3(); end

  def _Ticks4(); end

  def _Ticks5(); end

  def _Title(); end

  def _TitleDouble(); end

  def _TitleSingle(); end

  def _UlLine(); end

  def _UlOrStarLine(); end

  def _Verbatim(); end

  def _VerbatimChunk(); end

  def _Whitespace(); end

  def _root(); end

  def apply(rule); end

  def apply_with_args(rule, *args); end

  def break_on_newline=(enable); end

  def break_on_newline?(); end

  def css=(enable); end

  def css?(); end

  def current_column(target=T.unsafe(nil)); end

  def current_line(target=T.unsafe(nil)); end

  def definition_lists=(enable); end

  def definition_lists?(); end

  def emphasis(text); end

  def extension(name, enable); end

  def extension?(name); end

  def external_invoke(other, rule, *args); end

  def failed_rule(); end

  def failing_rule_offset(); end

  def failure_caret(); end

  def failure_character(); end

  def failure_info(); end

  def failure_oneline(); end

  def get_byte(); end

  def get_text(start); end

  def github=(enable); end

  def github?(); end

  def grow_lr(rule, args, start_pos, m); end

  def html=(enable); end

  def html?(); end

  def initialize(extensions=T.unsafe(nil), debug=T.unsafe(nil)); end

  def inner_parse(text); end

  def lines(); end

  def link_to(content, label=T.unsafe(nil), text=T.unsafe(nil)); end

  def list_item_from(unparsed); end

  def match_string(str); end

  def note(label); end

  def note_for(ref); end

  def notes=(enable); end

  def notes?(); end

  def paragraph(parts); end

  def parse(markdown); end

  def peg_parse(rule=T.unsafe(nil)); end

  def pos(); end

  def pos=(pos); end

  def raise_error(); end

  def reference(label, link); end

  def result(); end

  def result=(result); end

  def scan(reg); end

  def set_failed_rule(name); end

  def set_string(string, pos); end

  def setup_foreign_grammar(); end

  def setup_parser(str, debug=T.unsafe(nil)); end

  def show_error(io=T.unsafe(nil)); end

  def show_pos(); end

  def strike(text); end

  def strike=(enable); end

  def strike?(); end

  def string(); end

  def strong(text); end
  DEFAULT_EXTENSIONS = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  HTML_ENTITIES = ::T.let(nil, ::T.untyped)
  Rules = ::T.let(nil, ::T.untyped)
end

class RDoc::Markdown::Literals
  def _Alphanumeric(); end

  def _AlphanumericAscii(); end

  def _BOM(); end

  def _Newline(); end

  def _NonAlphanumeric(); end

  def _Spacechar(); end

  def apply(rule); end

  def apply_with_args(rule, *args); end

  def current_column(target=T.unsafe(nil)); end

  def current_line(target=T.unsafe(nil)); end

  def external_invoke(other, rule, *args); end

  def failed_rule(); end

  def failing_rule_offset(); end

  def failure_caret(); end

  def failure_character(); end

  def failure_info(); end

  def failure_oneline(); end

  def get_byte(); end

  def get_text(start); end

  def grow_lr(rule, args, start_pos, m); end

  def initialize(str, debug=T.unsafe(nil)); end

  def lines(); end

  def match_string(str); end

  def parse(rule=T.unsafe(nil)); end

  def pos(); end

  def pos=(pos); end

  def raise_error(); end

  def result(); end

  def result=(result); end

  def scan(reg); end

  def set_failed_rule(name); end

  def set_string(string, pos); end

  def setup_foreign_grammar(); end

  def setup_parser(str, debug=T.unsafe(nil)); end

  def show_error(io=T.unsafe(nil)); end

  def show_pos(); end

  def string(); end
  Rules = ::T.let(nil, ::T.untyped)
end

class RDoc::Markdown::Literals::MemoEntry
  def ans(); end

  def initialize(ans, pos); end

  def left_rec(); end

  def left_rec=(left_rec); end

  def move!(ans, pos, result); end

  def pos(); end

  def result(); end

  def set(); end
end

class RDoc::Markdown::Literals::MemoEntry
end

class RDoc::Markdown::Literals::ParseError
end

class RDoc::Markdown::Literals::ParseError
end

class RDoc::Markdown::Literals::RuleInfo
  def initialize(name, rendered); end

  def name(); end

  def rendered(); end
end

class RDoc::Markdown::Literals::RuleInfo
end

class RDoc::Markdown::Literals
  def self.rule_info(name, rendered); end
end

class RDoc::Markdown::MemoEntry
  def ans(); end

  def initialize(ans, pos); end

  def left_rec(); end

  def left_rec=(left_rec); end

  def move!(ans, pos, result); end

  def pos(); end

  def result(); end

  def set(); end
end

class RDoc::Markdown::MemoEntry
end

class RDoc::Markdown::ParseError
end

class RDoc::Markdown::ParseError
end

class RDoc::Markdown::RuleInfo
  def initialize(name, rendered); end

  def name(); end

  def rendered(); end
end

class RDoc::Markdown::RuleInfo
end

class RDoc::Markdown
  def self.extension(name); end

  def self.parse(markdown); end

  def self.rule_info(name, rendered); end
end

class RDoc::Markup
  def add_html(tag, name); end

  def add_regexp_handling(pattern, name); end

  def add_word_pair(start, stop, name); end

  def attribute_manager(); end

  def convert(input, formatter); end

  def initialize(attribute_manager=T.unsafe(nil)); end
end

class RDoc::Markup::AttrChanger
  def turn_off(); end

  def turn_off=(_); end

  def turn_on(); end

  def turn_on=(_); end
end

class RDoc::Markup::AttrChanger
  def self.[](*_); end

  def self.members(); end
end

class RDoc::Markup::AttrSpan
  def [](n); end

  def initialize(length); end

  def set_attrs(start, length, bits); end
end

class RDoc::Markup::AttrSpan
end

class RDoc::Markup::AttributeManager
  def add_html(tag, name); end

  def add_regexp_handling(pattern, name); end

  def add_word_pair(start, stop, name); end

  def attribute(turn_on, turn_off); end

  def attributes(); end

  def change_attribute(current, new); end

  def changed_attribute_by_name(current_set, new_set); end

  def convert_attrs(str, attrs); end

  def convert_html(str, attrs); end

  def convert_regexp_handlings(str, attrs); end

  def copy_string(start_pos, end_pos); end

  def display_attributes(); end

  def flow(str); end

  def html_tags(); end

  def mask_protected_sequences(); end

  def matching_word_pairs(); end

  def protectable(); end

  def regexp_handlings(); end

  def split_into_flow(); end

  def unmask_protected_sequences(); end

  def word_pair_map(); end
  A_PROTECT = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  PROTECT_ATTR = ::T.let(nil, ::T.untyped)
end

class RDoc::Markup::AttributeManager
end

class RDoc::Markup::Attributes
  def as_string(bitmap); end

  def bitmap_for(name); end

  def each_name_of(bitmap); end

  def regexp_handling(); end
end

class RDoc::Markup::Attributes
end

class RDoc::Markup::BlankLine
  def accept(visitor); end
end

class RDoc::Markup::BlankLine
  def self.new(); end
end

class RDoc::Markup::BlockQuote
end

class RDoc::Markup::BlockQuote
end

class RDoc::Markup::Document
  include ::Enumerable
  def <<(part); end

  def ==(other); end

  def accept(visitor); end

  def concat(parts); end

  def each(&block); end

  def empty?(); end

  def file(); end

  def file=(location); end

  def initialize(*parts); end

  def merge(other); end

  def merged?(); end

  def omit_headings_below(); end

  def omit_headings_below=(omit_headings_below); end

  def parts(); end

  def push(*parts); end

  def table_of_contents(); end
end

class RDoc::Markup::Document
end

class RDoc::Markup::Formatter
  def accept_document(document); end

  def add_regexp_handling_RDOCLINK(); end

  def add_regexp_handling_TIDYLINK(); end

  def add_tag(name, start, stop); end

  def annotate(tag); end

  def convert(content); end

  def convert_flow(flow); end

  def convert_regexp_handling(target); end

  def convert_string(string); end

  def ignore(*node); end

  def in_tt?(); end

  def initialize(options, markup=T.unsafe(nil)); end

  def off_tags(res, item); end

  def on_tags(res, item); end

  def parse_url(url); end

  def tt?(tag); end
end

class RDoc::Markup::Formatter::InlineTag
  def bit(); end

  def bit=(_); end

  def off(); end

  def off=(_); end

  def on(); end

  def on=(_); end
end

class RDoc::Markup::Formatter::InlineTag
  def self.[](*_); end

  def self.members(); end
end

class RDoc::Markup::Formatter
  def self.gen_relative_url(path, target); end
end

class RDoc::Markup::HardBreak
  def ==(other); end

  def accept(visitor); end
end

class RDoc::Markup::HardBreak
  def self.new(); end
end

class RDoc::Markup::Heading
  def accept(visitor); end

  def aref(); end

  def label(context=T.unsafe(nil)); end

  def level(); end

  def level=(_); end

  def plain_html(); end

  def text(); end

  def text=(_); end
end

class RDoc::Markup::Heading
  def self.[](*_); end

  def self.members(); end

  def self.to_html(); end

  def self.to_label(); end
end

class RDoc::Markup::Include
  def ==(other); end

  def file(); end

  def include_path(); end

  def initialize(file, include_path); end
end

class RDoc::Markup::Include
end

class RDoc::Markup::IndentedParagraph
  def indent(); end

  def initialize(indent, *parts); end

  def text(hard_break=T.unsafe(nil)); end
end

class RDoc::Markup::IndentedParagraph
end

class RDoc::Markup::List
  def <<(item); end

  def ==(other); end

  def accept(visitor); end

  def empty?(); end

  def initialize(type=T.unsafe(nil), *items); end

  def items(); end

  def last(); end

  def push(*items); end

  def type(); end

  def type=(type); end
end

class RDoc::Markup::List
end

class RDoc::Markup::ListItem
  def <<(part); end

  def ==(other); end

  def accept(visitor); end

  def empty?(); end

  def initialize(label=T.unsafe(nil), *parts); end

  def label(); end

  def label=(label); end

  def length(); end

  def parts(); end

  def push(*parts); end
end

class RDoc::Markup::ListItem
end

class RDoc::Markup::Paragraph
  def text(hard_break=T.unsafe(nil)); end
end

class RDoc::Markup::Paragraph
end

class RDoc::Markup::Parser
  include ::RDoc::Text
  def build_heading(level); end

  def build_list(margin); end

  def build_paragraph(margin); end

  def build_verbatim(margin); end

  def debug(); end

  def debug=(debug); end

  def get(); end

  def parse(parent, indent=T.unsafe(nil)); end

  def parse_text(parent, indent); end

  def peek_token(); end

  def setup_scanner(input); end

  def skip(token_type, error=T.unsafe(nil)); end

  def tokenize(input); end

  def tokens(); end

  def unget(); end
  LIST_TOKENS = ::T.let(nil, ::T.untyped)
end

class RDoc::Markup::Parser::Error
end

class RDoc::Markup::Parser::Error
end

class RDoc::Markup::Parser::MyStringScanner
  def [](i); end

  def eos?(); end

  def initialize(input); end

  def matched(); end

  def newline!(); end

  def pos(); end

  def scan(re); end

  def unscan(s); end
end

class RDoc::Markup::Parser::MyStringScanner
end

class RDoc::Markup::Parser::ParseError
end

class RDoc::Markup::Parser::ParseError
end

class RDoc::Markup::Parser
  def self.parse(str); end

  def self.tokenize(str); end
end

class RDoc::Markup::PreProcess
  def find_include_file(name); end

  def handle(text, code_object=T.unsafe(nil), &block); end

  def handle_directive(prefix, directive, param, code_object=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def include_file(name, indent, encoding); end

  def initialize(input_file_name, include_path); end

  def options(); end

  def options=(options); end
end

class RDoc::Markup::PreProcess
  def self.post_process(&block); end

  def self.post_processors(); end

  def self.register(directive, &block); end

  def self.registered(); end

  def self.reset(); end
end

class RDoc::Markup::Raw
  def <<(text); end

  def ==(other); end

  def accept(visitor); end

  def initialize(*parts); end

  def merge(other); end

  def parts(); end

  def push(*texts); end

  def text(); end
end

class RDoc::Markup::Raw
end

class RDoc::Markup::RegexpHandling
  def ==(o); end

  def initialize(type, text); end

  def text(); end

  def text=(text); end

  def type(); end
end

class RDoc::Markup::RegexpHandling
end

class RDoc::Markup::Rule
  def accept(visitor); end
end

class RDoc::Markup::Rule
end

class RDoc::Markup::ToAnsi
end

class RDoc::Markup::ToAnsi
end

class RDoc::Markup::ToBs
end

class RDoc::Markup::ToBs
end

class RDoc::Markup::ToHtml
  include ::RDoc::Text
  def accept_blank_line(blank_line); end

  def accept_block_quote(block_quote); end

  def accept_heading(heading); end

  def accept_list_end(list); end

  def accept_list_item_end(list_item); end

  def accept_list_item_start(list_item); end

  def accept_list_start(list); end

  def accept_paragraph(paragraph); end

  def accept_raw(raw); end

  def accept_rule(rule); end

  def accept_verbatim(verbatim); end

  def code_object(); end

  def code_object=(code_object); end

  def convert_string(text); end

  def end_accepting(); end

  def from_path(); end

  def from_path=(from_path); end

  def gen_url(url, text); end

  def handle_RDOCLINK(url); end

  def handle_regexp_HARD_BREAK(target); end

  def handle_regexp_HYPERLINK(target); end

  def handle_regexp_RDOCLINK(target); end

  def handle_regexp_TIDYLINK(target); end

  def html_list_name(list_type, open_tag); end

  def in_list_entry(); end

  def init_tags(); end

  def list(); end

  def list_end_for(list_type); end

  def list_item_start(list_item, list_type); end

  def parseable?(text); end

  def res(); end

  def start_accepting(); end

  def to_html(item); end
  LIST_TYPE_TO_HTML = ::T.let(nil, ::T.untyped)
end

class RDoc::Markup::ToHtml
end

class RDoc::Markup::ToHtmlCrossref
  def context(); end

  def context=(context); end

  def cross_reference(name, text=T.unsafe(nil), code=T.unsafe(nil)); end

  def handle_regexp_CROSSREF(target); end

  def initialize(options, from_path, context, markup=T.unsafe(nil)); end

  def link(name, text, code=T.unsafe(nil)); end

  def show_hash(); end

  def show_hash=(show_hash); end
  ALL_CROSSREF_REGEXP = ::T.let(nil, ::T.untyped)
  CLASS_REGEXP_STR = ::T.let(nil, ::T.untyped)
  CROSSREF_REGEXP = ::T.let(nil, ::T.untyped)
  METHOD_REGEXP_STR = ::T.let(nil, ::T.untyped)
end

class RDoc::Markup::ToHtmlCrossref
end

class RDoc::Markup::ToHtmlSnippet
  def accept_raw(*node); end

  def accept_rule(*node); end

  def add_paragraph(); end

  def character_limit(); end

  def characters(); end

  def handle_regexp_CROSSREF(target); end

  def initialize(options, characters=T.unsafe(nil), paragraphs=T.unsafe(nil), markup=T.unsafe(nil)); end

  def mask(); end

  def paragraph_limit(); end

  def paragraphs(); end

  def truncate(text); end
end

class RDoc::Markup::ToHtmlSnippet
end

class RDoc::Markup::ToJoinedParagraph
  def accept_block_quote(*node); end

  def accept_heading(*node); end

  def accept_list_end(*node); end

  def accept_list_item_end(*node); end

  def accept_list_item_start(*node); end

  def accept_list_start(*node); end

  def accept_paragraph(paragraph); end

  def accept_raw(*node); end

  def accept_rule(*node); end

  def accept_verbatim(*node); end

  def end_accepting(); end

  def initialize(); end

  def start_accepting(); end
end

class RDoc::Markup::ToJoinedParagraph
end

class RDoc::Markup::ToLabel
  def accept_blank_line(*node); end

  def accept_block_quote(*node); end

  def accept_heading(*node); end

  def accept_list_end(*node); end

  def accept_list_item_end(*node); end

  def accept_list_item_start(*node); end

  def accept_list_start(*node); end

  def accept_paragraph(*node); end

  def accept_raw(*node); end

  def accept_rule(*node); end

  def accept_verbatim(*node); end

  def convert(text); end

  def end_accepting(*node); end

  def handle_regexp_CROSSREF(target); end

  def handle_regexp_HARD_BREAK(*node); end

  def handle_regexp_TIDYLINK(target); end

  def initialize(markup=T.unsafe(nil)); end

  def res(); end

  def start_accepting(*node); end
end

class RDoc::Markup::ToLabel
end

class RDoc::Markup::ToMarkdown
  def gen_url(url, text); end

  def handle_rdoc_link(url); end

  def handle_regexp_RDOCLINK(target); end

  def handle_regexp_TIDYLINK(target); end
end

class RDoc::Markup::ToMarkdown
end

class RDoc::Markup::ToRdoc
  def accept_blank_line(blank_line); end

  def accept_block_quote(block_quote); end

  def accept_heading(heading); end

  def accept_indented_paragraph(paragraph); end

  def accept_list_end(list); end

  def accept_list_item_end(list_item); end

  def accept_list_item_start(list_item); end

  def accept_list_start(list); end

  def accept_paragraph(paragraph); end

  def accept_raw(raw); end

  def accept_rule(rule); end

  def accept_verbatim(verbatim); end

  def attributes(text); end

  def end_accepting(); end

  def handle_regexp_HARD_BREAK(target); end

  def handle_regexp_SUPPRESSED_CROSSREF(target); end

  def indent(); end

  def indent=(indent); end

  def init_tags(); end

  def initialize(markup=T.unsafe(nil)); end

  def list_index(); end

  def list_type(); end

  def list_width(); end

  def prefix(); end

  def res(); end

  def start_accepting(); end

  def use_prefix(); end

  def width(); end

  def width=(width); end

  def wrap(text); end
end

class RDoc::Markup::ToRdoc
end

class RDoc::Markup::ToTableOfContents
  def accept_blank_line(*node); end

  def accept_block_quote(*node); end

  def accept_heading(heading); end

  def accept_list_end(*node); end

  def accept_list_end_bullet(*node); end

  def accept_list_item_end(*node); end

  def accept_list_item_start(*node); end

  def accept_list_start(*node); end

  def accept_paragraph(*node); end

  def accept_raw(*node); end

  def accept_rule(*node); end

  def accept_verbatim(*node); end

  def end_accepting(); end

  def initialize(); end

  def omit_headings_below(); end

  def omit_headings_below=(omit_headings_below); end

  def res(); end

  def start_accepting(); end

  def suppressed?(heading); end
end

class RDoc::Markup::ToTableOfContents
  def self.to_toc(); end
end

class RDoc::Markup::ToTest
  def accept_blank_line(blank_line); end

  def accept_heading(heading); end

  def accept_list_end(list); end

  def accept_list_item_end(list_item); end

  def accept_list_item_start(list_item); end

  def accept_list_start(list); end

  def accept_paragraph(paragraph); end

  def accept_raw(raw); end

  def accept_rule(rule); end

  def accept_verbatim(verbatim); end

  def end_accepting(); end

  def start_accepting(); end
end

class RDoc::Markup::ToTest
end

class RDoc::Markup::ToTtOnly
  def accept_blank_line(markup_item); end

  def accept_block_quote(block_quote); end

  def accept_heading(markup_item); end

  def accept_list_end(list); end

  def accept_list_item_end(markup_item); end

  def accept_list_item_start(list_item); end

  def accept_list_start(list); end

  def accept_paragraph(paragraph); end

  def accept_raw(markup_item); end

  def accept_rule(markup_item); end

  def accept_verbatim(markup_item); end

  def do_nothing(markup_item); end

  def end_accepting(); end

  def initialize(markup=T.unsafe(nil)); end

  def list_type(); end

  def res(); end

  def start_accepting(); end

  def tt_sections(text); end
end

class RDoc::Markup::ToTtOnly
end

class RDoc::Markup::Verbatim
  def format(); end

  def format=(format); end

  def normalize(); end

  def ruby?(); end
end

class RDoc::Markup::Verbatim
end

class RDoc::Markup
  def self.parse(str); end
end

class RDoc::MetaMethod
end

class RDoc::MetaMethod
end

class RDoc::MethodAttr
  include ::Comparable
  def ==(other); end

  def add_alias(an_alias, context); end

  def add_line_numbers(src); end

  def aliases(); end

  def aref(); end

  def aref_prefix(); end

  def arglists(); end

  def block_params(); end

  def block_params=(value); end

  def call_seq(); end

  def call_seq=(call_seq); end

  def find_method_or_attribute(name); end

  def find_see(); end

  def full_name(); end

  def html_name(); end

  def initialize(text, name); end

  def is_alias_for(); end

  def is_alias_for=(is_alias_for); end

  def markup_code(); end

  def name(); end

  def name=(name); end

  def name_prefix(); end

  def output_name(context); end

  def param_seq(); end

  def params(); end

  def params=(params); end

  def path(); end

  def pretty_name(); end

  def search_record(); end

  def see(); end

  def singleton(); end

  def singleton=(singleton); end

  def text(); end

  def type(); end

  def visibility(); end

  def visibility=(visibility); end
end

class RDoc::MethodAttr
end

class RDoc::Mixin
  def ==(other); end

  def eql?(other); end

  def full_name(); end

  def initialize(name, comment); end

  def module(); end

  def name(); end

  def name=(name); end
end

class RDoc::Mixin
end

class RDoc::NormalClass
  def definition(); end
end

class RDoc::NormalClass
end

class RDoc::NormalModule
  def definition(); end
end

class RDoc::NormalModule
end

class RDoc::Options
  def ==(other); end

  def charset(); end

  def charset=(charset); end

  def check_files(); end

  def check_generator(); end

  def coverage_report(); end

  def coverage_report=(coverage_report); end

  def default_title=(string); end

  def dry_run(); end

  def dry_run=(dry_run); end

  def encode_with(coder); end

  def encoding(); end

  def encoding=(encoding); end

  def exclude(); end

  def exclude=(exclude); end

  def files(); end

  def files=(files); end

  def finish(); end

  def finish_page_dir(); end

  def force_output(); end

  def force_output=(force_output); end

  def force_update(); end

  def force_update=(force_update); end

  def formatter(); end

  def formatter=(formatter); end

  def generator(); end

  def generator=(generator); end

  def generator_descriptions(); end

  def generator_name(); end

  def generator_options(); end

  def generator_options=(generator_options); end

  def hyperlink_all(); end

  def hyperlink_all=(hyperlink_all); end

  def init_ivars(); end

  def init_with(map); end

  def line_numbers(); end

  def line_numbers=(line_numbers); end

  def locale(); end

  def locale=(locale); end

  def locale_dir(); end

  def locale_dir=(locale_dir); end

  def main_page(); end

  def main_page=(main_page); end

  def markup(); end

  def markup=(markup); end

  def op_dir(); end

  def op_dir=(op_dir); end

  def option_parser(); end

  def option_parser=(option_parser); end

  def output_decoration(); end

  def output_decoration=(output_decoration); end

  def page_dir(); end

  def page_dir=(page_dir); end

  def parse(argv); end

  def pipe(); end

  def pipe=(pipe); end

  def quiet(); end

  def quiet=(bool); end

  def rdoc_include(); end

  def rdoc_include=(rdoc_include); end

  def root(); end

  def root=(root); end

  def sanitize_path(path); end

  def setup_generator(generator_name=T.unsafe(nil)); end

  def show_hash(); end

  def show_hash=(show_hash); end

  def static_path(); end

  def static_path=(static_path); end

  def tab_width(); end

  def tab_width=(tab_width); end

  def template(); end

  def template=(template); end

  def template_dir(); end

  def template_dir=(template_dir); end

  def template_dir_for(template); end

  def template_stylesheets(); end

  def template_stylesheets=(template_stylesheets); end

  def title(); end

  def title=(title); end

  def update_output_dir(); end

  def update_output_dir=(update_output_dir); end

  def verbosity(); end

  def verbosity=(verbosity); end

  def visibility(); end

  def visibility=(visibility); end

  def warn(message); end

  def webcvs(); end

  def webcvs=(webcvs); end

  def write_options(); end

  def yaml_initialize(tag, map); end
  DEPRECATED = ::T.let(nil, ::T.untyped)
  Directory = ::T.let(nil, ::T.untyped)
  Path = ::T.let(nil, ::T.untyped)
  PathArray = ::T.let(nil, ::T.untyped)
  SPECIAL = ::T.let(nil, ::T.untyped)
  Template = ::T.let(nil, ::T.untyped)
end

class RDoc::Options
end

class RDoc::Parser
  def file_name(); end

  def initialize(top_level, file_name, content, options, stats); end
end

class RDoc::Parser::C
  include ::RDoc::Text
  def classes(); end

  def content(); end

  def content=(content); end

  def deduplicate_call_seq(); end

  def deduplicate_method_name(class_obj, method_name); end

  def do_aliases(); end

  def do_attrs(); end

  def do_boot_defclass(); end

  def do_classes_and_modules(); end

  def do_constants(); end

  def do_includes(); end

  def do_methods(); end

  def do_missing(); end

  def enclosure_dependencies(); end

  def find_alias_comment(class_name, new_name, old_name); end

  def find_attr_comment(var_name, attr_name, read=T.unsafe(nil), write=T.unsafe(nil)); end

  def find_body(class_name, meth_name, meth_obj, file_content, quiet=T.unsafe(nil)); end

  def find_class(raw_name, name); end

  def find_class_comment(class_name, class_mod); end

  def find_const_comment(type, const_name, class_name=T.unsafe(nil)); end

  def find_modifiers(comment, meth_obj); end

  def find_override_comment(class_name, meth_obj); end

  def gen_body_table(file_content); end

  def gen_const_table(file_content); end

  def handle_attr(var_name, attr_name, read, write); end

  def handle_class_module(var_name, type, class_name, parent, in_module); end

  def handle_constants(type, var_name, const_name, definition); end

  def handle_ifdefs_in(body); end

  def handle_method(type, var_name, meth_name, function, param_count, source_file=T.unsafe(nil)); end

  def handle_singleton(sclass_var, class_var); end

  def handle_tab_width(body); end

  def known_classes(); end

  def load_variable_map(map_name); end

  def look_for_directives_in(context, comment); end

  def missing_dependencies(); end

  def rb_scan_args(method_body); end

  def remove_commented_out_lines(); end

  def scan(); end

  def singleton_classes(); end

  def top_level(); end
end

class RDoc::Parser::C
end

class RDoc::Parser::ChangeLog
  include ::RDoc::Parser::Text
  def continue_entry_body(entry_body, continuation); end

  def create_document(groups); end

  def create_entries(entries); end

  def create_items(items); end

  def group_entries(entries); end

  def parse_entries(); end

  def scan(); end
end

class RDoc::Parser::ChangeLog
end

class RDoc::Parser::Markdown
  include ::RDoc::Parser::Text
  def scan(); end
end

class RDoc::Parser::Markdown
end

class RDoc::Parser::RD
  include ::RDoc::Parser::Text
  def scan(); end
end

class RDoc::Parser::RD
end

class RDoc::Parser::RipperStateLex
  def get_squashed_tk(); end

  def initialize(code); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_ARG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_BEG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_CMDARG = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_ENDARG = ::T.let(nil, ::T.untyped)
  EXPR_ENDFN = ::T.let(nil, ::T.untyped)
  EXPR_END_ANY = ::T.let(nil, ::T.untyped)
  EXPR_FITEM = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_LABEL = ::T.let(nil, ::T.untyped)
  EXPR_LABELED = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  EXPR_NONE = ::T.let(nil, ::T.untyped)
  EXPR_VALUE = ::T.let(nil, ::T.untyped)
  RIPPER_HAS_LEX_STATE = ::T.let(nil, ::T.untyped)
end

class RDoc::Parser::RipperStateLex::InnerStateLex
  def initialize(code); end

  def on_default(event, tok, data); end
end

class RDoc::Parser::RipperStateLex::InnerStateLex
end

class RDoc::Parser::RipperStateLex::Token
  def char_no(); end

  def char_no=(_); end

  def kind(); end

  def kind=(_); end

  def line_no(); end

  def line_no=(_); end

  def state(); end

  def state=(_); end

  def text(); end

  def text=(_); end
end

class RDoc::Parser::RipperStateLex::Token
  def self.[](*_); end

  def self.members(); end
end

class RDoc::Parser::RipperStateLex
  def self.end?(token); end

  def self.parse(code); end
end

class RDoc::Parser::Ruby
  include ::RDoc::TokenStream
  include ::RDoc::Parser::RubyTools
  def collect_first_comment(); end

  def consume_trailing_spaces(); end

  def create_attr(container, single, name, rw, comment); end

  def create_module_alias(container, constant, rhs_name); end

  def error(msg); end

  def get_bool(); end

  def get_class_or_module(container, ignore_constants=T.unsafe(nil)); end

  def get_class_specification(); end

  def get_constant(); end

  def get_end_token(tk); end

  def get_included_module_with_optional_parens(); end

  def get_method_container(container, name_t); end

  def get_symbol_or_name(); end

  def get_tkread_clean(pattern, replacement); end

  def get_visibility_information(tk, single); end

  def look_for_directives_in(container, comment); end

  def make_message(message); end

  def new_comment(comment, line_no=T.unsafe(nil)); end

  def parse_alias(context, single, tk, comment); end

  def parse_attr(context, single, tk, comment); end

  def parse_attr_accessor(context, single, tk, comment); end

  def parse_call_parameters(tk); end

  def parse_class(container, single, tk, comment); end

  def parse_class_regular(container, declaration_context, single, name_t, given_name, comment); end

  def parse_class_singleton(container, name, comment); end

  def parse_comment(container, tk, comment); end

  def parse_comment_attr(container, type, name, comment); end

  def parse_comment_ghost(container, text, name, column, line_no, comment); end

  def parse_comment_tomdoc(container, tk, comment); end

  def parse_constant(container, tk, comment, ignore_constants=T.unsafe(nil)); end

  def parse_constant_body(container, constant, is_array_or_hash); end

  def parse_constant_visibility(container, single, tk); end

  def parse_extend_or_include(klass, container, comment); end

  def parse_identifier(container, single, tk, comment); end

  def parse_meta_attr(context, single, tk, comment); end

  def parse_meta_method(container, single, tk, comment); end

  def parse_meta_method_name(comment, tk); end

  def parse_meta_method_params(container, single, meth, tk, comment); end

  def parse_method(container, single, tk, comment); end

  def parse_method_dummy(container); end

  def parse_method_name(container); end

  def parse_method_name_regular(container, name_t); end

  def parse_method_name_singleton(container, name_t); end

  def parse_method_or_yield_parameters(method=T.unsafe(nil), modifiers=T.unsafe(nil)); end

  def parse_method_parameters(method); end

  def parse_method_params_and_body(container, single, meth, added_container); end

  def parse_module(container, single, tk, comment); end

  def parse_require(context, comment); end

  def parse_rescue(); end

  def parse_statements(container, single=T.unsafe(nil), current_method=T.unsafe(nil), comment=T.unsafe(nil)); end

  def parse_symbol_arg(no=T.unsafe(nil)); end

  def parse_symbol_arg_paren(no); end

  def parse_symbol_arg_space(no, tk); end

  def parse_symbol_in_arg(); end

  def parse_top_level_statements(container); end

  def parse_visibility(container, single, tk); end

  def parse_yield(context, single, tk, method); end

  def read_directive(allowed); end

  def read_documentation_modifiers(context, allowed); end

  def record_location(container); end

  def retrieve_comment_body(tk); end

  def scan(); end

  def skip_for_variable(); end

  def skip_method(container); end

  def skip_optional_do_after_expression(); end

  def skip_tkspace_comment(skip_nl=T.unsafe(nil)); end

  def suppress_parents(container, ancestor); end

  def tk_nl?(tk); end

  def update_visibility(container, vis_type, vis, singleton); end

  def warn(message); end
  NORMAL = ::T.let(nil, ::T.untyped)
  SINGLE = ::T.let(nil, ::T.untyped)
end

class RDoc::Parser::Ruby
end

module RDoc::Parser::RubyTools
  def add_token_listener(obj); end

  def get_tk(); end

  def get_tk_until(*tokens); end

  def get_tkread(); end

  def peek_read(); end

  def peek_tk(); end

  def remove_token_listener(obj); end

  def reset(); end

  def skip_tkspace(); end

  def skip_tkspace_without_nl(); end

  def token_listener(obj); end

  def unget_tk(tk); end
end

module RDoc::Parser::RubyTools
end

class RDoc::Parser::Simple
  include ::RDoc::Parser::Text
  def content(); end

  def remove_coding_comment(text); end

  def remove_private_comment(comment); end

  def scan(); end
end

class RDoc::Parser::Simple
end

module RDoc::Parser::Text
end

module RDoc::Parser::Text
end

class RDoc::Parser
  def self.alias_extension(old_ext, new_ext); end

  def self.binary?(file); end

  def self.can_parse(file_name); end

  def self.can_parse_by_name(file_name); end

  def self.check_modeline(file_name); end

  def self.for(top_level, file_name, content, options, stats); end

  def self.parse_files_matching(regexp); end

  def self.parsers(); end

  def self.remove_modeline(content); end

  def self.use_markup(content); end

  def self.zip?(file); end
end

class RDoc::RD
end

class RDoc::RD::BlockParser
  def _reduce_1(val, _values, result); end

  def _reduce_10(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_17(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_33(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_36(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_42(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_44(val, _values, result); end

  def _reduce_45(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_47(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_50(val, _values, result); end

  def _reduce_51(val, _values, result); end

  def _reduce_52(val, _values, result); end

  def _reduce_54(val, _values, result); end

  def _reduce_55(val, _values, result); end

  def _reduce_57(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_62(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def add_footnote(content); end

  def add_label(label); end

  def content(values); end

  def footnotes(); end

  def include_path(); end

  def include_path=(include_path); end

  def labels(); end

  def line_index(); end

  def on_error(et, ev, _values); end

  def paragraph(value); end

  def parse(src); end
  MARK_TO_LEVEL = ::T.let(nil, ::T.untyped)
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
  TMPFILE = ::T.let(nil, ::T.untyped)
end

class RDoc::RD::BlockParser
end

class RDoc::RD::Inline
  def ==(other); end

  def append(more); end

  def initialize(rdoc, reference); end

  def rdoc(); end

  def reference(); end
end

class RDoc::RD::Inline
  def self.new(rdoc, reference=T.unsafe(nil)); end
end

class RDoc::RD::InlineParser
  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_109(val, _values, result); end

  def _reduce_111(val, _values, result); end

  def _reduce_113(val, _values, result); end

  def _reduce_114(val, _values, result); end

  def _reduce_115(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_136(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_17(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_33(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_36(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_44(val, _values, result); end

  def _reduce_45(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_57(val, _values, result); end

  def _reduce_58(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_62(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_78(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def initialize(block_parser); end

  def inline(rdoc, reference=T.unsafe(nil)); end

  def next_words_on_error(); end

  def on_error(et, ev, values); end

  def parse(inline); end

  def prev_words_on_error(ev); end
  BACK_SLASH = ::T.let(nil, ::T.untyped)
  BACK_SLASH_RE = ::T.let(nil, ::T.untyped)
  BAR = ::T.let(nil, ::T.untyped)
  BAR_RE = ::T.let(nil, ::T.untyped)
  CODE_CLOSE = ::T.let(nil, ::T.untyped)
  CODE_CLOSE_RE = ::T.let(nil, ::T.untyped)
  CODE_OPEN = ::T.let(nil, ::T.untyped)
  CODE_OPEN_RE = ::T.let(nil, ::T.untyped)
  EM_CLOSE = ::T.let(nil, ::T.untyped)
  EM_CLOSE_RE = ::T.let(nil, ::T.untyped)
  EM_OPEN = ::T.let(nil, ::T.untyped)
  EM_OPEN_RE = ::T.let(nil, ::T.untyped)
  FOOTNOTE_CLOSE = ::T.let(nil, ::T.untyped)
  FOOTNOTE_CLOSE_RE = ::T.let(nil, ::T.untyped)
  FOOTNOTE_OPEN = ::T.let(nil, ::T.untyped)
  FOOTNOTE_OPEN_RE = ::T.let(nil, ::T.untyped)
  INDEX_CLOSE = ::T.let(nil, ::T.untyped)
  INDEX_CLOSE_RE = ::T.let(nil, ::T.untyped)
  INDEX_OPEN = ::T.let(nil, ::T.untyped)
  INDEX_OPEN_RE = ::T.let(nil, ::T.untyped)
  KBD_CLOSE = ::T.let(nil, ::T.untyped)
  KBD_CLOSE_RE = ::T.let(nil, ::T.untyped)
  KBD_OPEN = ::T.let(nil, ::T.untyped)
  KBD_OPEN_RE = ::T.let(nil, ::T.untyped)
  OTHER_RE = ::T.let(nil, ::T.untyped)
  QUOTE = ::T.let(nil, ::T.untyped)
  QUOTE_RE = ::T.let(nil, ::T.untyped)
  REF_CLOSE = ::T.let(nil, ::T.untyped)
  REF_CLOSE_RE = ::T.let(nil, ::T.untyped)
  REF_OPEN = ::T.let(nil, ::T.untyped)
  REF_OPEN_RE = ::T.let(nil, ::T.untyped)
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
  SLASH = ::T.let(nil, ::T.untyped)
  SLASH_RE = ::T.let(nil, ::T.untyped)
  URL = ::T.let(nil, ::T.untyped)
  URL_RE = ::T.let(nil, ::T.untyped)
  VAR_CLOSE = ::T.let(nil, ::T.untyped)
  VAR_CLOSE_RE = ::T.let(nil, ::T.untyped)
  VAR_OPEN = ::T.let(nil, ::T.untyped)
  VAR_OPEN_RE = ::T.let(nil, ::T.untyped)
  VERB_CLOSE = ::T.let(nil, ::T.untyped)
  VERB_CLOSE_RE = ::T.let(nil, ::T.untyped)
  VERB_OPEN = ::T.let(nil, ::T.untyped)
  VERB_OPEN_RE = ::T.let(nil, ::T.untyped)
end

class RDoc::RD::InlineParser
end

class RDoc::RD
  def self.parse(rd); end
end

class RDoc::RDoc
  def document(options); end

  def error(msg); end

  def gather_files(files); end

  def generate(); end

  def generator(); end

  def generator=(generator); end

  def handle_pipe(); end

  def install_siginfo_handler(); end

  def last_modified(); end

  def list_files_in_directory(dir); end

  def load_options(); end

  def normalized_file_list(relative_files, force_doc=T.unsafe(nil), exclude_pattern=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def output_flag_file(op_dir); end

  def parse_dot_doc_file(in_dir, filename); end

  def parse_file(filename); end

  def parse_files(files); end

  def remove_siginfo_handler(); end

  def remove_unparseable(files); end

  def setup_output_dir(dir, force); end

  def stats(); end

  def store(); end

  def store=(store); end

  def update_output_dir(op_dir, time, last=T.unsafe(nil)); end
  GENERATORS = ::T.let(nil, ::T.untyped)
end

class RDoc::RDoc
  def self.add_generator(klass); end

  def self.current(); end

  def self.current=(rdoc); end
end

module RDoc::RI
end

class RDoc::RI::Driver
  def add_also_in(out, also_in); end

  def add_class(out, name, classes); end

  def add_extends(out, extends); end

  def add_extension_modules(out, type, extensions); end

  def add_extension_modules_multiple(out, store, modules); end

  def add_extension_modules_single(out, store, include); end

  def add_from(out, store); end

  def add_includes(out, includes); end

  def add_method(out, name); end

  def add_method_documentation(out, klass); end

  def add_method_list(out, methods, name); end

  def ancestors_of(klass); end

  def check_did_you_mean(); end

  def class_cache(); end

  def class_document(name, found, klasses, includes, extends); end

  def class_document_comment(out, comment); end

  def class_document_constants(out, klass); end

  def classes(); end

  def classes_and_includes_and_extends_for(name); end

  def complete(name); end

  def complete_klass(name, klass, selector, method, completions); end

  def complete_method(name, klass, selector, completions); end

  def display(document); end

  def display_class(name); end

  def display_method(name); end

  def display_name(name); end

  def display_names(names); end

  def display_page(name); end

  def display_page_list(store, pages=T.unsafe(nil), search=T.unsafe(nil)); end

  def expand_class(klass); end

  def expand_name(name); end

  def filter_methods(found, name); end

  def find_methods(name); end

  def find_pager_jruby(pager); end

  def find_store(name); end

  def formatter(io); end

  def in_path?(file); end

  def initialize(initial_options=T.unsafe(nil)); end

  def interactive(); end

  def list_known_classes(names=T.unsafe(nil)); end

  def list_methods_matching(name); end

  def load_method(store, cache, klass, type, name); end

  def load_methods_matching(name); end

  def lookup_method(name); end

  def method_document(name, filtered); end

  def method_type(selector); end

  def name_regexp(name); end

  def page(); end

  def paging?(); end

  def parse_name(name); end

  def render_class(out, store, klass, also_in); end

  def render_method(out, store, method, name); end

  def render_method_arguments(out, arglists); end

  def render_method_comment(out, method, alias_for=T.unsafe(nil)); end

  def render_method_superclass(out, method); end

  def run(); end

  def setup_pager(); end

  def show_all(); end

  def show_all=(show_all); end

  def start_server(); end

  def stores(); end

  def stores=(stores); end

  def use_stdout(); end

  def use_stdout=(use_stdout); end
end

class RDoc::RI::Driver::Error
end

class RDoc::RI::Driver::Error
end

class RDoc::RI::Driver::NotFoundError
  def initialize(klass, suggestions=T.unsafe(nil)); end

  def name(); end
end

class RDoc::RI::Driver::NotFoundError
end

class RDoc::RI::Driver
  def self.default_options(); end

  def self.dump(data_path); end

  def self.process_args(argv); end

  def self.run(argv=T.unsafe(nil)); end
end

class RDoc::RI::Error
end

class RDoc::RI::Error
end

module RDoc::RI::Paths
  BASE = ::T.let(nil, ::T.untyped)
  HOMEDIR = ::T.let(nil, ::T.untyped)
end

module RDoc::RI::Paths
  def self.each(system=T.unsafe(nil), site=T.unsafe(nil), home=T.unsafe(nil), gems=T.unsafe(nil), *extra_dirs, &blk); end

  def self.gem_dir(name, version); end

  def self.gemdirs(filter=T.unsafe(nil)); end

  def self.home_dir(); end

  def self.path(system=T.unsafe(nil), site=T.unsafe(nil), home=T.unsafe(nil), gems=T.unsafe(nil), *extra_dirs); end

  def self.raw_path(system, site, home, gems, *extra_dirs); end

  def self.site_dir(); end

  def self.system_dir(); end
end

RDoc::RI::Store = RDoc::Store

module RDoc::RI
end

class RDoc::Require
  def initialize(name, comment); end

  def name(); end

  def name=(name); end

  def top_level(); end
end

class RDoc::Require
end

class RDoc::Servlet
  def asset(generator_name, req, res); end

  def asset_dirs(); end

  def documentation_page(store, generator, path, req, res); end

  def documentation_search(store, generator, req, res); end

  def documentation_source(path); end

  def error(exception, req, res); end

  def generator_for(store); end

  def if_modified_since(req, res, path=T.unsafe(nil)); end

  def initialize(server, stores, cache, mount_path=T.unsafe(nil), extra_doc_dirs=T.unsafe(nil)); end

  def installed_docs(); end

  def not_found(generator, req, res, message=T.unsafe(nil)); end

  def options(); end

  def ri_paths(&block); end

  def root(req, res); end

  def root_search(req, res); end

  def show_documentation(req, res); end

  def store_for(source_name); end
end

class RDoc::Servlet
end

class RDoc::SingleClass
  def definition(); end
end

class RDoc::SingleClass
end

class RDoc::Stats
  include ::RDoc::Text
  def add_alias(as); end

  def add_attribute(attribute); end

  def add_class(klass); end

  def add_constant(constant); end

  def add_file(file); end

  def add_method(method); end

  def add_module(mod); end

  def begin_adding(); end

  def calculate(); end

  def coverage_level(); end

  def coverage_level=(level); end

  def doc_stats(collection); end

  def done_adding(); end

  def files_so_far(); end

  def fully_documented?(); end

  def great_job(); end

  def initialize(store, num_files, verbosity=T.unsafe(nil)); end

  def num_files(); end

  def percent_doc(); end

  def report(); end

  def report_attributes(cm); end

  def report_class_module(cm); end

  def report_constants(cm); end

  def report_methods(cm); end

  def summary(); end

  def undoc_params(method); end
end

class RDoc::Stats::Normal
  def begin_adding(); end

  def done_adding(); end

  def print_file(files_so_far, filename); end
end

class RDoc::Stats::Normal
end

class RDoc::Stats::Quiet
  def begin_adding(*_); end

  def done_adding(*_); end

  def initialize(num_files); end

  def print_alias(*_); end

  def print_attribute(*_); end

  def print_class(*_); end

  def print_constant(*_); end

  def print_file(*_); end

  def print_method(*_); end

  def print_module(*_); end
end

class RDoc::Stats::Quiet
end

class RDoc::Stats::Verbose
  def nodoc(co); end

  def print_alias(as); end

  def print_attribute(attribute); end

  def print_class(klass); end

  def print_constant(constant); end

  def print_file(files_so_far, file); end

  def print_method(method); end

  def print_module(mod); end
end

class RDoc::Stats::Verbose
end

class RDoc::Stats
end

class RDoc::Store
  def add_c_enclosure(variable, namespace); end

  def add_c_variables(c_parser); end

  def add_file(absolute_name, relative_name: T.unsafe(nil), parser: T.unsafe(nil)); end

  def all_classes(); end

  def all_classes_and_modules(); end

  def all_files(); end

  def all_modules(); end

  def ancestors(); end

  def attributes(); end

  def c_class_variables(); end

  def c_enclosure_classes(); end

  def c_enclosure_names(); end

  def c_singleton_class_variables(); end

  def cache(); end

  def cache_path(); end

  def class_file(klass_name); end

  def class_methods(); end

  def class_path(klass_name); end

  def classes_hash(); end

  def clean_cache_collection(collection); end

  def complete(min_visibility); end

  def dry_run(); end

  def dry_run=(dry_run); end

  def encoding(); end

  def encoding=(encoding); end

  def files_hash(); end

  def find_c_enclosure(variable); end

  def find_class_named(name); end

  def find_class_named_from(name, from); end

  def find_class_or_module(name); end

  def find_file_named(name); end

  def find_module_named(name); end

  def find_text_page(file_name); end

  def find_unique(all_hash); end

  def fix_basic_object_inheritance(); end

  def friendly_path(); end

  def initialize(path=T.unsafe(nil), type=T.unsafe(nil)); end

  def instance_methods(); end

  def load_all(); end

  def load_cache(); end

  def load_class(klass_name); end

  def load_class_data(klass_name); end

  def load_method(klass_name, method_name); end

  def load_page(page_name); end

  def main(); end

  def main=(page); end

  def make_variable_map(variables); end

  def method_file(klass_name, method_name); end

  def module_names(); end

  def modules_hash(); end

  def page(name); end

  def page_file(page_name); end

  def path(); end

  def path=(path); end

  def rdoc(); end

  def rdoc=(rdoc); end

  def remove_nodoc(all_hash); end

  def save(); end

  def save_cache(); end

  def save_class(klass); end

  def save_method(klass, method); end

  def save_page(page); end

  def source(); end

  def title(); end

  def title=(title); end

  def type(); end

  def type=(type); end

  def unique_classes(); end

  def unique_classes_and_modules(); end

  def unique_modules(); end

  def unmatched_constant_alias(); end

  def update_parser_of_file(absolute_name, parser); end
end

class RDoc::Store::Error
end

class RDoc::Store::Error
end

class RDoc::Store::MissingFileError
  def file(); end

  def initialize(store, file, name); end

  def name(); end

  def store(); end
end

class RDoc::Store::MissingFileError
end

class RDoc::Store
end

class RDoc::Task
  def before_running_rdoc(&block); end

  def check_names(names); end

  def clobber_task_description(); end

  def defaults(); end

  def define(); end

  def external(); end

  def external=(external); end

  def generator(); end

  def generator=(generator); end

  def initialize(name=T.unsafe(nil)); end

  def inline_source(); end

  def inline_source=(value); end

  def main(); end

  def main=(main); end

  def markup(); end

  def markup=(markup); end

  def name(); end

  def name=(name); end

  def option_list(); end

  def options(); end

  def options=(options); end

  def rdoc_dir(); end

  def rdoc_dir=(rdoc_dir); end

  def rdoc_files(); end

  def rdoc_files=(rdoc_files); end

  def rdoc_task_description(); end

  def rerdoc_task_description(); end

  def template(); end

  def template=(template); end

  def title(); end

  def title=(title); end
end

class RDoc::Task
end

module RDoc::Text
  def expand_tabs(text); end

  def flush_left(text); end

  def language(); end

  def language=(language); end

  def markup(text); end

  def normalize_comment(text); end

  def parse(text, format=T.unsafe(nil)); end

  def snippet(text, limit=T.unsafe(nil)); end

  def strip_hashes(text); end

  def strip_newlines(text); end

  def strip_stars(text); end

  def to_html(text); end

  def wrap(txt, line_len=T.unsafe(nil)); end
  MARKUP_FORMAT = ::T.let(nil, ::T.untyped)
  TO_HTML_CHARACTERS = ::T.let(nil, ::T.untyped)
end

module RDoc::Text
  def self.encode_fallback(character, encoding, fallback); end
end

module RDoc::TokenStream
  def add_token(token); end

  def add_tokens(tokens); end

  def collect_tokens(); end

  def pop_token(); end

  def start_collecting_tokens(); end

  def token_stream(); end

  def tokens_to_s(); end
end

module RDoc::TokenStream
  def self.to_html(token_stream); end
end

class RDoc::TomDoc
  def tokenize(text); end
end

class RDoc::TomDoc
  def self.add_post_processor(); end

  def self.parse(text); end

  def self.signature(comment); end
end

class RDoc::TopLevel
  def ==(other); end

  def absolute_name(); end

  def absolute_name=(absolute_name); end

  def add_to_classes_or_modules(mod); end

  def base_name(); end

  def classes_or_modules(); end

  def cvs_url(); end

  def diagram(); end

  def diagram=(diagram); end

  def eql?(other); end

  def file_stat(); end

  def file_stat=(file_stat); end

  def find_class_or_module(name); end

  def initialize(absolute_name, relative_name=T.unsafe(nil)); end

  def last_modified(); end

  def marshal_dump(); end

  def marshal_load(array); end

  def object_class(); end

  def page_name(); end

  def parser(); end

  def parser=(val); end

  def path(); end

  def relative_name(); end

  def relative_name=(relative_name); end

  def search_record(); end

  def text?(); end
  MARSHAL_VERSION = ::T.let(nil, ::T.untyped)
end

class RDoc::TopLevel
end

module RDoc
  def self.load_yaml(); end
end

module REXML
  COPYRIGHT = ::T.let(nil, ::T.untyped)
  Copyright = ::T.let(nil, ::T.untyped)
  DATE = ::T.let(nil, ::T.untyped)
  REVISION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class REXML::AttlistDecl
  include ::Enumerable
  def [](key); end

  def each(&block); end

  def element_name(); end

  def include?(key); end

  def initialize(source); end

  def node_type(); end

  def write(out, indent=T.unsafe(nil)); end
end

class REXML::AttlistDecl
end

class REXML::Attribute
  include ::REXML::Node
  include ::REXML::Namespace
  include ::REXML::XMLTokens
  def ==(other); end

  def clone(); end

  def doctype(); end

  def element(); end

  def element=(element); end

  def initialize(first, second=T.unsafe(nil), parent=T.unsafe(nil)); end

  def namespace(arg=T.unsafe(nil)); end

  def node_type(); end

  def normalized=(normalized); end

  def remove(); end

  def to_s(); end

  def to_string(); end

  def value(); end

  def write(output, indent=T.unsafe(nil)); end

  def xpath(); end
  NEEDS_A_SECOND_CHECK = ::T.let(nil, ::T.untyped)
  PATTERN = ::T.let(nil, ::T.untyped)
end

class REXML::Attribute
end

class REXML::Attributes
  def <<(attribute); end

  def [](name); end

  def []=(name, value); end

  def add(attribute); end

  def delete(attribute); end

  def delete_all(name); end

  def each_attribute(); end

  def get_attribute(name); end

  def get_attribute_ns(namespace, name); end

  def initialize(element); end

  def namespaces(); end

  def prefixes(); end
end

class REXML::Attributes
end

class REXML::CData
  def initialize(first, whitespace=T.unsafe(nil), parent=T.unsafe(nil)); end

  def write(output=T.unsafe(nil), indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  ILLEGAL = ::T.let(nil, ::T.untyped)
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::CData
end

class REXML::Child
  include ::REXML::Node
  def bytes(); end

  def document(); end

  def initialize(parent=T.unsafe(nil)); end

  def next_sibling(); end

  def next_sibling=(other); end

  def parent(); end

  def parent=(other); end

  def previous_sibling(); end

  def previous_sibling=(other); end

  def remove(); end

  def replace_with(child); end
end

class REXML::Child
end

class REXML::Comment
  include ::Comparable
  def ==(other); end

  def clone(); end

  def initialize(first, second=T.unsafe(nil)); end

  def node_type(); end

  def string(); end

  def string=(string); end

  def to_s(); end

  def write(output, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::Comment
end

class REXML::Declaration
  def initialize(src); end

  def to_s(); end

  def write(output, indent); end
end

class REXML::Declaration
end

class REXML::DocType
  include ::REXML::XMLTokens
  def add(child); end

  def attribute_of(element, attribute); end

  def attributes_of(element); end

  def clone(); end

  def context(); end

  def entities(); end

  def entity(name); end

  def external_id(); end

  def initialize(first, parent=T.unsafe(nil)); end

  def name(); end

  def namespaces(); end

  def node_type(); end

  def notation(name); end

  def notations(); end

  def public(); end

  def system(); end

  def write(output, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  DEFAULT_ENTITIES = ::T.let(nil, ::T.untyped)
  PUBLIC = ::T.let(nil, ::T.untyped)
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
  SYSTEM = ::T.let(nil, ::T.untyped)
end

class REXML::DocType
end

class REXML::Document
  def <<(child); end

  def add(child); end

  def add_element(arg=T.unsafe(nil), arg2=T.unsafe(nil)); end

  def doctype(); end

  def encoding(); end

  def entity_expansion_count(); end

  def initialize(source=T.unsafe(nil), context=T.unsafe(nil)); end

  def record_entity_expansion(); end

  def stand_alone?(); end

  def version(); end

  def write(*arguments); end

  def xml_decl(); end
  DECLARATION = ::T.let(nil, ::T.untyped)
end

class REXML::Document
  def self.entity_expansion_limit(); end

  def self.entity_expansion_limit=(val); end

  def self.entity_expansion_text_limit(); end

  def self.entity_expansion_text_limit=(val); end

  def self.parse_stream(source, listener); end
end

class REXML::Element
  include ::REXML::Namespace
  include ::REXML::XMLTokens
  def [](name_or_index); end

  def add_attribute(key, value=T.unsafe(nil)); end

  def add_attributes(hash); end

  def add_element(element, attrs=T.unsafe(nil)); end

  def add_namespace(prefix, uri=T.unsafe(nil)); end

  def add_text(text); end

  def attribute(name, namespace=T.unsafe(nil)); end

  def attributes(); end

  def cdatas(); end

  def clone(); end

  def comments(); end

  def context(); end

  def context=(context); end

  def delete_attribute(key); end

  def delete_element(element); end

  def delete_namespace(namespace=T.unsafe(nil)); end

  def each_element(xpath=T.unsafe(nil), &block); end

  def each_element_with_attribute(key, value=T.unsafe(nil), max=T.unsafe(nil), name=T.unsafe(nil), &block); end

  def each_element_with_text(text=T.unsafe(nil), max=T.unsafe(nil), name=T.unsafe(nil), &block); end

  def elements(); end

  def get_elements(xpath); end

  def get_text(path=T.unsafe(nil)); end

  def has_attributes?(); end

  def has_elements?(); end

  def has_text?(); end

  def ignore_whitespace_nodes(); end

  def initialize(arg=T.unsafe(nil), parent=T.unsafe(nil), context=T.unsafe(nil)); end

  def instructions(); end

  def namespace(prefix=T.unsafe(nil)); end

  def namespaces(); end

  def next_element(); end

  def node_type(); end

  def prefixes(); end

  def previous_element(); end

  def raw(); end

  def root(); end

  def root_node(); end

  def text(path=T.unsafe(nil)); end

  def text=(text); end

  def texts(); end

  def whitespace(); end

  def write(output=T.unsafe(nil), indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def xpath(); end
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

class REXML::Element
end

class REXML::ElementDecl
end

class REXML::ElementDecl
end

class REXML::Elements
  include ::Enumerable
  def <<(element=T.unsafe(nil)); end

  def [](index, name=T.unsafe(nil)); end

  def []=(index, element); end

  def add(element=T.unsafe(nil)); end

  def collect(xpath=T.unsafe(nil)); end

  def delete(element); end

  def delete_all(xpath); end

  def each(xpath=T.unsafe(nil), &blk); end

  def empty?(); end

  def index(element); end

  def initialize(parent); end

  def inject(xpath=T.unsafe(nil), initial=T.unsafe(nil)); end

  def size(); end

  def to_a(xpath=T.unsafe(nil)); end
end

class REXML::Elements
end

module REXML::Encoding
  def decode(string); end

  def encode(string); end

  def encoding(); end

  def encoding=(encoding); end
end

module REXML::Encoding
end

class REXML::Entity
  include ::REXML::XMLTokens
  def external(); end

  def initialize(stream, value=T.unsafe(nil), parent=T.unsafe(nil), reference=T.unsafe(nil)); end

  def name(); end

  def ndata(); end

  def normalized(); end

  def pubid(); end

  def ref(); end

  def to_s(); end

  def unnormalized(); end

  def value(); end

  def write(out, indent=T.unsafe(nil)); end
  ENTITYDECL = ::T.let(nil, ::T.untyped)
  ENTITYDEF = ::T.let(nil, ::T.untyped)
  ENTITYVALUE = ::T.let(nil, ::T.untyped)
  EXTERNALID = ::T.let(nil, ::T.untyped)
  GEDECL = ::T.let(nil, ::T.untyped)
  NDATADECL = ::T.let(nil, ::T.untyped)
  PEDECL = ::T.let(nil, ::T.untyped)
  PEDEF = ::T.let(nil, ::T.untyped)
  PEREFERENCE = ::T.let(nil, ::T.untyped)
  PEREFERENCE_RE = ::T.let(nil, ::T.untyped)
  PUBIDCHAR = ::T.let(nil, ::T.untyped)
  PUBIDLITERAL = ::T.let(nil, ::T.untyped)
  SYSTEMLITERAL = ::T.let(nil, ::T.untyped)
end

class REXML::Entity
  def self.matches?(string); end
end

module REXML::EntityConst
  AMP = ::T.let(nil, ::T.untyped)
  APOS = ::T.let(nil, ::T.untyped)
  GT = ::T.let(nil, ::T.untyped)
  LT = ::T.let(nil, ::T.untyped)
  QUOT = ::T.let(nil, ::T.untyped)
end

module REXML::EntityConst
end

class REXML::ExternalEntity
  def initialize(src); end

  def to_s(); end

  def write(output, indent); end
end

class REXML::ExternalEntity
end

module REXML::Formatters
end

class REXML::Formatters::Default
  def initialize(ie_hack=T.unsafe(nil)); end

  def write(node, output); end

  def write_cdata(node, output); end

  def write_comment(node, output); end

  def write_document(node, output); end

  def write_element(node, output); end

  def write_instruction(node, output); end

  def write_text(node, output); end
end

class REXML::Formatters::Default
end

class REXML::Formatters::Pretty
  def compact(); end

  def compact=(compact); end

  def initialize(indentation=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def width(); end

  def width=(width); end
end

class REXML::Formatters::Pretty
end

module REXML::Formatters
end

module REXML::Functions
  INTERNAL_METHODS = ::T.let(nil, ::T.untyped)
end

module REXML::Functions
  def self.boolean(object=T.unsafe(nil)); end

  def self.ceiling(number); end

  def self.compare_language(lang1, lang2); end

  def self.concat(*objects); end

  def self.contains(string, test); end

  def self.context=(value); end

  def self.count(node_set); end

  def self.false(); end

  def self.floor(number); end

  def self.get_namespace(node_set=T.unsafe(nil)); end

  def self.id(object); end

  def self.lang(language); end

  def self.last(); end

  def self.local_name(node_set=T.unsafe(nil)); end

  def self.name(node_set=T.unsafe(nil)); end

  def self.namespace_context(); end

  def self.namespace_context=(x); end

  def self.namespace_uri(node_set=T.unsafe(nil)); end

  def self.normalize_space(string=T.unsafe(nil)); end

  def self.not(object); end

  def self.number(object=T.unsafe(nil)); end

  def self.position(); end

  def self.processing_instruction(node); end

  def self.round(number); end

  def self.send(name, *args); end

  def self.singleton_method_added(name); end

  def self.starts_with(string, test); end

  def self.string(object=T.unsafe(nil)); end

  def self.string_length(string); end

  def self.string_value(o); end

  def self.substring(string, start, length=T.unsafe(nil)); end

  def self.substring_after(string, test); end

  def self.substring_before(string, test); end

  def self.sum(nodes); end

  def self.text(); end

  def self.translate(string, tr1, tr2); end

  def self.true(); end

  def self.variables(); end

  def self.variables=(x); end
end

class REXML::IOSource
  def initialize(arg, block_size=T.unsafe(nil), encoding=T.unsafe(nil)); end
end

class REXML::IOSource
end

class REXML::Instruction
  def ==(other); end

  def clone(); end

  def content(); end

  def content=(content); end

  def initialize(target, content=T.unsafe(nil)); end

  def node_type(); end

  def target(); end

  def target=(target); end

  def write(writer, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::Instruction
end

module REXML::Namespace
  include ::REXML::XMLTokens
  def expanded_name(); end

  def fully_expanded_name(); end

  def has_name?(other, ns=T.unsafe(nil)); end

  def local_name(); end

  def name(); end

  def name=(name); end

  def prefix(); end

  def prefix=(prefix); end
  NAMESPLIT = ::T.let(nil, ::T.untyped)
end

module REXML::Namespace
end

module REXML::Node
  def each_recursive(&block); end

  def find_first_recursive(&block); end

  def indent(to, ind); end

  def index_in_parent(); end

  def next_sibling_node(); end

  def parent?(); end

  def previous_sibling_node(); end

  def to_s(indent=T.unsafe(nil)); end
end

module REXML::Node
end

class REXML::NotationDecl
  def initialize(name, middle, pub, sys); end

  def name(); end

  def public(); end

  def public=(public); end

  def system(); end

  def system=(system); end

  def to_s(); end

  def write(output, indent=T.unsafe(nil)); end
end

class REXML::NotationDecl
end

class REXML::Output
  include ::REXML::Encoding
  def <<(content); end

  def initialize(real_IO, encd=T.unsafe(nil)); end
end

class REXML::Output
end

class REXML::Parent
  include ::Enumerable
  def <<(object); end

  def [](index); end

  def []=(*args); end

  def add(object); end

  def children(); end

  def deep_clone(); end

  def delete(object); end

  def delete_at(index); end

  def delete_if(&block); end

  def each(&block); end

  def each_child(&block); end

  def each_index(&block); end

  def index(child); end

  def insert_after(child1, child2); end

  def insert_before(child1, child2); end

  def length(); end

  def push(object); end

  def replace_child(to_replace, replacement); end

  def size(); end

  def to_a(); end

  def unshift(object); end
end

class REXML::Parent
end

class REXML::ParseException
  def context(); end

  def continued_exception(); end

  def continued_exception=(continued_exception); end

  def initialize(message, source=T.unsafe(nil), parser=T.unsafe(nil), exception=T.unsafe(nil)); end

  def line(); end

  def parser(); end

  def parser=(parser); end

  def position(); end

  def source(); end

  def source=(source); end
end

class REXML::ParseException
end

module REXML::Parsers
end

class REXML::Parsers::BaseParser
  def add_listener(listener); end

  def empty?(); end

  def entity(reference, entities); end

  def has_next?(); end

  def initialize(source); end

  def normalize(input, entities=T.unsafe(nil), entity_filter=T.unsafe(nil)); end

  def peek(depth=T.unsafe(nil)); end

  def position(); end

  def pull(); end

  def source(); end

  def stream=(source); end

  def unnormalize(string, entities=T.unsafe(nil), filter=T.unsafe(nil)); end

  def unshift(token); end
  ATTDEF = ::T.let(nil, ::T.untyped)
  ATTDEF_RE = ::T.let(nil, ::T.untyped)
  ATTLISTDECL_PATTERN = ::T.let(nil, ::T.untyped)
  ATTLISTDECL_START = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_PATTERN = ::T.let(nil, ::T.untyped)
  ATTTYPE = ::T.let(nil, ::T.untyped)
  ATTVALUE = ::T.let(nil, ::T.untyped)
  CDATA_END = ::T.let(nil, ::T.untyped)
  CDATA_PATTERN = ::T.let(nil, ::T.untyped)
  CDATA_START = ::T.let(nil, ::T.untyped)
  CLOSE_MATCH = ::T.let(nil, ::T.untyped)
  COMBININGCHAR = ::T.let(nil, ::T.untyped)
  COMMENT_PATTERN = ::T.let(nil, ::T.untyped)
  COMMENT_START = ::T.let(nil, ::T.untyped)
  DEFAULTDECL = ::T.let(nil, ::T.untyped)
  DEFAULT_ENTITIES = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  DOCTYPE_END = ::T.let(nil, ::T.untyped)
  DOCTYPE_PATTERN = ::T.let(nil, ::T.untyped)
  DOCTYPE_START = ::T.let(nil, ::T.untyped)
  ELEMENTDECL_PATTERN = ::T.let(nil, ::T.untyped)
  ELEMENTDECL_START = ::T.let(nil, ::T.untyped)
  ENCODING = ::T.let(nil, ::T.untyped)
  ENTITYDECL = ::T.let(nil, ::T.untyped)
  ENTITYDEF = ::T.let(nil, ::T.untyped)
  ENTITYVALUE = ::T.let(nil, ::T.untyped)
  ENTITY_START = ::T.let(nil, ::T.untyped)
  ENUMERATEDTYPE = ::T.let(nil, ::T.untyped)
  ENUMERATION = ::T.let(nil, ::T.untyped)
  EREFERENCE = ::T.let(nil, ::T.untyped)
  EXTENDER = ::T.let(nil, ::T.untyped)
  EXTERNALID = ::T.let(nil, ::T.untyped)
  GEDECL = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  INSTRUCTION_PATTERN = ::T.let(nil, ::T.untyped)
  INSTRUCTION_START = ::T.let(nil, ::T.untyped)
  LETTER = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  NAMECHAR = ::T.let(nil, ::T.untyped)
  NCNAME_STR = ::T.let(nil, ::T.untyped)
  NDATADECL = ::T.let(nil, ::T.untyped)
  NMTOKEN = ::T.let(nil, ::T.untyped)
  NMTOKENS = ::T.let(nil, ::T.untyped)
  NOTATIONDECL_START = ::T.let(nil, ::T.untyped)
  NOTATIONTYPE = ::T.let(nil, ::T.untyped)
  PEDECL = ::T.let(nil, ::T.untyped)
  PEDEF = ::T.let(nil, ::T.untyped)
  PEREFERENCE = ::T.let(nil, ::T.untyped)
  PUBIDCHAR = ::T.let(nil, ::T.untyped)
  PUBIDLITERAL = ::T.let(nil, ::T.untyped)
  PUBLIC = ::T.let(nil, ::T.untyped)
  QNAME = ::T.let(nil, ::T.untyped)
  QNAME_STR = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
  REFERENCE_RE = ::T.let(nil, ::T.untyped)
  STANDALONE = ::T.let(nil, ::T.untyped)
  SYSTEM = ::T.let(nil, ::T.untyped)
  SYSTEMENTITY = ::T.let(nil, ::T.untyped)
  SYSTEMLITERAL = ::T.let(nil, ::T.untyped)
  TAG_MATCH = ::T.let(nil, ::T.untyped)
  TEXT_PATTERN = ::T.let(nil, ::T.untyped)
  UNAME_STR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  XMLDECL_PATTERN = ::T.let(nil, ::T.untyped)
  XMLDECL_START = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::BaseParser
end

class REXML::Parsers::StreamParser
  def add_listener(listener); end

  def initialize(source, listener); end

  def parse(); end
end

class REXML::Parsers::StreamParser
end

class REXML::Parsers::TreeParser
  def add_listener(listener); end

  def initialize(source, build_context=T.unsafe(nil)); end

  def parse(); end
end

class REXML::Parsers::TreeParser
end

class REXML::Parsers::XPathParser
  include ::REXML::XMLTokens
  def abbreviate(path); end

  def expand(path); end

  def namespaces=(namespaces); end

  def parse(path); end

  def predicate(path); end

  def predicate_to_string(path, &block); end
  AXIS = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
  LOCAL_NAME_WILDCARD = ::T.let(nil, ::T.untyped)
  NODE_TYPE = ::T.let(nil, ::T.untyped)
  NT = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  PI = ::T.let(nil, ::T.untyped)
  PREFIX_WILDCARD = ::T.let(nil, ::T.untyped)
  QNAME = ::T.let(nil, ::T.untyped)
  VARIABLE_REFERENCE = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::XPathParser
end

module REXML::Parsers
end

module REXML::Security
end

module REXML::Security
  def self.entity_expansion_limit(); end

  def self.entity_expansion_limit=(val); end

  def self.entity_expansion_text_limit(); end

  def self.entity_expansion_text_limit=(val); end
end

class REXML::Source
  include ::REXML::Encoding
  def buffer(); end

  def consume(pattern); end

  def current_line(); end

  def empty?(); end

  def encoding=(enc); end

  def initialize(arg, encoding=T.unsafe(nil)); end

  def line(); end

  def match(pattern, cons=T.unsafe(nil)); end

  def match_to(char, pattern); end

  def match_to_consume(char, pattern); end

  def position(); end

  def read(); end

  def scan(pattern, cons=T.unsafe(nil)); end
end

class REXML::Source
end

class REXML::SourceFactory
end

class REXML::SourceFactory
  def self.create_from(arg); end
end

class REXML::Text
  include ::Comparable
  def <<(to_append); end

  def clone(); end

  def doctype(); end

  def empty?(); end

  def indent_text(string, level=T.unsafe(nil), style=T.unsafe(nil), indentfirstline=T.unsafe(nil)); end

  def initialize(arg, respect_whitespace=T.unsafe(nil), parent=T.unsafe(nil), raw=T.unsafe(nil), entity_filter=T.unsafe(nil), illegal=T.unsafe(nil)); end

  def node_type(); end

  def parent=(parent); end

  def raw(); end

  def raw=(raw); end

  def to_s(); end

  def value(); end

  def value=(val); end

  def wrap(string, width, addnewline=T.unsafe(nil)); end

  def write(writer, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def write_with_substitution(out, input); end

  def xpath(); end
  EREFERENCE = ::T.let(nil, ::T.untyped)
  NEEDS_A_SECOND_CHECK = ::T.let(nil, ::T.untyped)
  NUMERICENTITY = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
  SETUTITSBUS = ::T.let(nil, ::T.untyped)
  SLAICEPS = ::T.let(nil, ::T.untyped)
  SPECIALS = ::T.let(nil, ::T.untyped)
  SUBSTITUTES = ::T.let(nil, ::T.untyped)
  VALID_CHAR = ::T.let(nil, ::T.untyped)
  VALID_XML_CHARS = ::T.let(nil, ::T.untyped)
end

class REXML::Text
  def self.check(string, pattern, doctype); end

  def self.expand(ref, doctype, filter); end

  def self.normalize(input, doctype=T.unsafe(nil), entity_filter=T.unsafe(nil)); end

  def self.read_with_substitution(input, illegal=T.unsafe(nil)); end

  def self.unnormalize(string, doctype=T.unsafe(nil), filter=T.unsafe(nil), illegal=T.unsafe(nil)); end
end

class REXML::UndefinedNamespaceException
  def initialize(prefix, source, parser); end
end

class REXML::UndefinedNamespaceException
end

module REXML::Validation
end

class REXML::Validation::ValidationException
  def initialize(msg); end
end

class REXML::Validation::ValidationException
end

module REXML::Validation
end

class REXML::XMLDecl
  include ::REXML::Encoding
  def ==(other); end

  def clone(); end

  def dowrite(); end

  def encoding=(enc); end

  def initialize(version=T.unsafe(nil), encoding=T.unsafe(nil), standalone=T.unsafe(nil)); end

  def node_type(); end

  def nowrite(); end

  def old_enc=(encoding); end

  def stand_alone?(); end

  def standalone(); end

  def standalone=(standalone); end

  def version(); end

  def version=(version); end

  def write(writer, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def writeencoding(); end

  def writethis(); end

  def xmldecl(version, encoding, standalone); end
  DEFAULT_ENCODING = ::T.let(nil, ::T.untyped)
  DEFAULT_STANDALONE = ::T.let(nil, ::T.untyped)
  DEFAULT_VERSION = ::T.let(nil, ::T.untyped)
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::XMLDecl
  def self.default(); end
end

module REXML::XMLTokens
  NAME = ::T.let(nil, ::T.untyped)
  NAMECHAR = ::T.let(nil, ::T.untyped)
  NAME_CHAR = ::T.let(nil, ::T.untyped)
  NAME_START_CHAR = ::T.let(nil, ::T.untyped)
  NAME_STR = ::T.let(nil, ::T.untyped)
  NCNAME_STR = ::T.let(nil, ::T.untyped)
  NMTOKEN = ::T.let(nil, ::T.untyped)
  NMTOKENS = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
end

module REXML::XMLTokens
end

class REXML::XPath
  include ::REXML::Functions
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
end

class REXML::XPath
  def self.each(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.first(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.match(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil), options=T.unsafe(nil)); end
end

class REXML::XPathNode
  def context(); end

  def initialize(node, context=T.unsafe(nil)); end

  def position(); end

  def raw_node(); end
end

class REXML::XPathNode
end

class REXML::XPathParser
  include ::REXML::XMLTokens
  def []=(variable_name, value); end

  def first(path_stack, node); end

  def get_first(path, nodeset); end

  def initialize(strict: T.unsafe(nil)); end

  def match(path_stack, nodeset); end

  def namespaces=(namespaces=T.unsafe(nil)); end

  def parse(path, nodeset); end

  def predicate(path, nodeset); end

  def variables=(vars=T.unsafe(nil)); end
  DEBUG = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
end

class REXML::XPathParser
end

module REXML
end

module Racc
  Copyright = ::T.let(nil, ::T.untyped)
  Racc_No_Extentions = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

module Rack
  CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
  ETAG = ::T.let(nil, ::T.untyped)
  GET = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  HTTPS = ::T.let(nil, ::T.untyped)
  HTTP_COOKIE = ::T.let(nil, ::T.untyped)
  HTTP_HOST = ::T.let(nil, ::T.untyped)
  HTTP_VERSION = ::T.let(nil, ::T.untyped)
  LINK = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  POST = ::T.let(nil, ::T.untyped)
  PUT = ::T.let(nil, ::T.untyped)
  QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_ERRORS = ::T.let(nil, ::T.untyped)
  RACK_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_HIJACK_IO = ::T.let(nil, ::T.untyped)
  RACK_INPUT = ::T.let(nil, ::T.untyped)
  RACK_IS_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_LOGGER = ::T.let(nil, ::T.untyped)
  RACK_METHODOVERRIDE_ORIGINAL_METHOD = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  RACK_MULTIPROCESS = ::T.let(nil, ::T.untyped)
  RACK_MULTITHREAD = ::T.let(nil, ::T.untyped)
  RACK_RECURSIVE_INCLUDE = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_STRING = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_INPUT = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_VARS = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_RUNONCE = ::T.let(nil, ::T.untyped)
  RACK_SESSION = ::T.let(nil, ::T.untyped)
  RACK_SESSION_OPTIONS = ::T.let(nil, ::T.untyped)
  RACK_SESSION_UNPACKED_COOKIE_DATA = ::T.let(nil, ::T.untyped)
  RACK_SHOWSTATUS_DETAIL = ::T.let(nil, ::T.untyped)
  RACK_TEMPFILES = ::T.let(nil, ::T.untyped)
  RACK_URL_SCHEME = ::T.let(nil, ::T.untyped)
  RACK_VERSION = ::T.let(nil, ::T.untyped)
  RELEASE = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_PATH = ::T.let(nil, ::T.untyped)
  SCRIPT_NAME = ::T.let(nil, ::T.untyped)
  SERVER_ADDR = ::T.let(nil, ::T.untyped)
  SERVER_NAME = ::T.let(nil, ::T.untyped)
  SERVER_PORT = ::T.let(nil, ::T.untyped)
  SERVER_PROTOCOL = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
  TRACE = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  UNLINK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::AbstractHandler
  def initialize(app, realm=T.unsafe(nil), &authenticator); end

  def realm(); end

  def realm=(realm); end
end

class Rack::Auth::AbstractHandler
end

class Rack::Auth::AbstractRequest
  def initialize(env); end

  def params(); end

  def parts(); end

  def provided?(); end

  def request(); end

  def scheme(); end

  def valid?(); end
  AUTHORIZATION_KEYS = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::AbstractRequest
end

class Rack::Auth::Basic
  def call(env); end
end

class Rack::Auth::Basic::Request
  def basic?(); end

  def credentials(); end

  def username(); end
end

class Rack::Auth::Basic::Request
end

class Rack::Auth::Basic
end

class Rack::Auth::Digest::MD5
  def call(env); end

  def initialize(app, realm=T.unsafe(nil), opaque=T.unsafe(nil), &authenticator); end

  def opaque(); end

  def opaque=(opaque); end

  def passwords_hashed=(passwords_hashed); end

  def passwords_hashed?(); end
  QOP = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::MD5
end

class Rack::Auth::Digest::Nonce
  def digest(); end

  def fresh?(); end

  def initialize(timestamp=T.unsafe(nil), given_digest=T.unsafe(nil)); end

  def stale?(); end

  def valid?(); end
end

class Rack::Auth::Digest::Nonce
  def self.parse(string); end

  def self.private_key(); end

  def self.private_key=(private_key); end

  def self.time_limit(); end

  def self.time_limit=(time_limit); end
end

class Rack::Auth::Digest::Params
  def [](k); end

  def []=(k, v); end

  def initialize(); end

  def quote(str); end
  UNQUOTED = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::Params
  def self.dequote(str); end

  def self.parse(str); end

  def self.split_header_value(str); end
end

class Rack::Auth::Digest::Request
  def correct_uri?(); end

  def digest?(); end

  def method(); end

  def method_missing(sym, *args); end

  def nonce(); end

  def respond_to?(sym, *_); end
end

class Rack::Auth::Digest::Request
end

class Rack::Builder
  def call(env); end

  def freeze_app(); end

  def initialize(default_app=T.unsafe(nil), &block); end

  def map(path, &block); end

  def run(app); end

  def to_app(); end

  def use(middleware, *args, &block); end

  def warmup(prc=T.unsafe(nil), &block); end
  UTF_8_BOM = ::T.let(nil, ::T.untyped)
end

class Rack::Builder
  def self.app(default_app=T.unsafe(nil), &block); end

  def self.load_file(path, opts=T.unsafe(nil)); end

  def self.new_from_string(builder_script, file=T.unsafe(nil)); end

  def self.parse_file(config, opts=T.unsafe(nil)); end
end

class Rack::Cascade
  def <<(app); end

  def add(app); end

  def apps(); end

  def call(env); end

  def include?(app); end

  def initialize(apps, catch=T.unsafe(nil)); end
  NotFound = ::T.let(nil, ::T.untyped)
end

class Rack::Cascade
end

class Rack::Chunked::Body
  TAIL = ::T.let(nil, ::T.untyped)
  TERM = ::T.let(nil, ::T.untyped)
end

class Rack::CommonLogger
  def call(env); end

  def initialize(app, logger=T.unsafe(nil)); end
  FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::CommonLogger
end

class Rack::Config
  def call(env); end

  def initialize(app, &block); end
end

class Rack::Config
end

class Rack::ContentLength
  include ::Rack::Utils
  def call(env); end

  def initialize(app); end
end

class Rack::ContentLength
end

class Rack::ContentType
  include ::Rack::Utils
  def call(env); end

  def initialize(app, content_type=T.unsafe(nil)); end
end

class Rack::ContentType
end

class Rack::Deflater
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
end

class Rack::Deflater::GzipStream
  def close(); end

  def each(&block); end

  def initialize(body, mtime, sync); end

  def write(data); end
end

class Rack::Deflater::GzipStream
end

class Rack::Deflater
end

class Rack::Directory
  def call(env); end

  def check_bad_request(path_info); end

  def check_forbidden(path_info); end

  def entity_not_found(path_info); end

  def filesize_format(int); end

  def get(env); end

  def initialize(root, app=T.unsafe(nil)); end

  def list_directory(path_info, path, script_name); end

  def list_path(env, path, path_info, script_name); end

  def path(); end

  def root(); end

  def stat(node); end
  DIR_FILE = ::T.let(nil, ::T.untyped)
  DIR_PAGE = ::T.let(nil, ::T.untyped)
  FILESIZE_FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::Directory::DirectoryBody
end

class Rack::Directory::DirectoryBody
end

class Rack::Directory
end

class Rack::ETag
  DEFAULT_CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  ETAG_STRING = ::T.let(nil, ::T.untyped)
end

Rack::File = Rack::Files

class Rack::Files
  ALLOWED_VERBS = ::T.let(nil, ::T.untyped)
  ALLOW_HEADER = ::T.let(nil, ::T.untyped)
end

class Rack::ForwardRequest
  def env(); end

  def initialize(url, env=T.unsafe(nil)); end

  def url(); end
end

class Rack::ForwardRequest
end

module Rack::Handler
end

class Rack::Handler::CGI
end

class Rack::Handler::CGI
  def self.run(app, options=T.unsafe(nil)); end

  def self.send_body(body); end

  def self.send_headers(status, headers); end

  def self.serve(app); end
end

class Rack::Handler::WEBrick
  def initialize(server, app); end
end

class Rack::Handler::WEBrick
  def self.run(app, options=T.unsafe(nil)); end

  def self.shutdown(); end

  def self.valid_options(); end
end

module Rack::Handler
  def self.default(); end

  def self.get(server); end

  def self.pick(server_names); end

  def self.register(server, klass); end

  def self.try_require(prefix, const_name); end
end

class Rack::Lint::HijackWrapper
  REQUIRED_METHODS = ::T.let(nil, ::T.untyped)
end

class Rack::Lock
  def call(env); end

  def initialize(app, mutex=T.unsafe(nil)); end
end

class Rack::Lock
end

class Rack::Logger
  def call(env); end

  def initialize(app, level=T.unsafe(nil)); end
end

class Rack::Logger
end

class Rack::MediaType
  SPLIT_PATTERN = ::T.let(nil, ::T.untyped)
end

class Rack::MethodOverride
  ALLOWED_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_OVERRIDE_HEADER = ::T.let(nil, ::T.untyped)
  METHOD_OVERRIDE_PARAM_KEY = ::T.let(nil, ::T.untyped)
end

module Rack::Mime
  MIME_TYPES = ::T.let(nil, ::T.untyped)
end

class Rack::MockRequest
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

module Rack::Multipart
  ATTRIBUTE = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_CHAR = ::T.let(nil, ::T.untyped)
  BROKEN_QUOTED = ::T.let(nil, ::T.untyped)
  BROKEN_UNQUOTED = ::T.let(nil, ::T.untyped)
  CONDISP = ::T.let(nil, ::T.untyped)
  DISPPARM = ::T.let(nil, ::T.untyped)
  EOL = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_PARAMETER = ::T.let(nil, ::T.untyped)
  MULTIPART = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_DISPOSITION = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_ID = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER_NAME = ::T.let(nil, ::T.untyped)
  RFC2183 = ::T.let(nil, ::T.untyped)
  SECTION = ::T.let(nil, ::T.untyped)
  TOKEN = ::T.let(nil, ::T.untyped)
  VALUE = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Generator
  def dump(); end

  def initialize(params, first=T.unsafe(nil)); end
end

class Rack::Multipart::Generator
end

class Rack::Multipart::MultipartPartLimitError
end

class Rack::Multipart::MultipartPartLimitError
end

class Rack::Multipart::Parser
  def initialize(boundary, tempfile, bufsize, query_parser); end

  def on_read(content); end

  def result(); end

  def state(); end
  BOUNDARY_REGEX = ::T.let(nil, ::T.untyped)
  BUFSIZE = ::T.let(nil, ::T.untyped)
  CHARSET = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  TEXT_PLAIN = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Parser::BoundedIO
  def initialize(io, content_length); end

  def read(size, outbuf=T.unsafe(nil)); end

  def rewind(); end
end

class Rack::Multipart::Parser::BoundedIO
end

class Rack::Multipart::Parser::Collector
  include ::Enumerable
  def each(&blk); end

  def initialize(tempfile); end

  def on_mime_body(mime_index, content); end

  def on_mime_finish(mime_index); end

  def on_mime_head(mime_index, head, filename, content_type, name); end
end

class Rack::Multipart::Parser::Collector::BufferPart
  def close(); end

  def file?(); end
end

class Rack::Multipart::Parser::Collector::BufferPart
end

class Rack::Multipart::Parser::Collector::MimePart
  def get_data(); end
end

class Rack::Multipart::Parser::Collector::MimePart
end

class Rack::Multipart::Parser::Collector::TempfilePart
  def close(); end

  def file?(); end
end

class Rack::Multipart::Parser::Collector::TempfilePart
end

class Rack::Multipart::Parser::Collector
end

class Rack::Multipart::Parser::MultipartInfo
  def params(); end

  def params=(_); end

  def tmp_files(); end

  def tmp_files=(_); end
end

class Rack::Multipart::Parser::MultipartInfo
  def self.[](*_); end

  def self.members(); end
end

class Rack::Multipart::Parser
  def self.parse(io, content_length, content_type, tmpfile, bufsize, qp); end

  def self.parse_boundary(content_type); end
end

class Rack::Multipart::UploadedFile
  def content_type(); end

  def content_type=(content_type); end

  def initialize(path, content_type=T.unsafe(nil), binary=T.unsafe(nil)); end

  def local_path(); end

  def method_missing(method_name, *args, &block); end

  def original_filename(); end

  def path(); end

  def respond_to?(*args); end
end

class Rack::Multipart::UploadedFile
end

module Rack::Multipart
  def self.build_multipart(params, first=T.unsafe(nil)); end

  def self.extract_multipart(req, params=T.unsafe(nil)); end

  def self.parse_multipart(env, params=T.unsafe(nil)); end
end

class Rack::NullLogger
  def <<(msg); end

  def add(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def call(env); end

  def close(); end

  def datetime_format(); end

  def datetime_format=(datetime_format); end

  def debug(progname=T.unsafe(nil), &block); end

  def debug?(); end

  def error(progname=T.unsafe(nil), &block); end

  def error?(); end

  def fatal(progname=T.unsafe(nil), &block); end

  def fatal?(); end

  def formatter(); end

  def formatter=(formatter); end

  def info(progname=T.unsafe(nil), &block); end

  def info?(); end

  def initialize(app); end

  def level(); end

  def level=(level); end

  def progname(); end

  def progname=(progname); end

  def sev_threshold(); end

  def sev_threshold=(sev_threshold); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end

  def warn?(); end
end

class Rack::NullLogger
end

class Rack::Proxy
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::QueryParser
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
end

class Rack::Recursive
  def _call(env); end

  def call(env); end

  def include(env, path); end

  def initialize(app); end
end

class Rack::Recursive
end

class Rack::Reloader
  def call(env); end

  def initialize(app, cooldown=T.unsafe(nil), backend=T.unsafe(nil)); end

  def reload!(stderr=T.unsafe(nil)); end

  def safe_load(file, mtime, stderr=T.unsafe(nil)); end
end

module Rack::Reloader::Stat
  def figure_path(file, paths); end

  def rotation(); end

  def safe_stat(file); end
end

module Rack::Reloader::Stat
end

class Rack::Reloader
end

class Rack::Request
  ALLOWED_SCHEMES = ::T.let(nil, ::T.untyped)
  SCHEME_WHITELIST = ::T.let(nil, ::T.untyped)
end

module Rack::Request::Helpers
  DEFAULT_PORTS = ::T.let(nil, ::T.untyped)
  FORM_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_HOST = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PORT = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PROTO = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SCHEME = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SSL = ::T.let(nil, ::T.untyped)
  PARSEABLE_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
end

class Rack::Response
  CHUNKED = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
end

class Rack::Runtime
  FORMAT_STRING = ::T.let(nil, ::T.untyped)
  HEADER_NAME = ::T.let(nil, ::T.untyped)
end

class Rack::Server
  def app(); end

  def default_options(); end

  def initialize(options=T.unsafe(nil)); end

  def middleware(); end

  def options(); end

  def options=(options); end

  def server(); end

  def start(&blk); end
end

class Rack::Server::Options
  def handler_opts(options); end

  def parse!(args); end
end

class Rack::Server::Options
end

class Rack::Server
  def self.default_middleware_by_environment(); end

  def self.logging_middleware(); end

  def self.middleware(); end

  def self.start(options=T.unsafe(nil)); end
end

class Rack::Session::Abstract::Persisted
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::SessionHash
  Unspecified = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Cookie::SessionId
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Pool
  def delete_session(req, session_id, options); end

  def find_session(req, sid); end

  def generate_sid(); end

  def mutex(); end

  def pool(); end

  def with_lock(req); end

  def write_session(req, session_id, new_session, options); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Pool
end

class Rack::Session::SessionId
  ID_VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::ShowExceptions
  def call(env); end

  def dump_exception(exception); end

  def h(obj); end

  def initialize(app); end

  def prefers_plaintext?(env); end

  def pretty(env, exception); end

  def template(); end
  CONTEXT = ::T.let(nil, ::T.untyped)
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowExceptions
end

class Rack::ShowStatus
  def call(env); end

  def h(obj); end

  def initialize(app); end
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowStatus
end

class Rack::Static
  def add_index_root?(path); end

  def applicable_rules(path); end

  def call(env); end

  def can_serve(path); end

  def initialize(app, options=T.unsafe(nil)); end

  def overwrite_file_path(path); end

  def route_file(path); end
end

class Rack::Static
end

module Rack::Test
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Test::CookieJar
  DELIMITER = ::T.let(nil, ::T.untyped)
end

module Rack::Test::Methods
  METHODS = ::T.let(nil, ::T.untyped)
end

class Rack::URLMap
  def call(env); end

  def initialize(map=T.unsafe(nil)); end

  def remap(map); end
  INFINITY = ::T.let(nil, ::T.untyped)
  NEGATIVE_INFINITY = ::T.let(nil, ::T.untyped)
end

class Rack::URLMap
end

module Rack::Utils
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML_PATTERN = ::T.let(nil, ::T.untyped)
  HTTP_STATUS_CODES = ::T.let(nil, ::T.untyped)
  NULL_BYTE = ::T.let(nil, ::T.untyped)
  PATH_SEPS = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
  SYMBOL_TO_STATUS_CODE = ::T.let(nil, ::T.untyped)
end

Rack::Utils::InvalidParameterError = Rack::QueryParser::InvalidParameterError

Rack::Utils::KeySpaceConstrainedParams = Rack::QueryParser::Params

Rack::Utils::ParameterTypeError = Rack::QueryParser::ParameterTypeError

class Rails::Application
  INITIAL_VARIABLES = ::T.let(nil, ::T.untyped)
end

class Rails::ApplicationController
end

class Rails::ApplicationController
end

module Rails::Autoloaders
  extend ::Enumerable
end

class Rails::BacktraceCleaner
  APP_DIRS_PATTERN = ::T.let(nil, ::T.untyped)
  DOT_SLASH = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  RENDER_TEMPLATE_PATTERN = ::T.let(nil, ::T.untyped)
  SLASH = ::T.let(nil, ::T.untyped)
end

module Rails::Command
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
end

module Rails::Command::Actions
  def load_generators(); end

  def load_tasks(); end

  def require_application!(); end

  def require_application_and_environment!(); end

  def require_environment!(); end

  def set_application_directory!(); end
end

module Rails::Command::Actions
end

class Rails::Command::Base
  include ::Rails::Command::Actions
  def help(); end
end

class Rails::Command::Base::Error
end

class Rails::Command::Base::Error
end

class Rails::Command::Base
  def self.banner(*_); end

  def self.base_name(); end

  def self.command_name(); end

  def self.default_command_root(); end

  def self.desc(usage=T.unsafe(nil), description=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.engine?(); end

  def self.executable(); end

  def self.hide_command!(); end

  def self.inherited(base); end

  def self.perform(command, args, config); end

  def self.printing_commands(); end

  def self.usage_path(); end
end

module Rails::Command::Spellchecker
end

module Rails::Command::Spellchecker
  def self.suggest(word, from:); end
end

module Rails::Generators
  DEFAULT_ALIASES = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

module Rails::Generators::Actions
  def add_source(source, options=T.unsafe(nil), &block); end

  def application(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def environment(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def gem(*args); end

  def gem_group(*names, &block); end

  def generate(what, *args); end

  def git(commands=T.unsafe(nil)); end

  def github(repo, options=T.unsafe(nil), &block); end

  def initialize(*_); end

  def initializer(filename, data=T.unsafe(nil)); end

  def lib(filename, data=T.unsafe(nil)); end

  def rails_command(command, options=T.unsafe(nil)); end

  def rake(command, options=T.unsafe(nil)); end

  def rakefile(filename, data=T.unsafe(nil)); end

  def readme(path); end

  def route(routing_code); end

  def vendor(filename, data=T.unsafe(nil)); end
end

class Rails::Generators::Actions::CreateMigration
  def existing_migration(); end

  def migration_dir(); end

  def migration_file_name(); end

  def relative_existing_migration(); end
end

class Rails::Generators::Actions::CreateMigration
end

module Rails::Generators::Actions
end

class Rails::Generators::ActiveModel
  def destroy(); end

  def errors(); end

  def initialize(name); end

  def name(); end

  def save(); end

  def update(params=T.unsafe(nil)); end
end

class Rails::Generators::ActiveModel
  def self.all(klass); end

  def self.build(klass, params=T.unsafe(nil)); end

  def self.find(klass, params=T.unsafe(nil)); end
end

module Rails::Generators::AppName
  RESERVED_NAMES = ::T.let(nil, ::T.untyped)
end

module Rails::Generators::AppName
end

class Rails::Generators::Base
  include ::Thor::Actions
  include ::Rails::Generators::Actions
end

class Rails::Generators::Base
  def self.add_shebang_option!(); end

  def self.base_name(); end

  def self.base_root(); end

  def self.default_aliases_for_option(name, options); end

  def self.default_for_option(config, name, options, default); end

  def self.default_generator_root(); end

  def self.default_source_root(); end

  def self.default_value_for_option(name, options); end

  def self.generator_name(); end

  def self.hide!(); end

  def self.hook_for(*names, &block); end

  def self.hooks(); end

  def self.inherited(base); end

  def self.prepare_for_invocation(name, value); end

  def self.remove_hook_for(*names); end

  def self.usage_path(); end
end

module Rails::Generators::Database
  def convert_database_option_for_jruby(); end

  def gem_for_database(database=T.unsafe(nil)); end

  def initialize(*_); end
  DATABASES = ::T.let(nil, ::T.untyped)
  JDBC_DATABASES = ::T.let(nil, ::T.untyped)
end

module Rails::Generators::Database
end

module Rails::Generators::Migration
  def create_migration(destination, data, config=T.unsafe(nil), &block); end

  def migration_class_name(); end

  def migration_file_name(); end

  def migration_number(); end

  def migration_template(source, destination, config=T.unsafe(nil)); end

  def set_migration_assigns!(destination); end
end

module Rails::Generators::Migration::ClassMethods
  def current_migration_number(dirname); end

  def migration_exists?(dirname, file_name); end

  def migration_lookup_at(dirname); end

  def next_migration_number(dirname); end
end

module Rails::Generators::Migration::ClassMethods
end

module Rails::Generators::Migration
  extend ::ActiveSupport::Concern
end

class Rails::Generators::NamedBase
  def file_name(); end

  def initialize(args, *options); end

  def js_template(source, destination); end

  def name(); end

  def name=(name); end
end

class Rails::Generators::NamedBase
  def self.check_class_collision(options=T.unsafe(nil)); end
end

module Rails::Generators::ResourceHelpers
  def initialize(*args); end
end

module Rails::Generators::ResourceHelpers
  def self.included(base); end
end

class Rails::Generators::TestCase
  include ::FileUtils::StreamUtils_
end

module Rails::Html
  XPATHS_TO_REMOVE = ::T.let(nil, ::T.untyped)
end

class Rails::Html::Sanitizer
  VERSION = ::T.let(nil, ::T.untyped)
end

Rails::Html::WhiteListSanitizer = Rails::Html::SafeListSanitizer

module Rails::Info
  def properties(); end

  def properties=(obj); end
end

module Rails::Info
  def self.properties(); end

  def self.properties=(obj); end

  def self.property(name, value=T.unsafe(nil)); end

  def self.to_html(); end
end

class Rails::InfoController
  def _layout_from_proc(); end

  def index(); end

  def properties(); end

  def routes(); end
end

class Rails::InfoController
end

class Rails::MailersController
  def index(); end

  def preview(); end
end

class Rails::MailersController
end

class Rails::Rack::Logger
  def call(env); end

  def initialize(app, taggers=T.unsafe(nil)); end
end

class Rails::Railtie
  ABSTRACT_RAILTIES = ::T.let(nil, ::T.untyped)
end

module Rails::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class Rails::WelcomeController
  def index(); end
end

class Rails::WelcomeController
end

module Rake
  EARLY = ::T.let(nil, ::T.untyped)
  EMPTY_TASK_ARGS = ::T.let(nil, ::T.untyped)
  LATE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rake::Application
  include ::Rake::TaskManager
  include ::Rake::TraceOutput
  def add_import(fn); end

  def add_loader(ext, loader); end

  def collect_command_line_tasks(args); end

  def default_task_name(); end

  def deprecate(old_usage, new_usage, call_site); end

  def display_cause_details(ex); end

  def display_error_message(ex); end

  def display_exception_backtrace(ex); end

  def display_exception_details(ex); end

  def display_exception_details_seen(); end

  def display_exception_message_details(ex); end

  def display_prerequisites(); end

  def display_tasks_and_comments(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def exit_because_of_exception(ex); end

  def find_rakefile_location(); end

  def handle_options(argv); end

  def has_cause?(ex); end

  def have_rakefile(); end

  def init(app_name=T.unsafe(nil), argv=T.unsafe(nil)); end

  def invoke_task(task_string); end

  def load_imports(); end

  def load_rakefile(); end

  def name(); end

  def options(); end

  def original_dir(); end

  def parse_task_string(string); end

  def print_rakefile_directory(location); end

  def rake_require(file_name, paths=T.unsafe(nil), loaded=T.unsafe(nil)); end

  def rakefile(); end

  def rakefile_location(backtrace=T.unsafe(nil)); end

  def raw_load_rakefile(); end

  def run(argv=T.unsafe(nil)); end

  def run_with_threads(); end

  def set_default_options(); end

  def standard_exception_handling(); end

  def standard_rake_options(); end

  def system_dir(); end

  def terminal_columns(); end

  def terminal_columns=(terminal_columns); end

  def terminal_width(); end

  def thread_pool(); end

  def top_level(); end

  def top_level_tasks(); end

  def trace(*strings); end

  def truncate(string, width); end

  def truncate_output?(); end

  def tty_output=(tty_output); end

  def tty_output?(); end

  def unix?(); end

  def windows?(); end
  DEFAULT_RAKEFILES = ::T.let(nil, ::T.untyped)
end

class Rake::Application
end

module Rake::Backtrace
  SUPPRESSED_PATHS = ::T.let(nil, ::T.untyped)
  SUPPRESSED_PATHS_RE = ::T.let(nil, ::T.untyped)
  SUPPRESS_PATTERN = ::T.let(nil, ::T.untyped)
  SYS_KEYS = ::T.let(nil, ::T.untyped)
  SYS_PATHS = ::T.let(nil, ::T.untyped)
end

module Rake::Backtrace
  def self.collapse(backtrace); end
end

class Rake::CommandLineOptionError
end

class Rake::CommandLineOptionError
end

class Rake::CpuCounter
  def count(); end

  def count_with_default(default=T.unsafe(nil)); end
end

class Rake::CpuCounter
  def self.count(); end
end

module Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Rake::DSL
end

class Rake::DefaultLoader
  def load(fn); end
end

class Rake::DefaultLoader
end

class Rake::EarlyTime
  include ::Comparable
  include ::Singleton
end

class Rake::EarlyTime
  extend ::Singleton::SingletonClassMethods
end

class Rake::FileCreationTask
end

class Rake::FileCreationTask
end

class Rake::FileList
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PATTERNS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PROCS = ::T.let(nil, ::T.untyped)
  DELEGATING_METHODS = ::T.let(nil, ::T.untyped)
  GLOB_PATTERN = ::T.let(nil, ::T.untyped)
  MUST_DEFINE = ::T.let(nil, ::T.untyped)
  MUST_NOT_DEFINE = ::T.let(nil, ::T.untyped)
  SPECIAL_RETURN = ::T.let(nil, ::T.untyped)
end

class Rake::FileTask
end

class Rake::FileTask
end

module Rake::FileUtilsExt
  include ::FileUtils::StreamUtils_
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  extend ::FileUtils::StreamUtils_
end

class Rake::InvocationChain
  def append(invocation); end

  def member?(invocation); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::InvocationChain::EmptyInvocationChain
  def append(invocation); end

  def member?(obj); end
end

class Rake::InvocationChain::EmptyInvocationChain
end

class Rake::InvocationChain
  def self.append(invocation, chain); end
end

module Rake::InvocationExceptionMixin
  def chain(); end

  def chain=(value); end
end

module Rake::InvocationExceptionMixin
end

class Rake::LateTime
  include ::Comparable
  include ::Singleton
end

class Rake::LateTime
  extend ::Singleton::SingletonClassMethods
end

class Rake::LinkedList
  include ::Enumerable
  def ==(other); end

  def conj(item); end

  def each(&blk); end

  def empty?(); end

  def head(); end

  def initialize(head, tail=T.unsafe(nil)); end

  def tail(); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::LinkedList::EmptyLinkedList
  def initialize(); end
end

class Rake::LinkedList::EmptyLinkedList
end

class Rake::LinkedList
  def self.cons(head, tail); end

  def self.empty(); end

  def self.make(*args); end
end

class Rake::MultiTask
end

class Rake::MultiTask
end

class Rake::NameSpace
  def [](name); end

  def initialize(task_manager, scope_list); end

  def scope(); end

  def tasks(); end
end

class Rake::NameSpace
end

module Rake::PrivateReader
end

module Rake::PrivateReader::ClassMethods
  def private_reader(*names); end
end

module Rake::PrivateReader::ClassMethods
end

module Rake::PrivateReader
  def self.included(base); end
end

class Rake::Promise
  def initialize(args, &block); end

  def recorder(); end

  def recorder=(recorder); end

  def value(); end

  def work(); end
  NOT_SET = ::T.let(nil, ::T.untyped)
end

class Rake::Promise
end

class Rake::PseudoStatus
  def >>(n); end

  def exited?(); end

  def exitstatus(); end

  def initialize(code=T.unsafe(nil)); end

  def stopped?(); end

  def to_i(); end
end

class Rake::PseudoStatus
end

Rake::RDocTask = RDoc::Task

class Rake::RuleRecursionOverflowError
  def add_target(target); end

  def initialize(*args); end
end

class Rake::RuleRecursionOverflowError
end

class Rake::Scope
  def path(); end

  def path_with_task_name(task_name); end

  def trim(n); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::Scope::EmptyScope
  def path(); end

  def path_with_task_name(task_name); end
end

class Rake::Scope::EmptyScope
end

class Rake::Scope
end

class Rake::Task
  def actions(); end

  def add_description(description); end

  def all_prerequisite_tasks(); end

  def already_invoked(); end

  def application(); end

  def application=(application); end

  def arg_description(); end

  def arg_names(); end

  def clear(); end

  def clear_actions(); end

  def clear_args(); end

  def clear_comments(); end

  def clear_prerequisites(); end

  def collect_prerequisites(seen); end

  def comment(); end

  def comment=(comment); end

  def enhance(deps=T.unsafe(nil), &block); end

  def execute(args=T.unsafe(nil)); end

  def full_comment(); end

  def initialize(task_name, app); end

  def investigation(); end

  def invoke(*args); end

  def invoke_prerequisites(task_args, invocation_chain); end

  def invoke_prerequisites_concurrently(task_args, invocation_chain); end

  def invoke_with_call_chain(task_args, invocation_chain); end

  def locations(); end

  def name(); end

  def name_with_args(); end

  def needed?(); end

  def order_only_prerequisites(); end

  def prereqs(); end

  def prerequisite_tasks(); end

  def prerequisites(); end

  def reenable(); end

  def scope(); end

  def set_arg_names(args); end

  def source(); end

  def sources(); end

  def sources=(sources); end

  def timestamp(); end

  def |(deps); end
end

class Rake::Task
  def self.[](task_name); end

  def self.clear(); end

  def self.create_rule(*args, &block); end

  def self.define_task(*args, &block); end

  def self.format_deps(deps); end

  def self.scope_name(scope, task_name); end

  def self.task_defined?(task_name); end

  def self.tasks(); end
end

class Rake::TaskArgumentError
end

class Rake::TaskArgumentError
end

class Rake::TaskArguments
  include ::Enumerable
  def [](index); end

  def each(&block); end

  def extras(); end

  def fetch(*args, &block); end

  def has_key?(key); end

  def initialize(names, values, parent=T.unsafe(nil)); end

  def key?(key); end

  def lookup(name); end

  def method_missing(sym, *args); end

  def names(); end

  def new_scope(names); end

  def to_a(); end

  def to_hash(); end

  def values_at(*keys); end

  def with_defaults(defaults); end
end

class Rake::TaskArguments
end

class Rake::TaskLib
  include ::Rake::Cloneable
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

class Rake::TaskLib
end

module Rake::TaskManager
  def [](task_name, scopes=T.unsafe(nil)); end

  def clear(); end

  def create_rule(*args, &block); end

  def current_scope(); end

  def define_task(task_class, *args, &block); end

  def enhance_with_matching_rule(task_name, level=T.unsafe(nil)); end

  def generate_did_you_mean_suggestions(task_name); end

  def generate_message_for_undefined_task(task_name); end

  def in_namespace(name); end

  def initialize(); end

  def intern(task_class, task_name); end

  def last_description(); end

  def last_description=(last_description); end

  def lookup(task_name, initial_scope=T.unsafe(nil)); end

  def resolve_args(args); end

  def synthesize_file_task(task_name); end

  def tasks(); end

  def tasks_in_scope(scope); end
end

module Rake::TaskManager
  def self.record_task_metadata(); end

  def self.record_task_metadata=(record_task_metadata); end
end

class Rake::ThreadHistoryDisplay
  include ::Rake::PrivateReader
  def initialize(stats); end

  def show(); end
end

class Rake::ThreadHistoryDisplay
  extend ::Rake::PrivateReader::ClassMethods
end

class Rake::ThreadPool
  def future(*args, &block); end

  def gather_history(); end

  def history(); end

  def initialize(thread_count); end

  def join(); end

  def statistics(); end
end

class Rake::ThreadPool
end

module Rake::TraceOutput
  def trace_on(out, *strings); end
end

module Rake::TraceOutput
end

module Rake::Version
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  NUMBERS = ::T.let(nil, ::T.untyped)
  OTHER = ::T.let(nil, ::T.untyped)
end

module Rake::Version
end

module Rake::Win32
end

class Rake::Win32::Win32HomeError
end

class Rake::Win32::Win32HomeError
end

module Rake::Win32
  def self.normalize(path); end

  def self.win32_system_dir(); end

  def self.windows?(); end
end

module Rake
  extend ::Rake::FileUtilsExt
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  def self.add_rakelib(*files); end

  def self.application(); end

  def self.application=(app); end

  def self.load_rakefile(path); end

  def self.original_dir(); end

  def self.suggested_thread_count(); end

  def self.with_application(block_application=T.unsafe(nil)); end
end

module Random::Formatter
  def alphanumeric(n=T.unsafe(nil)); end

  ALPHANUMERIC = ::T.let(nil, ::T.untyped)
end

class Random
  def self.bytes(_); end

  def self.urandom(_); end
end

class Range
  include ::ActiveSupport::RangeWithFormat
  include ::ActiveSupport::CompareWithRange
  include ::ActiveSupport::IncludeTimeWithZone
  include ::ActiveSupport::EachTimeWithZone
  def %(_); end

  def entries(); end

  def to_a(); end
end

class Rational
  def to_d(precision); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end

  def self.ruby(); end
end

module Readapt
  VERSION = ::T.let(nil, ::T.untyped)
end

class Readapt::Debugger
  include ::Observable
end

class Readapt::Frame
  NULL_FRAME = ::T.let(nil, ::T.untyped)
end

class Readapt::Shell
  def serve(); end

  def version(); end
end

module Readline
  FILENAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  HISTORY = ::T.let(nil, ::T.untyped)
  USERNAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Readline
  def self.basic_quote_characters(); end

  def self.basic_quote_characters=(basic_quote_characters); end

  def self.basic_word_break_characters(); end

  def self.basic_word_break_characters=(basic_word_break_characters); end

  def self.completer_quote_characters(); end

  def self.completer_quote_characters=(completer_quote_characters); end

  def self.completer_word_break_characters(); end

  def self.completer_word_break_characters=(completer_word_break_characters); end

  def self.completion_append_character(); end

  def self.completion_append_character=(completion_append_character); end

  def self.completion_case_fold(); end

  def self.completion_case_fold=(completion_case_fold); end

  def self.completion_proc(); end

  def self.completion_proc=(completion_proc); end

  def self.completion_quote_character(); end

  def self.delete_text(*_); end

  def self.emacs_editing_mode(); end

  def self.emacs_editing_mode?(); end

  def self.filename_quote_characters(); end

  def self.filename_quote_characters=(filename_quote_characters); end

  def self.get_screen_size(); end

  def self.input=(input); end

  def self.insert_text(_); end

  def self.line_buffer(); end

  def self.output=(output); end

  def self.point(); end

  def self.point=(point); end

  def self.pre_input_hook(); end

  def self.pre_input_hook=(pre_input_hook); end

  def self.quoting_detection_proc(); end

  def self.quoting_detection_proc=(quoting_detection_proc); end

  def self.redisplay(); end

  def self.refresh_line(); end

  def self.set_screen_size(_, _1); end

  def self.special_prefixes(); end

  def self.special_prefixes=(special_prefixes); end

  def self.vi_editing_mode(); end

  def self.vi_editing_mode?(); end
end

class Regexp
  def match?(*_); end
  TOKEN_KEYS = ::T.let(nil, ::T.untyped)
end

Regexp::Expression::Alternation::OPERAND = Regexp::Expression::Alternative

Regexp::Expression::Anchor::BOL = Regexp::Expression::Anchor::BeginningOfLine

Regexp::Expression::Anchor::BOS = Regexp::Expression::Anchor::BeginningOfString

Regexp::Expression::Anchor::EOL = Regexp::Expression::Anchor::EndOfLine

Regexp::Expression::Anchor::EOS = Regexp::Expression::Anchor::EndOfString

Regexp::Expression::Anchor::EOSobEOL = Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine

Regexp::Expression::CharacterSet::Intersection::OPERAND = Regexp::Expression::CharacterSet::IntersectedSequence

Regexp::Expression::MatchLength = Regexp::MatchLength

class Regexp::Expression::Quantifier
  MODES = ::T.let(nil, ::T.untyped)
end

class Regexp::Lexer
  CLOSING_TOKENS = ::T.let(nil, ::T.untyped)
  OPENING_TOKENS = ::T.let(nil, ::T.untyped)
end

class Regexp::Parser
  ENC_FLAGS = ::T.let(nil, ::T.untyped)
  MOD_FLAGS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Regexp::Scanner
  PROP_MAPS_DIR = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax
  VERSION_CONST_REGEXP = ::T.let(nil, ::T.untyped)
  VERSION_FORMAT = ::T.let(nil, ::T.untyped)
  VERSION_REGEXP = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token
  All = ::T.let(nil, ::T.untyped)
  Map = ::T.let(nil, ::T.untyped)
  Types = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Anchor
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  MatchStart = ::T.let(nil, ::T.untyped)
  String = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Assertion
  All = ::T.let(nil, ::T.untyped)
  Lookahead = ::T.let(nil, ::T.untyped)
  Lookbehind = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Backreference
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  RecursionLevel = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterSet
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterType
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Clustered = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Conditional
  All = ::T.let(nil, ::T.untyped)
  Condition = ::T.let(nil, ::T.untyped)
  Delimiters = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Escape
  ASCII = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Control = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Meta = ::T.let(nil, ::T.untyped)
  Octal = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  Unicode = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::FreeSpace
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Group
  All = ::T.let(nil, ::T.untyped)
  Atomic = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Comment = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Named = ::T.let(nil, ::T.untyped)
  Passive = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  V1_8_6 = ::T.let(nil, ::T.untyped)
  V2_4_1 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Keep
  All = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Literal
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Meta
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::PosixClass
  All = ::T.let(nil, ::T.untyped)
  Extensions = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  Standard = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Quantifier
  All = ::T.let(nil, ::T.untyped)
  Greedy = ::T.let(nil, ::T.untyped)
  Interval = ::T.let(nil, ::T.untyped)
  IntervalAll = ::T.let(nil, ::T.untyped)
  IntervalPossessive = ::T.let(nil, ::T.untyped)
  IntervalReluctant = ::T.let(nil, ::T.untyped)
  Possessive = ::T.let(nil, ::T.untyped)
  Reluctant = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::SubexpressionCall
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty
  Age = ::T.let(nil, ::T.untyped)
  Age_V1_9_3 = ::T.let(nil, ::T.untyped)
  Age_V2_0_0 = ::T.let(nil, ::T.untyped)
  Age_V2_2_0 = ::T.let(nil, ::T.untyped)
  Age_V2_3_0 = ::T.let(nil, ::T.untyped)
  Age_V2_4_0 = ::T.let(nil, ::T.untyped)
  Age_V2_5_0 = ::T.let(nil, ::T.untyped)
  Age_V2_6_0 = ::T.let(nil, ::T.untyped)
  Age_V2_6_2 = ::T.let(nil, ::T.untyped)
  Age_V2_6_3 = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  CharType_V1_9_0 = ::T.let(nil, ::T.untyped)
  CharType_V2_5_0 = ::T.let(nil, ::T.untyped)
  Derived = ::T.let(nil, ::T.untyped)
  Derived_V1_9_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_0_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_4_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_5_0 = ::T.let(nil, ::T.untyped)
  Emoji = ::T.let(nil, ::T.untyped)
  Emoji_V2_5_0 = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  POSIX = ::T.let(nil, ::T.untyped)
  Script = ::T.let(nil, ::T.untyped)
  Script_V1_9_0 = ::T.let(nil, ::T.untyped)
  Script_V1_9_3 = ::T.let(nil, ::T.untyped)
  Script_V2_0_0 = ::T.let(nil, ::T.untyped)
  Script_V2_2_0 = ::T.let(nil, ::T.untyped)
  Script_V2_3_0 = ::T.let(nil, ::T.untyped)
  Script_V2_4_0 = ::T.let(nil, ::T.untyped)
  Script_V2_5_0 = ::T.let(nil, ::T.untyped)
  Script_V2_6_0 = ::T.let(nil, ::T.untyped)
  Script_V2_6_2 = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  UnicodeBlock = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V1_9_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_0_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_2_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_3_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_4_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_5_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_6_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_6_2 = ::T.let(nil, ::T.untyped)
  V1_9_0 = ::T.let(nil, ::T.untyped)
  V1_9_3 = ::T.let(nil, ::T.untyped)
  V2_0_0 = ::T.let(nil, ::T.untyped)
  V2_2_0 = ::T.let(nil, ::T.untyped)
  V2_3_0 = ::T.let(nil, ::T.untyped)
  V2_4_0 = ::T.let(nil, ::T.untyped)
  V2_5_0 = ::T.let(nil, ::T.untyped)
  V2_6_0 = ::T.let(nil, ::T.untyped)
  V2_6_2 = ::T.let(nil, ::T.untyped)
  V2_6_3 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty::Category
  All = ::T.let(nil, ::T.untyped)
  Codepoint = ::T.let(nil, ::T.untyped)
  Letter = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  Punctuation = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Symbol = ::T.let(nil, ::T.untyped)
end

module Reline
  def eof?(*args, &block); end
  FILENAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  HISTORY = ::T.let(nil, ::T.untyped)
  USERNAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Reline::ANSI
  RAW_KEYSTROKE_CONFIG = ::T.let(nil, ::T.untyped)
end

class Reline::ANSI
  def self.clear_screen(); end

  def self.cursor_pos(); end

  def self.deprep(otio); end

  def self.erase_after_cursor(); end

  def self.get_screen_size(); end

  def self.getc(); end

  def self.input=(val); end

  def self.move_cursor_column(x); end

  def self.move_cursor_down(x); end

  def self.move_cursor_up(x); end

  def self.output=(val); end

  def self.prep(); end

  def self.retrieve_keybuffer(); end

  def self.scroll_down(x); end

  def self.set_screen_size(rows, columns); end

  def self.set_winch_handler(&handler); end

  def self.ungetc(c); end
end

class Reline::Config
  def add_default_key_binding(keystroke, target); end

  def bind_key(key, func_name); end

  def bind_tty_special_chars(); end

  def bind_tty_special_chars=(bind_tty_special_chars); end

  def bind_variable(name, value); end

  def blink_matching_paren(); end

  def blink_matching_paren=(blink_matching_paren); end

  def byte_oriented(); end

  def byte_oriented=(byte_oriented); end

  def completion_ignore_case(); end

  def completion_ignore_case=(completion_ignore_case); end

  def convert_meta(); end

  def convert_meta=(convert_meta); end

  def disable_completion(); end

  def disable_completion=(disable_completion); end

  def editing_mode(); end

  def editing_mode=(val); end

  def editing_mode_is?(*val); end

  def enable_keypad(); end

  def enable_keypad=(enable_keypad); end

  def expand_tilde(); end

  def expand_tilde=(expand_tilde); end

  def handle_directive(directive, file, no); end

  def history_preserve_point(); end

  def history_preserve_point=(history_preserve_point); end

  def history_size(); end

  def history_size=(history_size); end

  def horizontal_scroll_mode(); end

  def horizontal_scroll_mode=(horizontal_scroll_mode); end

  def input_meta(); end

  def input_meta=(input_meta); end

  def key_bindings(); end

  def key_notation_to_code(notation); end

  def keymap(); end

  def keyseq_timeout(); end

  def keyseq_timeout=(keyseq_timeout); end

  def mark_directories(); end

  def mark_directories=(mark_directories); end

  def mark_modified_lines(); end

  def mark_modified_lines=(mark_modified_lines); end

  def mark_symlinked_directories(); end

  def mark_symlinked_directories=(mark_symlinked_directories); end

  def match_hidden_files(); end

  def match_hidden_files=(match_hidden_files); end

  def meta_flag(); end

  def meta_flag=(meta_flag); end

  def output_meta(); end

  def output_meta=(output_meta); end

  def page_completions(); end

  def page_completions=(page_completions); end

  def parse_keyseq(str); end

  def prefer_visible_bell(); end

  def prefer_visible_bell=(prefer_visible_bell); end

  def print_completions_horizontally(); end

  def print_completions_horizontally=(print_completions_horizontally); end

  def read(file=T.unsafe(nil)); end

  def read_lines(lines, file=T.unsafe(nil)); end

  def reset(); end

  def reset_default_key_bindings(); end

  def show_all_if_ambiguous(); end

  def show_all_if_ambiguous=(show_all_if_ambiguous); end

  def show_all_if_unmodified(); end

  def show_all_if_unmodified=(show_all_if_unmodified); end

  def test_mode(); end

  def visible_stats(); end

  def visible_stats=(visible_stats); end
  DEFAULT_PATH = ::T.let(nil, ::T.untyped)
  KEYSEQ_PATTERN = ::T.let(nil, ::T.untyped)
  VARIABLE_NAMES = ::T.let(nil, ::T.untyped)
  VARIABLE_NAME_SYMBOLS = ::T.let(nil, ::T.untyped)
end

class Reline::Config::InvalidInputrc
  def file(); end

  def file=(file); end

  def lineno(); end

  def lineno=(lineno); end
end

class Reline::Config::InvalidInputrc
end

class Reline::Config
end

class Reline::Core
  def ambiguous_width(); end

  def ambiguous_width=(ambiguous_width); end

  def auto_indent_proc(); end

  def auto_indent_proc=(p); end

  def basic_quote_characters(); end

  def basic_quote_characters=(v); end

  def basic_word_break_characters(); end

  def basic_word_break_characters=(v); end

  def completer_quote_characters(); end

  def completer_quote_characters=(v); end

  def completer_word_break_characters(); end

  def completer_word_break_characters=(v); end

  def completion_append_character(); end

  def completion_append_character=(val); end

  def completion_case_fold(); end

  def completion_case_fold=(v); end

  def completion_proc(); end

  def completion_proc=(p); end

  def completion_quote_character(); end

  def config(); end

  def config=(config); end

  def dig_perfect_match_proc(); end

  def dig_perfect_match_proc=(p); end

  def emacs_editing_mode(); end

  def emacs_editing_mode?(); end

  def filename_quote_characters(); end

  def filename_quote_characters=(v); end

  def get_screen_size(); end

  def input=(val); end

  def key_stroke(); end

  def key_stroke=(key_stroke); end

  def last_incremental_search(); end

  def last_incremental_search=(last_incremental_search); end

  def line_editor(); end

  def line_editor=(line_editor); end

  def output(); end

  def output=(val); end

  def output_modifier_proc(); end

  def output_modifier_proc=(p); end

  def pre_input_hook(); end

  def pre_input_hook=(p); end

  def prompt_proc(); end

  def prompt_proc=(p); end

  def readline(prompt=T.unsafe(nil), add_hist=T.unsafe(nil)); end

  def readmultiline(prompt=T.unsafe(nil), add_hist=T.unsafe(nil), &confirm_multiline_termination); end

  def special_prefixes(); end

  def special_prefixes=(v); end

  def vi_editing_mode(); end

  def vi_editing_mode?(); end
  ATTR_READER_NAMES = ::T.let(nil, ::T.untyped)
end

class Reline::Core
end

class Reline::CursorPos
  def x(); end

  def x=(_); end

  def y(); end

  def y=(_); end
end

class Reline::CursorPos
  def self.[](*_); end

  def self.members(); end
end

class Reline::GeneralIO
  RAW_KEYSTROKE_CONFIG = ::T.let(nil, ::T.untyped)
end

class Reline::GeneralIO
  def self.clear_screen(); end

  def self.cursor_pos(); end

  def self.deprep(otio); end

  def self.erase_after_cursor(); end

  def self.get_screen_size(); end

  def self.getc(); end

  def self.input=(val); end

  def self.move_cursor_column(val); end

  def self.move_cursor_down(val); end

  def self.move_cursor_up(val); end

  def self.prep(); end

  def self.scroll_down(val); end

  def self.set_screen_size(rows, columns); end

  def self.set_winch_handler(&handler); end

  def self.ungetc(c); end
end

class Reline::History
  def <<(val); end

  def [](index); end

  def []=(index, val); end

  def concat(*val); end

  def delete_at(index); end

  def initialize(config); end

  def push(*val); end

  def to_s(); end
end

class Reline::History
end

Reline::IOGate = Reline::ANSI

Reline::Key = Struct::Key

module Reline::KeyActor
end

class Reline::KeyActor::Base
  def get_method(key); end
  MAPPING = ::T.let(nil, ::T.untyped)
end

class Reline::KeyActor::Base
end

class Reline::KeyActor::Emacs
  MAPPING = ::T.let(nil, ::T.untyped)
end

class Reline::KeyActor::Emacs
end

class Reline::KeyActor::ViCommand
  MAPPING = ::T.let(nil, ::T.untyped)
end

class Reline::KeyActor::ViCommand
end

class Reline::KeyActor::ViInsert
  MAPPING = ::T.let(nil, ::T.untyped)
end

class Reline::KeyActor::ViInsert
end

module Reline::KeyActor
end

class Reline::KeyStroke
  def expand(input); end

  def initialize(config); end

  def match_status(input); end
end

class Reline::KeyStroke
end

class Reline::KillRing
  def append(string, before_p=T.unsafe(nil)); end

  def initialize(max=T.unsafe(nil)); end

  def process(); end

  def yank(); end

  def yank_pop(); end
end

class Reline::KillRing::RingBuffer
  def <<(point); end

  def empty?(); end

  def head(); end

  def initialize(max=T.unsafe(nil)); end

  def size(); end
end

class Reline::KillRing::RingBuffer
end

class Reline::KillRing::RingPoint
  def ==(other); end

  def backward(); end

  def backward=(_); end

  def forward(); end

  def forward=(_); end

  def initialize(str); end

  def str(); end

  def str=(_); end
end

class Reline::KillRing::RingPoint
  def self.[](*_); end

  def self.members(); end
end

module Reline::KillRing::State
  CONTINUED = ::T.let(nil, ::T.untyped)
  FRESH = ::T.let(nil, ::T.untyped)
  PROCESSED = ::T.let(nil, ::T.untyped)
  YANK = ::T.let(nil, ::T.untyped)
end

module Reline::KillRing::State
end

class Reline::KillRing
end

class Reline::LineEditor
  def auto_indent_proc(); end

  def auto_indent_proc=(auto_indent_proc); end

  def byte_pointer(); end

  def byte_pointer=(val); end

  def call_completion_proc(); end

  def completion_append_character(); end

  def completion_append_character=(completion_append_character); end

  def completion_proc(); end

  def completion_proc=(completion_proc); end

  def confirm_multiline_termination(); end

  def confirm_multiline_termination_proc(); end

  def confirm_multiline_termination_proc=(confirm_multiline_termination_proc); end

  def delete_text(start=T.unsafe(nil), length=T.unsafe(nil)); end

  def dig_perfect_match_proc(); end

  def dig_perfect_match_proc=(dig_perfect_match_proc); end

  def editing_mode(); end

  def eof?(); end

  def finalize(); end

  def finish(); end

  def finished?(); end

  def initialize(config); end

  def input_key(key); end

  def insert_text(text); end

  def line(); end

  def multiline_off(); end

  def multiline_on(); end

  def output=(output); end

  def output_modifier_proc(); end

  def output_modifier_proc=(output_modifier_proc); end

  def pre_input_hook(); end

  def pre_input_hook=(pre_input_hook); end

  def prompt_proc(); end

  def prompt_proc=(prompt_proc); end

  def rerender(); end

  def reset(prompt=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def reset_line(); end

  def reset_variables(prompt=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def retrieve_completion_block(set_completion_quote_character=T.unsafe(nil)); end

  def whole_buffer(); end

  def whole_lines(index: T.unsafe(nil), line: T.unsafe(nil)); end
  CSI_REGEXP = ::T.let(nil, ::T.untyped)
  NON_PRINTING_END = ::T.let(nil, ::T.untyped)
  NON_PRINTING_START = ::T.let(nil, ::T.untyped)
  OSC_REGEXP = ::T.let(nil, ::T.untyped)
  VI_MOTIONS = ::T.let(nil, ::T.untyped)
  WIDTH_SCANNER = ::T.let(nil, ::T.untyped)
end

Reline::LineEditor::CompletionJourneyData = Struct::CompletionJourneyData

module Reline::LineEditor::CompletionState
  COMPLETION = ::T.let(nil, ::T.untyped)
  JOURNEY = ::T.let(nil, ::T.untyped)
  MENU = ::T.let(nil, ::T.untyped)
  MENU_WITH_PERFECT_MATCH = ::T.let(nil, ::T.untyped)
  NORMAL = ::T.let(nil, ::T.untyped)
  PERFECT_MATCH = ::T.let(nil, ::T.untyped)
end

module Reline::LineEditor::CompletionState
end

Reline::LineEditor::MenuInfo = Struct::MenuInfo

class Reline::LineEditor
end

class Reline::Unicode
  EscapedChars = ::T.let(nil, ::T.untyped)
  EscapedPairs = ::T.let(nil, ::T.untyped)
end

class Reline::Unicode::EastAsianWidth
  TYPE_A = ::T.let(nil, ::T.untyped)
  TYPE_F = ::T.let(nil, ::T.untyped)
  TYPE_H = ::T.let(nil, ::T.untyped)
  TYPE_N = ::T.let(nil, ::T.untyped)
  TYPE_NA = ::T.let(nil, ::T.untyped)
  TYPE_W = ::T.let(nil, ::T.untyped)
end

class Reline::Unicode::EastAsianWidth
end

class Reline::Unicode
  def self.ed_transpose_words(line, byte_pointer); end

  def self.em_backward_word(line, byte_pointer); end

  def self.em_big_backward_word(line, byte_pointer); end

  def self.em_forward_word(line, byte_pointer); end

  def self.em_forward_word_with_capitalization(line, byte_pointer); end

  def self.escape_for_print(str); end

  def self.get_mbchar_byte_size_by_first_char(c); end

  def self.get_mbchar_width(mbchar); end

  def self.get_next_mbchar_size(line, byte_pointer); end

  def self.get_prev_mbchar_size(line, byte_pointer); end

  def self.vi_backward_word(line, byte_pointer); end

  def self.vi_big_backward_word(line, byte_pointer); end

  def self.vi_big_forward_end_word(line, byte_pointer); end

  def self.vi_big_forward_word(line, byte_pointer); end

  def self.vi_first_print(line); end

  def self.vi_forward_end_word(line, byte_pointer); end

  def self.vi_forward_word(line, byte_pointer); end
end

module Reline
  extend ::Forwardable
  extend ::SingleForwardable
  def self.ambiguous_width(*args, &block); end

  def self.auto_indent_proc(*args, &block); end

  def self.auto_indent_proc=(*args, &block); end

  def self.basic_quote_characters(*args, &block); end

  def self.basic_quote_characters=(*args, &block); end

  def self.basic_word_break_characters(*args, &block); end

  def self.basic_word_break_characters=(*args, &block); end

  def self.completer_quote_characters(*args, &block); end

  def self.completer_quote_characters=(*args, &block); end

  def self.completer_word_break_characters(*args, &block); end

  def self.completer_word_break_characters=(*args, &block); end

  def self.completion_append_character(*args, &block); end

  def self.completion_append_character=(*args, &block); end

  def self.completion_case_fold(*args, &block); end

  def self.completion_case_fold=(*args, &block); end

  def self.completion_proc(*args, &block); end

  def self.completion_proc=(*args, &block); end

  def self.completion_quote_character(*args, &block); end

  def self.core(); end

  def self.delete_text(*args, &block); end

  def self.dig_perfect_match_proc(*args, &block); end

  def self.dig_perfect_match_proc=(*args, &block); end

  def self.emacs_editing_mode(*args, &block); end

  def self.emacs_editing_mode?(*args, &block); end

  def self.eof?(*args, &block); end

  def self.filename_quote_characters(*args, &block); end

  def self.filename_quote_characters=(*args, &block); end

  def self.get_screen_size(*args, &block); end

  def self.input=(*args, &block); end

  def self.insert_text(*args, &block); end

  def self.last_incremental_search(*args, &block); end

  def self.last_incremental_search=(*args, &block); end

  def self.line_buffer(*args, &block); end

  def self.line_editor(); end

  def self.output=(*args, &block); end

  def self.output_modifier_proc(*args, &block); end

  def self.output_modifier_proc=(*args, &block); end

  def self.point(*args, &block); end

  def self.point=(*args, &block); end

  def self.pre_input_hook(*args, &block); end

  def self.pre_input_hook=(*args, &block); end

  def self.prompt_proc(*args, &block); end

  def self.prompt_proc=(*args, &block); end

  def self.readline(*args, &block); end

  def self.readmultiline(*args, &block); end

  def self.redisplay(*args, &block); end

  def self.special_prefixes(*args, &block); end

  def self.special_prefixes=(*args, &block); end

  def self.vi_editing_mode(*args, &block); end

  def self.vi_editing_mode?(*args, &block); end
end

class Ripper
  def column(); end

  def debug_output(); end

  def debug_output=(debug_output); end

  def encoding(); end

  def end_seen?(); end

  def error?(); end

  def filename(); end

  def initialize(*_); end

  def lineno(); end

  def parse(); end

  def state(); end

  def token(); end

  def yydebug(); end

  def yydebug=(yydebug); end
  EVENTS = ::T.let(nil, ::T.untyped)
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_ARG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_BEG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_CMDARG = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_ENDARG = ::T.let(nil, ::T.untyped)
  EXPR_ENDFN = ::T.let(nil, ::T.untyped)
  EXPR_END_ANY = ::T.let(nil, ::T.untyped)
  EXPR_FITEM = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_LABEL = ::T.let(nil, ::T.untyped)
  EXPR_LABELED = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  EXPR_NONE = ::T.let(nil, ::T.untyped)
  EXPR_VALUE = ::T.let(nil, ::T.untyped)
  PARSER_EVENTS = ::T.let(nil, ::T.untyped)
  PARSER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
  SCANNER_EVENTS = ::T.let(nil, ::T.untyped)
  SCANNER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Ripper::Filter
  def column(); end

  def filename(); end

  def initialize(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end

  def lineno(); end

  def parse(init=T.unsafe(nil)); end

  def state(); end
end

class Ripper::Filter
end

class Ripper::Lexer
  def errors(); end

  def lex(); end

  def scan(); end

  def tokenize(); end
end

class Ripper::Lexer::Elem
  def event(); end

  def event=(_); end

  def initialize(pos, event, tok, state, message=T.unsafe(nil)); end

  def message(); end

  def message=(_); end

  def pos(); end

  def pos=(_); end

  def state(); end

  def state=(_); end

  def tok(); end

  def tok=(_); end
end

class Ripper::Lexer::Elem
  def self.[](*_); end

  def self.members(); end
end

class Ripper::Lexer::State
  def &(i); end

  def ==(i); end

  def allbits?(i); end

  def anybits?(i); end

  def initialize(i); end

  def nobits?(i); end

  def to_i(); end

  def to_int(); end

  def to_int=(_); end

  def to_s=(_); end

  def |(i); end
end

class Ripper::Lexer::State
  def self.[](*_); end

  def self.members(); end
end

class Ripper::Lexer
end

class Ripper::SexpBuilder
  def on_BEGIN(*args); end

  def on_CHAR(tok); end

  def on_END(*args); end

  def on___end__(tok); end

  def on_alias(*args); end

  def on_alias_error(*args); end

  def on_aref(*args); end

  def on_aref_field(*args); end

  def on_arg_ambiguous(*args); end

  def on_arg_paren(*args); end

  def on_args_add(*args); end

  def on_args_add_block(*args); end

  def on_args_add_star(*args); end

  def on_args_forward(*args); end

  def on_args_new(*args); end

  def on_array(*args); end

  def on_aryptn(*args); end

  def on_assign(*args); end

  def on_assign_error(*args); end

  def on_assoc_new(*args); end

  def on_assoc_splat(*args); end

  def on_assoclist_from_args(*args); end

  def on_backref(tok); end

  def on_backtick(tok); end

  def on_bare_assoc_hash(*args); end

  def on_begin(*args); end

  def on_binary(*args); end

  def on_block_var(*args); end

  def on_blockarg(*args); end

  def on_bodystmt(*args); end

  def on_brace_block(*args); end

  def on_break(*args); end

  def on_call(*args); end

  def on_case(*args); end

  def on_class(*args); end

  def on_class_name_error(*args); end

  def on_comma(tok); end

  def on_command(*args); end

  def on_command_call(*args); end

  def on_comment(tok); end

  def on_const(tok); end

  def on_const_path_field(*args); end

  def on_const_path_ref(*args); end

  def on_const_ref(*args); end

  def on_cvar(tok); end

  def on_def(*args); end

  def on_defined(*args); end

  def on_defs(*args); end

  def on_do_block(*args); end

  def on_dot2(*args); end

  def on_dot3(*args); end

  def on_dyna_symbol(*args); end

  def on_else(*args); end

  def on_elsif(*args); end

  def on_embdoc(tok); end

  def on_embdoc_beg(tok); end

  def on_embdoc_end(tok); end

  def on_embexpr_beg(tok); end

  def on_embexpr_end(tok); end

  def on_embvar(tok); end

  def on_ensure(*args); end

  def on_excessed_comma(*args); end

  def on_fcall(*args); end

  def on_field(*args); end

  def on_float(tok); end

  def on_for(*args); end

  def on_gvar(tok); end

  def on_hash(*args); end

  def on_heredoc_beg(tok); end

  def on_heredoc_end(tok); end

  def on_hshptn(*args); end

  def on_ident(tok); end

  def on_if(*args); end

  def on_if_mod(*args); end

  def on_ifop(*args); end

  def on_ignored_nl(tok); end

  def on_ignored_sp(tok); end

  def on_imaginary(tok); end

  def on_in(*args); end

  def on_int(tok); end

  def on_ivar(tok); end

  def on_kw(tok); end

  def on_kwrest_param(*args); end

  def on_label(tok); end

  def on_label_end(tok); end

  def on_lambda(*args); end

  def on_lbrace(tok); end

  def on_lbracket(tok); end

  def on_lparen(tok); end

  def on_magic_comment(*args); end

  def on_massign(*args); end

  def on_method_add_arg(*args); end

  def on_method_add_block(*args); end

  def on_mlhs_add(*args); end

  def on_mlhs_add_post(*args); end

  def on_mlhs_add_star(*args); end

  def on_mlhs_new(*args); end

  def on_mlhs_paren(*args); end

  def on_module(*args); end

  def on_mrhs_add(*args); end

  def on_mrhs_add_star(*args); end

  def on_mrhs_new(*args); end

  def on_mrhs_new_from_args(*args); end

  def on_next(*args); end

  def on_nl(tok); end

  def on_nokw_param(*args); end

  def on_op(tok); end

  def on_opassign(*args); end

  def on_operator_ambiguous(*args); end

  def on_param_error(*args); end

  def on_params(*args); end

  def on_paren(*args); end

  def on_parse_error(*args); end

  def on_period(tok); end

  def on_program(*args); end

  def on_qsymbols_add(*args); end

  def on_qsymbols_beg(tok); end

  def on_qsymbols_new(*args); end

  def on_qwords_add(*args); end

  def on_qwords_beg(tok); end

  def on_qwords_new(*args); end

  def on_rational(tok); end

  def on_rbrace(tok); end

  def on_rbracket(tok); end

  def on_redo(*args); end

  def on_regexp_add(*args); end

  def on_regexp_beg(tok); end

  def on_regexp_end(tok); end

  def on_regexp_literal(*args); end

  def on_regexp_new(*args); end

  def on_rescue(*args); end

  def on_rescue_mod(*args); end

  def on_rest_param(*args); end

  def on_retry(*args); end

  def on_return(*args); end

  def on_return0(*args); end

  def on_rparen(tok); end

  def on_sclass(*args); end

  def on_semicolon(tok); end

  def on_sp(tok); end

  def on_stmts_add(*args); end

  def on_stmts_new(*args); end

  def on_string_add(*args); end

  def on_string_concat(*args); end

  def on_string_content(*args); end

  def on_string_dvar(*args); end

  def on_string_embexpr(*args); end

  def on_string_literal(*args); end

  def on_super(*args); end

  def on_symbeg(tok); end

  def on_symbol(*args); end

  def on_symbol_literal(*args); end

  def on_symbols_add(*args); end

  def on_symbols_beg(tok); end

  def on_symbols_new(*args); end

  def on_tlambda(tok); end

  def on_tlambeg(tok); end

  def on_top_const_field(*args); end

  def on_top_const_ref(*args); end

  def on_tstring_beg(tok); end

  def on_tstring_content(tok); end

  def on_tstring_end(tok); end

  def on_unary(*args); end

  def on_undef(*args); end

  def on_unless(*args); end

  def on_unless_mod(*args); end

  def on_until(*args); end

  def on_until_mod(*args); end

  def on_var_alias(*args); end

  def on_var_field(*args); end

  def on_var_ref(*args); end

  def on_vcall(*args); end

  def on_void_stmt(*args); end

  def on_when(*args); end

  def on_while(*args); end

  def on_while_mod(*args); end

  def on_word_add(*args); end

  def on_word_new(*args); end

  def on_words_add(*args); end

  def on_words_beg(tok); end

  def on_words_new(*args); end

  def on_words_sep(tok); end

  def on_xstring_add(*args); end

  def on_xstring_literal(*args); end

  def on_xstring_new(*args); end

  def on_yield(*args); end

  def on_yield0(*args); end

  def on_zsuper(*args); end
end

class Ripper::SexpBuilder
end

class Ripper::SexpBuilderPP
end

class Ripper::SexpBuilderPP
end

class Ripper::TokenPattern
  def initialize(pattern); end

  def match(str); end

  def match_list(tokens); end
  MAP = ::T.let(nil, ::T.untyped)
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::MatchData
  def initialize(tokens, match); end

  def string(n=T.unsafe(nil)); end
end

class Ripper::TokenPattern::MatchData
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern
  def self.compile(*_); end
end

class Ripper
  def self.dedent_string(_, _1); end

  def self.lex(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end

  def self.lex_state_name(_); end

  def self.parse(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end

  def self.token_match(src, pattern); end
end

class RipperTags::DataReader
  READ_MODE = ::T.let(nil, ::T.untyped)
end

class RipperTags::FileFinder
  DIR_CURRENT = ::T.let(nil, ::T.untyped)
  DIR_PARENT = ::T.let(nil, ::T.untyped)
  RUBY_EXT = ::T.let(nil, ::T.untyped)
end

module Roo
  CLASS_FOR_EXTENSION = ::T.let(nil, ::T.untyped)
  ROO_EXCELML_NOTICE = ::T.let(nil, ::T.untyped)
  ROO_EXCEL_NOTICE = ::T.let(nil, ::T.untyped)
  ROO_GOOGLE_NOTICE = ::T.let(nil, ::T.untyped)
  TEMP_PREFIX = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Roo::Base
  MAX_ROW_COL = ::T.let(nil, ::T.untyped)
  MIN_ROW_COL = ::T.let(nil, ::T.untyped)
end

class Roo::CSV
  TYPE_MAP = ::T.let(nil, ::T.untyped)
end

class Roo::Excelx
  ERROR_VALUES = ::T.let(nil, ::T.untyped)
end

class Roo::Excelx::Cell::DateTime
  DATE_FORMATS = ::T.let(nil, ::T.untyped)
  SECONDS_IN_DAY = ::T.let(nil, ::T.untyped)
  TIME_FORMATS = ::T.let(nil, ::T.untyped)
end

class Roo::Excelx::Extractor
  COMMON_STRINGS = ::T.let(nil, ::T.untyped)
end

module Roo::Excelx::Format
  EXCEPTIONAL_FORMATS = ::T.let(nil, ::T.untyped)
  STANDARD_FORMATS = ::T.let(nil, ::T.untyped)
end

Roo::LibreOffice = Roo::OpenOffice

class Roo::OpenOffice
  ERROR_MISSING_CONTENT_XML = ::T.let(nil, ::T.untyped)
  XPATH_FIND_TABLE_STYLES = ::T.let(nil, ::T.untyped)
  XPATH_LOCAL_NAME_TABLE = ::T.let(nil, ::T.untyped)
end

module Roo::Utils
  LETTERS = ::T.let(nil, ::T.untyped)
end

module RubyDep
  PROJECT_URL = ::T.let(nil, ::T.untyped)
end

class RubyDep::NullLogger
  LOG_LEVELS = ::T.let(nil, ::T.untyped)
end

class RubyDep::RubyVersion
  VERSION_INFO = ::T.let(nil, ::T.untyped)
end

class RubyDep::Warning
  DISABLING_ENVIRONMENT_VAR = ::T.let(nil, ::T.untyped)
  NOTICE_BUGGY_ALTERNATIVE = ::T.let(nil, ::T.untyped)
  NOTICE_HOW_TO_DISABLE = ::T.let(nil, ::T.untyped)
  NOTICE_OPEN_ISSUE = ::T.let(nil, ::T.untyped)
  NOTICE_RECOMMENDATION = ::T.let(nil, ::T.untyped)
  PREFIX = ::T.let(nil, ::T.untyped)
  WARNING = ::T.let(nil, ::T.untyped)
end

class RubyLex
  def check_code_block(code); end

  def check_corresponding_token_depth(); end

  def check_newline_depth_difference(); end

  def check_state(code); end

  def check_string_literal(); end

  def each_top_level_statement(); end

  def initialize_input(); end

  def lex(); end

  def process_continue(); end

  def process_literal_type(); end

  def process_nesting_level(); end

  def prompt(); end

  def ripper_lex_without_warning(code); end

  def set_auto_indent(context); end

  def set_input(io, p=T.unsafe(nil), &block); end

  def set_prompt(p=T.unsafe(nil), &block); end
end

class RubyLex::TerminateLineInput
  def initialize(); end
end

class RubyLex::TerminateLineInput
end

class RubyLex
end

module RubyVM::AbstractSyntaxTree
end

class RubyVM::AbstractSyntaxTree::Node
  def children(); end

  def first_column(); end

  def first_lineno(); end

  def last_column(); end

  def last_lineno(); end

  def pretty_print_children(q, names=T.unsafe(nil)); end

  def type(); end
end

class RubyVM::AbstractSyntaxTree::Node
end

module RubyVM::AbstractSyntaxTree
  def self.of(body); end

  def self.parse(string); end

  def self.parse_file(pathname); end
end

class RubyVM::InstructionSequence
  def absolute_path(); end

  def base_label(); end

  def disasm(); end

  def disassemble(); end

  def each_child(); end

  def eval(); end

  def first_lineno(); end

  def label(); end

  def path(); end

  def to_a(); end

  def to_binary(*_); end

  def trace_points(); end
end

class RubyVM::InstructionSequence
  extend ::Bootsnap::CompileCache::ISeq::InstructionSequenceMixin
  def self.compile(*_); end

  def self.compile_file(*_); end

  def self.compile_option(); end

  def self.compile_option=(compile_option); end

  def self.disasm(_); end

  def self.disassemble(_); end

  def self.load_from_binary(_); end

  def self.load_from_binary_extra_data(_); end

  def self.of(_); end
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  def self.enabled?(); end

  def self.pause(*_); end

  def self.resume(); end
end

class RubyVM
  def self.stat(*_); end
end

module SQLite3
  SQLITE_VERSION = ::T.let(nil, ::T.untyped)
  SQLITE_VERSION_NUMBER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class SQLite3::Blob
end

class SQLite3::Blob
end

module SQLite3::Constants::ColumnType
  BLOB = ::T.let(nil, ::T.untyped)
  FLOAT = ::T.let(nil, ::T.untyped)
  INTEGER = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
end

module SQLite3::Constants::ErrorCode
  ABORT = ::T.let(nil, ::T.untyped)
  AUTH = ::T.let(nil, ::T.untyped)
  BUSY = ::T.let(nil, ::T.untyped)
  CANTOPEN = ::T.let(nil, ::T.untyped)
  CONSTRAINT = ::T.let(nil, ::T.untyped)
  CORRUPT = ::T.let(nil, ::T.untyped)
  DONE = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ERROR = ::T.let(nil, ::T.untyped)
  FULL = ::T.let(nil, ::T.untyped)
  INTERNAL = ::T.let(nil, ::T.untyped)
  INTERRUPT = ::T.let(nil, ::T.untyped)
  IOERR = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MISMATCH = ::T.let(nil, ::T.untyped)
  MISUSE = ::T.let(nil, ::T.untyped)
  NOLFS = ::T.let(nil, ::T.untyped)
  NOMEM = ::T.let(nil, ::T.untyped)
  NOTFOUND = ::T.let(nil, ::T.untyped)
  OK = ::T.let(nil, ::T.untyped)
  PERM = ::T.let(nil, ::T.untyped)
  PROTOCOL = ::T.let(nil, ::T.untyped)
  READONLY = ::T.let(nil, ::T.untyped)
  ROW = ::T.let(nil, ::T.untyped)
  SCHEMA = ::T.let(nil, ::T.untyped)
  TOOBIG = ::T.let(nil, ::T.untyped)
end

module SQLite3::Constants::Open
  AUTOPROXY = ::T.let(nil, ::T.untyped)
  CREATE = ::T.let(nil, ::T.untyped)
  DELETEONCLOSE = ::T.let(nil, ::T.untyped)
  EXCLUSIVE = ::T.let(nil, ::T.untyped)
  FULLMUTEX = ::T.let(nil, ::T.untyped)
  MAIN_DB = ::T.let(nil, ::T.untyped)
  MAIN_JOURNAL = ::T.let(nil, ::T.untyped)
  MASTER_JOURNAL = ::T.let(nil, ::T.untyped)
  MEMORY = ::T.let(nil, ::T.untyped)
  NOMUTEX = ::T.let(nil, ::T.untyped)
  PRIVATECACHE = ::T.let(nil, ::T.untyped)
  READONLY = ::T.let(nil, ::T.untyped)
  READWRITE = ::T.let(nil, ::T.untyped)
  SHAREDCACHE = ::T.let(nil, ::T.untyped)
  SUBJOURNAL = ::T.let(nil, ::T.untyped)
  TEMP_DB = ::T.let(nil, ::T.untyped)
  TEMP_JOURNAL = ::T.let(nil, ::T.untyped)
  TRANSIENT_DB = ::T.let(nil, ::T.untyped)
  URI = ::T.let(nil, ::T.untyped)
  WAL = ::T.let(nil, ::T.untyped)
end

module SQLite3::Constants::Open
end

module SQLite3::Constants::TextRep
  ANY = ::T.let(nil, ::T.untyped)
  DETERMINISTIC = ::T.let(nil, ::T.untyped)
  UTF16 = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class SQLite3::Database
  NULL_TRANSLATOR = ::T.let(nil, ::T.untyped)
end

module SQLite3::Pragmas
  AUTO_VACUUM_MODES = ::T.let(nil, ::T.untyped)
  ENCODINGS = ::T.let(nil, ::T.untyped)
  JOURNAL_MODES = ::T.let(nil, ::T.untyped)
  LOCKING_MODES = ::T.let(nil, ::T.untyped)
  SYNCHRONOUS_MODES = ::T.let(nil, ::T.untyped)
  TEMP_STORE_MODES = ::T.let(nil, ::T.untyped)
  WAL_CHECKPOINTS = ::T.let(nil, ::T.untyped)
end

module SQLite3::VersionProxy
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sass
  ROOT_DIR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sass::Engine
  COMMENT_CHAR = ::T.let(nil, ::T.untyped)
  CONTENT_RE = ::T.let(nil, ::T.untyped)
  CSS_COMMENT_CHAR = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  DIRECTIVES = ::T.let(nil, ::T.untyped)
  DIRECTIVE_CHAR = ::T.let(nil, ::T.untyped)
  ESCAPE_CHAR = ::T.let(nil, ::T.untyped)
  FUNCTION_RE = ::T.let(nil, ::T.untyped)
  MIXIN_DEFINITION_CHAR = ::T.let(nil, ::T.untyped)
  MIXIN_DEF_RE = ::T.let(nil, ::T.untyped)
  MIXIN_INCLUDE_CHAR = ::T.let(nil, ::T.untyped)
  MIXIN_INCLUDE_RE = ::T.let(nil, ::T.untyped)
  PROPERTY_CHAR = ::T.let(nil, ::T.untyped)
  PROPERTY_OLD = ::T.let(nil, ::T.untyped)
  SASS_COMMENT_CHAR = ::T.let(nil, ::T.untyped)
  SASS_LOUD_COMMENT_CHAR = ::T.let(nil, ::T.untyped)
end

module Sass::Features
  KNOWN_FEATURES = ::T.let(nil, ::T.untyped)
end

class Sass::Importers::Filesystem
  REDUNDANT_DIRECTORY = ::T.let(nil, ::T.untyped)
end

module Sass::Rails
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sass::Rails::SassImporter::Globbing
  GLOB = ::T.let(nil, ::T.untyped)
end

class Sass::SCSS::Parser
  DIRECTIVES = ::T.let(nil, ::T.untyped)
  EXPR_NAMES = ::T.let(nil, ::T.untyped)
  NEWLINE = ::T.let(nil, ::T.untyped)
  PREFIXED_DIRECTIVES = ::T.let(nil, ::T.untyped)
  TOK_NAMES = ::T.let(nil, ::T.untyped)
end

module Sass::SCSS::RX
  ANY = ::T.let(nil, ::T.untyped)
  CDC = ::T.let(nil, ::T.untyped)
  CDO = ::T.let(nil, ::T.untyped)
  COMMENT = ::T.let(nil, ::T.untyped)
  DASHMATCH = ::T.let(nil, ::T.untyped)
  DOMAIN = ::T.let(nil, ::T.untyped)
  ESCAPE = ::T.let(nil, ::T.untyped)
  FUNCTION = ::T.let(nil, ::T.untyped)
  GREATER = ::T.let(nil, ::T.untyped)
  H = ::T.let(nil, ::T.untyped)
  HASH = ::T.let(nil, ::T.untyped)
  HEXCOLOR = ::T.let(nil, ::T.untyped)
  IDENT = ::T.let(nil, ::T.untyped)
  IDENT_HYPHEN_INTERP = ::T.let(nil, ::T.untyped)
  IDENT_START = ::T.let(nil, ::T.untyped)
  IMPORTANT = ::T.let(nil, ::T.untyped)
  INCLUDES = ::T.let(nil, ::T.untyped)
  INTERP_START = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  NL = ::T.let(nil, ::T.untyped)
  NMCHAR = ::T.let(nil, ::T.untyped)
  NMSTART = ::T.let(nil, ::T.untyped)
  NONASCII = ::T.let(nil, ::T.untyped)
  NOT = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  OPTIONAL = ::T.let(nil, ::T.untyped)
  PERCENTAGE = ::T.let(nil, ::T.untyped)
  PLUS = ::T.let(nil, ::T.untyped)
  PREFIXMATCH = ::T.let(nil, ::T.untyped)
  RANGE = ::T.let(nil, ::T.untyped)
  S = ::T.let(nil, ::T.untyped)
  SINGLE_LINE_COMMENT = ::T.let(nil, ::T.untyped)
  STATIC_COMPONENT = ::T.let(nil, ::T.untyped)
  STATIC_SELECTOR = ::T.let(nil, ::T.untyped)
  STATIC_VALUE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  STRING1 = ::T.let(nil, ::T.untyped)
  STRING1_NOINTERP = ::T.let(nil, ::T.untyped)
  STRING2 = ::T.let(nil, ::T.untyped)
  STRING2_NOINTERP = ::T.let(nil, ::T.untyped)
  STRING_NOINTERP = ::T.let(nil, ::T.untyped)
  SUBSTRINGMATCH = ::T.let(nil, ::T.untyped)
  SUFFIXMATCH = ::T.let(nil, ::T.untyped)
  TILDE = ::T.let(nil, ::T.untyped)
  UNICODE = ::T.let(nil, ::T.untyped)
  UNICODERANGE = ::T.let(nil, ::T.untyped)
  UNIT = ::T.let(nil, ::T.untyped)
  UNITLESS_NUMBER = ::T.let(nil, ::T.untyped)
  URI = ::T.let(nil, ::T.untyped)
  URL = ::T.let(nil, ::T.untyped)
  URLCHAR = ::T.let(nil, ::T.untyped)
  URL_PREFIX = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
  W = ::T.let(nil, ::T.untyped)
end

class Sass::SCSS::StaticParser
  PREFIXED_SELECTOR_PSEUDO_CLASSES = ::T.let(nil, ::T.untyped)
  SELECTOR_PSEUDO_CLASSES = ::T.let(nil, ::T.untyped)
  SELECTOR_PSEUDO_ELEMENTS = ::T.let(nil, ::T.untyped)
end

module Sass::Script
  CONST_RENAMES = ::T.let(nil, ::T.untyped)
  MATCH = ::T.let(nil, ::T.untyped)
  VALIDATE = ::T.let(nil, ::T.untyped)
end

class Sass::Script::Functions::EvaluationContext
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

class Sass::Script::Lexer
  IDENT_OP_NAMES = ::T.let(nil, ::T.untyped)
  OPERATORS = ::T.let(nil, ::T.untyped)
  OPERATORS_REVERSE = ::T.let(nil, ::T.untyped)
  OP_NAMES = ::T.let(nil, ::T.untyped)
  PARSEABLE_NUMBER = ::T.let(nil, ::T.untyped)
  REGULAR_EXPRESSIONS = ::T.let(nil, ::T.untyped)
  STRING_REGULAR_EXPRESSIONS = ::T.let(nil, ::T.untyped)
  TOKEN_NAMES = ::T.let(nil, ::T.untyped)
end

class Sass::Script::Parser
  ASSOCIATIVE = ::T.let(nil, ::T.untyped)
  EXPR_NAMES = ::T.let(nil, ::T.untyped)
  PRECEDENCE = ::T.let(nil, ::T.untyped)
end

class Sass::Script::Value::Bool
  FALSE = ::T.let(nil, ::T.untyped)
  TRUE = ::T.let(nil, ::T.untyped)
end

class Sass::Script::Value::Color
  ALTERNATE_COLOR_NAMES = ::T.let(nil, ::T.untyped)
  COLOR_NAMES = ::T.let(nil, ::T.untyped)
  COLOR_NAMES_REVERSE = ::T.let(nil, ::T.untyped)
end

module Sass::Script::Value::Helpers
  VALID_UNIT = ::T.let(nil, ::T.untyped)
end

class Sass::Script::Value::Null
  NULL = ::T.let(nil, ::T.untyped)
end

class Sass::Script::Value::Number
  CONVERSION_TABLE = ::T.let(nil, ::T.untyped)
  MUTUALLY_CONVERTIBLE = ::T.let(nil, ::T.untyped)
  NO_UNITS = ::T.let(nil, ::T.untyped)
  OPERATIONS = ::T.let(nil, ::T.untyped)
end

module Sass::Selector
  SPECIFICITY_BASE = ::T.let(nil, ::T.untyped)
end

class Sass::Selector::Pseudo
  ACTUALLY_ELEMENTS = ::T.let(nil, ::T.untyped)
end

class Sass::Tree::RuleNode
  PARENT = ::T.let(nil, ::T.untyped)
end

class Sass::Tree::Visitors::CheckNesting
  CONTROL_NODES = ::T.let(nil, ::T.untyped)
  INVALID_IMPORT_PARENTS = ::T.let(nil, ::T.untyped)
  SCRIPT_NODES = ::T.let(nil, ::T.untyped)
  VALID_EXTEND_PARENTS = ::T.let(nil, ::T.untyped)
  VALID_FUNCTION_CHILDREN = ::T.let(nil, ::T.untyped)
  VALID_PROP_CHILDREN = ::T.let(nil, ::T.untyped)
  VALID_PROP_PARENTS = ::T.let(nil, ::T.untyped)
end

class Sass::Tree::Visitors::ToCss
  NEWLINE = ::T.let(nil, ::T.untyped)
end

module Sass::Util
  ATOMIC_WRITE_MUTEX = ::T.let(nil, ::T.untyped)
  BASE64_DIGITS = ::T.let(nil, ::T.untyped)
  BASE64_DIGIT_MAP = ::T.let(nil, ::T.untyped)
  CHARSET_REGEXP = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_VERSION_COMPONENTS = ::T.let(nil, ::T.untyped)
  UTF_16BE_BOM = ::T.let(nil, ::T.untyped)
  UTF_16LE_BOM = ::T.let(nil, ::T.untyped)
  UTF_8_BOM = ::T.let(nil, ::T.untyped)
  VLQ_BASE = ::T.let(nil, ::T.untyped)
  VLQ_BASE_MASK = ::T.let(nil, ::T.untyped)
  VLQ_BASE_SHIFT = ::T.let(nil, ::T.untyped)
  VLQ_CONTINUATION_BIT = ::T.let(nil, ::T.untyped)
end

ScanError = StringScanner::Error

module SecureRandom
  BASE36_ALPHABET = ::T.let(nil, ::T.untyped)
  BASE58_ALPHABET = ::T.let(nil, ::T.untyped)
end

module SecureRandom
  def self.bytes(n); end
end

module Selenium::WebDriver
  VERSION = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Chrome::Bridge
  COMMANDS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Chrome::Options
  KEY = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::DriverExtensions::Rotatable
  ORIENTATIONS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Edge
end

module Selenium::WebDriver::Edge::Bridge
  def commands(command); end

  def maximize_window(handle=T.unsafe(nil)); end

  def reposition_window(x, y, handle=T.unsafe(nil)); end

  def resize_window(width, height, handle=T.unsafe(nil)); end

  def send_keys_to_active_element(key); end

  def window_handle(); end

  def window_position(handle=T.unsafe(nil)); end

  def window_size(handle=T.unsafe(nil)); end
end

module Selenium::WebDriver::Edge::Bridge
end

class Selenium::WebDriver::Edge::Driver
  include ::Selenium::WebDriver::DriverExtensions::TakesScreenshot
  def initialize(opts=T.unsafe(nil)); end
end

class Selenium::WebDriver::Edge::Driver
end

class Selenium::WebDriver::Edge::Options
  def add_extension_path(path); end

  def as_json(*_); end

  def extension_paths(); end

  def in_private(); end

  def in_private=(in_private); end

  def initialize(**opts); end

  def start_page(); end

  def start_page=(start_page); end
end

class Selenium::WebDriver::Edge::Options
end

class Selenium::WebDriver::Edge::Service
end

class Selenium::WebDriver::Edge::Service
end

module Selenium::WebDriver::Edge
  def self.driver_path(); end

  def self.driver_path=(path); end
end

module Selenium::WebDriver::Error
  DEPRECATED_ERRORS = ::T.let(nil, ::T.untyped)
  ERRORS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Error::ServerError
  def initialize(response); end
end

class Selenium::WebDriver::Error::ServerError
end

module Selenium::WebDriver::Firefox
  DEFAULT_ASSUME_UNTRUSTED_ISSUER = ::T.let(nil, ::T.untyped)
  DEFAULT_ENABLE_NATIVE_EVENTS = ::T.let(nil, ::T.untyped)
  DEFAULT_LOAD_NO_FOCUS_LIB = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  DEFAULT_SECURE_SSL = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Binary
  NO_FOCUS_LIBRARIES = ::T.let(nil, ::T.untyped)
  NO_FOCUS_LIBRARY_NAME = ::T.let(nil, ::T.untyped)
  QUIT_TIMEOUT = ::T.let(nil, ::T.untyped)
  WAIT_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Extension
  NAMESPACE = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Launcher
  SOCKET_LOCK_TIMEOUT = ::T.let(nil, ::T.untyped)
  STABLE_CONNECTION_TIMEOUT = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Firefox::Marionette::Bridge
  COMMANDS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Options
  KEY = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Profile
  VALID_PREFERENCE_TYPES = ::T.let(nil, ::T.untyped)
  WEBDRIVER_EXTENSION_PATH = ::T.let(nil, ::T.untyped)
  WEBDRIVER_PREFS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::HTML5::SharedWebStorage
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Selenium::WebDriver::IE::Options
  CAPABILITIES = ::T.let(nil, ::T.untyped)
  KEY = ::T.let(nil, ::T.untyped)
  SCROLL_BOTTOM = ::T.let(nil, ::T.untyped)
  SCROLL_TOP = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Interactions
  KEY = ::T.let(nil, ::T.untyped)
  NONE = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  SOURCE_TYPES = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::Interaction
  PAUSE = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::KeyInput
  SUBTYPES = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::PointerInput
  KIND = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::PointerMove
  ORIGINS = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  VIEWPORT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::PointerPress
  BUTTONS = ::T.let(nil, ::T.untyped)
  DIRECTIONS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Keyboard
  MODIFIERS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Keys
  KEYS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Manager
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::PortProber
  IGNORED_ERRORS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Proxy
  ALLOWED = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Remote
end

class Selenium::WebDriver::Remote::Bridge
  include ::Selenium::WebDriver::Atoms
  include ::Selenium::WebDriver::BridgeHelper
  def browser(); end

  def capabilities(); end

  def context(); end

  def context=(context); end

  def create_session(desired_capabilities, options=T.unsafe(nil)); end

  def dialect(); end

  def file_detector(); end

  def file_detector=(file_detector); end

  def http(); end

  def http=(http); end

  def initialize(opts=T.unsafe(nil)); end

  def session_id(); end
  COMMANDS = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::Bridge
  def self.handshake(**opts); end
end

class Selenium::WebDriver::Remote::Capabilities
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def as_json(*_); end

  def browser_name(); end

  def browser_name=(value); end

  def capabilities(); end

  def css_selectors_enabled(); end

  def css_selectors_enabled=(value); end

  def css_selectors_enabled?(); end

  def eql?(other); end

  def firefox_profile(); end

  def firefox_profile=(value); end

  def initialize(opts=T.unsafe(nil)); end

  def javascript_enabled(); end

  def javascript_enabled=(value); end

  def javascript_enabled?(); end

  def merge!(other); end

  def native_events(); end

  def native_events=(value); end

  def native_events?(); end

  def platform(); end

  def platform=(value); end

  def proxy(); end

  def proxy=(proxy); end

  def rotatable(); end

  def rotatable=(value); end

  def rotatable?(); end

  def takes_screenshot(); end

  def takes_screenshot=(value); end

  def takes_screenshot?(); end

  def to_json(*_); end

  def version(); end

  def version=(value); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::Capabilities
  def self.chrome(opts=T.unsafe(nil)); end

  def self.edge(opts=T.unsafe(nil)); end

  def self.firefox(opts=T.unsafe(nil)); end

  def self.firefox_legacy(opts=T.unsafe(nil)); end

  def self.htmlunit(opts=T.unsafe(nil)); end

  def self.htmlunitwithjs(opts=T.unsafe(nil)); end

  def self.ie(opts=T.unsafe(nil)); end

  def self.internet_explorer(opts=T.unsafe(nil)); end

  def self.json_create(data); end

  def self.phantomjs(opts=T.unsafe(nil)); end

  def self.safari(opts=T.unsafe(nil)); end
end

class Selenium::WebDriver::Remote::Driver
  include ::Selenium::WebDriver::DriverExtensions::UploadsFiles
  include ::Selenium::WebDriver::DriverExtensions::TakesScreenshot
  include ::Selenium::WebDriver::DriverExtensions::HasSessionId
  include ::Selenium::WebDriver::DriverExtensions::Rotatable
  include ::Selenium::WebDriver::DriverExtensions::HasRemoteStatus
  include ::Selenium::WebDriver::DriverExtensions::HasWebStorage
  def initialize(opts=T.unsafe(nil)); end
end

class Selenium::WebDriver::Remote::Driver
end

module Selenium::WebDriver::Remote::Http
end

class Selenium::WebDriver::Remote::Http::Common
  def call(verb, url, command_hash); end

  def close(); end

  def quit_errors(); end

  def server_url=(server_url); end

  def timeout(); end

  def timeout=(timeout); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  DEFAULT_HEADERS = ::T.let(nil, ::T.untyped)
  MAX_REDIRECTS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::Http::Common
end

class Selenium::WebDriver::Remote::Http::Default
  def initialize(open_timeout: T.unsafe(nil), read_timeout: T.unsafe(nil)); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def proxy=(proxy); end

  def read_timeout(); end

  def read_timeout=(read_timeout); end

  def timeout=(value); end
  MAX_RETRIES = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::Http::Default
end

module Selenium::WebDriver::Remote::Http
end

module Selenium::WebDriver::Remote::OSS
end

class Selenium::WebDriver::Remote::OSS::Bridge
  def accept_alert(); end

  def action(); end

  def active_element(); end

  def add_cookie(cookie); end

  def alert=(keys); end

  def alert_text(); end

  def authentication(credentials); end

  def available_log_types(); end

  def clear_element(element); end

  def clear_local_storage(); end

  def clear_session_storage(); end

  def click(); end

  def click_element(element); end

  def close(); end

  def context_click(); end

  def cookies(); end

  def delete_all_cookies(); end

  def delete_cookie(name); end

  def dismiss_alert(); end

  def double_click(); end

  def drag_element(element, right_by, down_by); end

  def element_attribute(element, name); end

  def element_displayed?(element); end

  def element_enabled?(element); end

  def element_location(element); end

  def element_location_once_scrolled_into_view(element); end

  def element_property(element, name); end

  def element_rect(element); end

  def element_selected?(element); end

  def element_size(element); end

  def element_tag_name(element); end

  def element_text(element); end

  def element_value(element); end

  def element_value_of_css_property(element, prop); end

  def execute_async_script(script, *args); end

  def execute_script(script, *args); end

  def find_element_by(how, what, parent=T.unsafe(nil)); end

  def find_elements_by(how, what, parent=T.unsafe(nil)); end

  def get(url); end

  def go_back(); end

  def go_forward(); end

  def implicit_wait_timeout=(milliseconds); end

  def initialize(capabilities, session_id, **opts); end

  def keyboard(); end

  def local_storage_item(key, value=T.unsafe(nil)); end

  def local_storage_keys(); end

  def local_storage_size(); end

  def location(); end

  def log(type); end

  def manage(); end

  def maximize_window(handle=T.unsafe(nil)); end

  def mouse(); end

  def mouse_down(); end

  def mouse_move_to(element, x=T.unsafe(nil), y=T.unsafe(nil)); end

  def mouse_up(); end

  def network_connection(); end

  def network_connection=(type); end

  def page_source(); end

  def quit(); end

  def refresh(); end

  def remove_local_storage_item(key); end

  def remove_session_storage_item(key); end

  def reposition_window(x, y, handle=T.unsafe(nil)); end

  def resize_window(width, height, handle=T.unsafe(nil)); end

  def screen_orientation(); end

  def screen_orientation=(orientation); end

  def screenshot(); end

  def script_timeout=(milliseconds); end

  def send_keys_to_active_element(key); end

  def send_keys_to_element(element, keys); end

  def session_capabilities(); end

  def session_storage_item(key, value=T.unsafe(nil)); end

  def session_storage_keys(); end

  def session_storage_size(); end

  def set_location(lat, lon, alt); end

  def status(); end

  def submit_element(element); end

  def switch_to_active_element(); end

  def switch_to_default_content(); end

  def switch_to_frame(id); end

  def switch_to_parent_frame(); end

  def switch_to_window(name); end

  def timeout(type, milliseconds); end

  def title(); end

  def touch_double_tap(element); end

  def touch_down(x, y); end

  def touch_element_flick(element, right_by, down_by, speed); end

  def touch_flick(xspeed, yspeed); end

  def touch_long_press(element); end

  def touch_move(x, y); end

  def touch_scroll(element, x, y); end

  def touch_single_tap(element); end

  def touch_up(x, y); end

  def upload(local_file); end

  def url(); end

  def window_handle(); end

  def window_handles(); end

  def window_position(handle=T.unsafe(nil)); end

  def window_size(handle=T.unsafe(nil)); end
  COMMANDS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::OSS::Bridge
end

module Selenium::WebDriver::Remote::OSS
end

class Selenium::WebDriver::Remote::Response
  def [](key); end

  def code(); end

  def error(); end

  def error_message(); end

  def initialize(code, payload=T.unsafe(nil)); end

  def payload(); end

  def payload=(payload); end
  STACKTRACE_KEY = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::Response
end

module Selenium::WebDriver::Remote::W3C
end

class Selenium::WebDriver::Remote::W3C::Bridge
  def accept_alert(); end

  def action(async=T.unsafe(nil)); end

  def actions(async=T.unsafe(nil)); end

  def active_element(); end

  def add_cookie(cookie); end

  def alert=(keys); end

  def alert_text(); end

  def clear_element(element); end

  def clear_local_storage(); end

  def clear_session_storage(); end

  def click_element(element); end

  def close(); end

  def cookie(name); end

  def cookies(); end

  def delete_all_cookies(); end

  def delete_cookie(name); end

  def dismiss_alert(); end

  def drag_element(element, right_by, down_by); end

  def element_attribute(element, name); end

  def element_displayed?(element); end

  def element_enabled?(element); end

  def element_location(element); end

  def element_location_once_scrolled_into_view(element); end

  def element_property(element, name); end

  def element_rect(element); end

  def element_selected?(element); end

  def element_size(element); end

  def element_tag_name(element); end

  def element_text(element); end

  def element_value(element); end

  def element_value_of_css_property(element, prop); end

  def execute_async_script(script, *args); end

  def execute_script(script, *args); end

  def find_element_by(how, what, parent=T.unsafe(nil)); end

  def find_elements_by(how, what, parent=T.unsafe(nil)); end

  def full_screen_window(); end

  def get(url); end

  def go_back(); end

  def go_forward(); end

  def implicit_wait_timeout=(milliseconds); end

  def initialize(capabilities, session_id, **opts); end

  def keyboard(); end

  def local_storage_item(key, value=T.unsafe(nil)); end

  def local_storage_keys(); end

  def local_storage_size(); end

  def location(); end

  def manage(); end

  def maximize_window(handle=T.unsafe(nil)); end

  def minimize_window(); end

  def mouse(); end

  def network_connection(); end

  def network_connection=(_type); end

  def new_window(type); end

  def page_source(); end

  def quit(); end

  def refresh(); end

  def release_actions(); end

  def remove_local_storage_item(key); end

  def remove_session_storage_item(key); end

  def reposition_window(x, y); end

  def resize_window(width, height, handle=T.unsafe(nil)); end

  def screen_orientation(); end

  def screen_orientation=(orientation); end

  def screenshot(); end

  def script_timeout=(milliseconds); end

  def send_actions(data); end

  def send_keys_to_element(element, keys); end

  def session_storage_item(key, value=T.unsafe(nil)); end

  def session_storage_keys(); end

  def session_storage_size(); end

  def set_location(_lat, _lon, _alt); end

  def set_window_rect(x: T.unsafe(nil), y: T.unsafe(nil), width: T.unsafe(nil), height: T.unsafe(nil)); end

  def status(); end

  def submit_element(element); end

  def switch_to_active_element(); end

  def switch_to_default_content(); end

  def switch_to_frame(id); end

  def switch_to_parent_frame(); end

  def switch_to_window(name); end

  def timeout(type, milliseconds); end

  def title(); end

  def touch_double_tap(element); end

  def touch_down(x, y); end

  def touch_element_flick(element, right_by, down_by, speed); end

  def touch_flick(xspeed, yspeed); end

  def touch_long_press(element); end

  def touch_move(x, y); end

  def touch_scroll(element, x, y); end

  def touch_single_tap(element); end

  def touch_up(x, y); end

  def upload(local_file); end

  def url(); end

  def window_handle(); end

  def window_handles(); end

  def window_position(); end

  def window_rect(); end

  def window_size(handle=T.unsafe(nil)); end
  COMMANDS = ::T.let(nil, ::T.untyped)
  ESCAPE_CSS_REGEXP = ::T.let(nil, ::T.untyped)
  QUIT_ERRORS = ::T.let(nil, ::T.untyped)
  UNICODE_CODE_POINT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::W3C::Bridge
end

class Selenium::WebDriver::Remote::W3C::Capabilities
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def accept_insecure_certs(); end

  def accept_insecure_certs=(value); end

  def accessibility_checks(); end

  def accessibility_checks=(value); end

  def as_json(*_); end

  def browser_name(); end

  def browser_name=(value); end

  def browser_version(); end

  def browser_version=(value); end

  def capabilities(); end

  def device(); end

  def device=(value); end

  def eql?(other); end

  def implicit_timeout(); end

  def implicit_timeout=(value); end

  def initialize(opts=T.unsafe(nil)); end

  def merge!(other); end

  def page_load_strategy(); end

  def page_load_strategy=(value); end

  def page_load_timeout(); end

  def page_load_timeout=(value); end

  def platform(); end

  def platform=(value); end

  def platform_name(); end

  def platform_name=(value); end

  def proxy(); end

  def proxy=(proxy); end

  def remote_session_id(); end

  def remote_session_id=(value); end

  def script_timeout(); end

  def script_timeout=(value); end

  def set_window_rect(); end

  def set_window_rect=(value); end

  def strict_file_interactability(); end

  def strict_file_interactability=(value); end

  def timeouts(); end

  def timeouts=(value); end

  def to_json(*_); end

  def unhandled_prompt_behavior(); end

  def unhandled_prompt_behavior=(value); end

  def version(); end

  def version=(value); end
  EXTENSION_CAPABILITY_PATTERN = ::T.let(nil, ::T.untyped)
  KNOWN = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::W3C::Capabilities
  def self.edge(opts=T.unsafe(nil)); end

  def self.ff(opts=T.unsafe(nil)); end

  def self.firefox(opts=T.unsafe(nil)); end

  def self.from_oss(oss_capabilities); end

  def self.json_create(data); end
end

module Selenium::WebDriver::Remote::W3C
end

module Selenium::WebDriver::Remote
end

module Selenium::WebDriver::Safari
end

module Selenium::WebDriver::Safari::Bridge
  def attach_debugger(); end

  def commands(command); end

  def permissions(); end

  def permissions=(permissions); end
  COMMANDS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Safari::Bridge
end

class Selenium::WebDriver::Safari::Driver
  include ::Selenium::WebDriver::DriverExtensions::HasDebugger
  include ::Selenium::WebDriver::DriverExtensions::HasPermissions
  include ::Selenium::WebDriver::DriverExtensions::TakesScreenshot
  def initialize(opts=T.unsafe(nil)); end
end

class Selenium::WebDriver::Safari::Driver
end

class Selenium::WebDriver::Safari::Options
  def as_json(*_); end

  def automatic_inspection(); end

  def automatic_inspection=(automatic_inspection); end

  def automatic_profiling(); end

  def automatic_profiling=(automatic_profiling); end

  def initialize(**opts); end
end

class Selenium::WebDriver::Safari::Options
end

class Selenium::WebDriver::Safari::Service
end

class Selenium::WebDriver::Safari::Service
end

module Selenium::WebDriver::Safari
  def self.driver_path(); end

  def self.driver_path=(path); end

  def self.path(); end

  def self.path=(path); end

  def self.technology_preview(); end

  def self.technology_preview!(); end
end

module Selenium::WebDriver::SearchContext
  FINDERS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Service
  SOCKET_LOCK_TIMEOUT = ::T.let(nil, ::T.untyped)
  START_TIMEOUT = ::T.let(nil, ::T.untyped)
  STOP_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::SocketPoller
  CONNECTED_ERRORS = ::T.let(nil, ::T.untyped)
  CONNECT_TIMEOUT = ::T.let(nil, ::T.untyped)
  NOT_CONNECTED_ERRORS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Support
end

class Selenium::WebDriver::Support::AbstractEventListener
  def after_change_value_of(element, driver); end

  def after_click(element, driver); end

  def after_close(driver); end

  def after_execute_script(script, driver); end

  def after_find(by, what, driver); end

  def after_navigate_back(driver); end

  def after_navigate_forward(driver); end

  def after_navigate_to(url, driver); end

  def after_quit(driver); end

  def before_change_value_of(element, driver); end

  def before_click(element, driver); end

  def before_close(driver); end

  def before_execute_script(script, driver); end

  def before_find(by, what, driver); end

  def before_navigate_back(driver); end

  def before_navigate_forward(driver); end

  def before_navigate_to(url, driver); end

  def before_quit(driver); end
end

class Selenium::WebDriver::Support::AbstractEventListener
end

class Selenium::WebDriver::Support::BlockEventListener
  def initialize(callback); end

  def method_missing(meth, *args); end
end

class Selenium::WebDriver::Support::BlockEventListener
end

class Selenium::WebDriver::Support::Color
  def ==(other); end

  def alpha(); end

  def blue(); end

  def eql?(other); end

  def green(); end

  def hex(); end

  def initialize(red, green, blue, alpha=T.unsafe(nil)); end

  def red(); end

  def rgb(); end

  def rgba(); end
  HEX3_PATTERN = ::T.let(nil, ::T.untyped)
  HEX_PATTERN = ::T.let(nil, ::T.untyped)
  HSLA_PATTERN = ::T.let(nil, ::T.untyped)
  HSL_PATTERN = ::T.let(nil, ::T.untyped)
  RGBA_PATTERN = ::T.let(nil, ::T.untyped)
  RGBA_PCT_PATTERN = ::T.let(nil, ::T.untyped)
  RGB_PATTERN = ::T.let(nil, ::T.untyped)
  RGB_PCT_PATTERN = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Support::Color
  def self.from_hsl(h, s, l, a); end

  def self.from_string(str); end

  def self.hue_to_rgb(lum1, lum2, hue); end
end

module Selenium::WebDriver::Support::Escaper
end

module Selenium::WebDriver::Support::Escaper
  def self.escape(str); end
end

class Selenium::WebDriver::Support::EventFiringBridge
  def clear_element(ref); end

  def click_element(ref); end

  def close(); end

  def execute_script(script, *args); end

  def find_element_by(how, what, parent=T.unsafe(nil)); end

  def find_elements_by(how, what, parent=T.unsafe(nil)); end

  def get(url); end

  def go_back(); end

  def go_forward(); end

  def initialize(delegate, listener); end

  def quit(); end

  def send_keys_to_element(ref, keys); end
end

class Selenium::WebDriver::Support::EventFiringBridge
end

class Selenium::WebDriver::Support::Select
  def deselect_all(); end

  def deselect_by(how, what); end

  def first_selected_option(); end

  def initialize(element); end

  def multiple?(); end

  def options(); end

  def select_all(); end

  def select_by(how, what); end

  def selected_options(); end
end

class Selenium::WebDriver::Support::Select
end

module Selenium::WebDriver::Support
end

class Selenium::WebDriver::TouchScreen
  FLICK_SPEED = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Wait
  DEFAULT_INTERVAL = ::T.let(nil, ::T.untyped)
  DEFAULT_TIMEOUT = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Zipper
  EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class Set
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

module Shellwords
end

module Shellwords
  def self.escape(str); end

  def self.join(array); end

  def self.shellescape(str); end

  def self.shelljoin(array); end

  def self.shellsplit(line); end

  def self.shellwords(line); end

  def self.split(line); end
end

class SignalException
  def signm(); end

  def signo(); end
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module SingleForwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_single_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_single_delegators(accessor, *methods); end

  def delegate(hash); end

  def single_delegate(hash); end
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

module Skiptrace
  VERSION = ::T.let(nil, ::T.untyped)
end

module SmarterCSV
  VERSION = ::T.let(nil, ::T.untyped)
end

class Socket
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Solargraph
  VERSION = ::T.let(nil, ::T.untyped)
  VIEWS_PATH = ::T.let(nil, ::T.untyped)
  YARDOC_PATH = ::T.let(nil, ::T.untyped)
  YARD_EXTENSION_FILE = ::T.let(nil, ::T.untyped)
end

class Solargraph::ApiMap
  include ::Solargraph::ApiMap::SourceToYard
  include ::Solargraph::ApiMap::BundlerMethods
  def bundled?(filename); end

  def catalog(bundle); end

  def clip(cursor); end

  def clip_at(filename, position); end

  def cursor_at(filename, position); end

  def document(path); end

  def document_symbols(filename); end

  def get_class_variable_pins(namespace); end

  def get_complex_type_methods(type, context=T.unsafe(nil), internal=T.unsafe(nil)); end

  def get_constants(namespace, *contexts); end

  def get_global_variable_pins(); end

  def get_instance_variable_pins(namespace, scope=T.unsafe(nil)); end

  def get_method_stack(fqns, name, scope: T.unsafe(nil)); end

  def get_methods(fqns, scope: T.unsafe(nil), visibility: T.unsafe(nil), deep: T.unsafe(nil)); end

  def get_path_pins(path); end

  def get_path_suggestions(path); end

  def get_symbols(); end

  def implicit(); end

  def index(pins); end

  def initialize(pins: T.unsafe(nil)); end

  def local_path_hash(); end

  def locate_pins(location); end

  def map(source); end

  def named_macro(name); end

  def namespace_exists?(name, context=T.unsafe(nil)); end

  def namespaces(); end

  def pins(); end

  def qualify(namespace, context=T.unsafe(nil)); end

  def query_symbols(query); end

  def require_reference_at(location); end

  def search(query); end

  def source_map(filename); end

  def source_maps(); end

  def super_and_sub?(sup, sub); end

  def unresolved_requires(); end

  def workspaced?(filename); end
end

module Solargraph::ApiMap::BundlerMethods
end

module Solargraph::ApiMap::BundlerMethods
  def self.require_from_bundle(directory); end

  def self.reset_require_from_bundle(); end
end

class Solargraph::ApiMap::Cache
  def clear(); end

  def empty?(); end

  def get_constants(namespace, context); end

  def get_methods(fqns, scope, visibility, deep); end

  def get_qualified_namespace(name, context); end

  def get_receiver_definition(path); end

  def receiver_defined?(path); end

  def set_constants(namespace, context, value); end

  def set_methods(fqns, scope, visibility, deep, value); end

  def set_qualified_namespace(name, context, value); end

  def set_receiver_definition(path, pin); end
end

class Solargraph::ApiMap::Cache
end

module Solargraph::ApiMap::SourceToYard
  def code_object_at(path); end

  def code_object_paths(); end

  def rake_yard(store); end
end

module Solargraph::ApiMap::SourceToYard
end

class Solargraph::ApiMap::Store
  def block_pins(); end

  def domains(fqns); end

  def get_class_variables(fqns); end

  def get_constants(fqns, visibility=T.unsafe(nil)); end

  def get_extends(fqns); end

  def get_includes(fqns); end

  def get_instance_variables(fqns, scope=T.unsafe(nil)); end

  def get_methods(fqns, scope: T.unsafe(nil), visibility: T.unsafe(nil)); end

  def get_path_pins(path); end

  def get_superclass(fqns); end

  def get_symbols(); end

  def initialize(pins=T.unsafe(nil)); end

  def method_pins(); end

  def named_macros(); end

  def namespace_exists?(fqns); end

  def namespace_pins(); end

  def namespaces(); end

  def pins(); end
end

class Solargraph::ApiMap::Store
end

class Solargraph::ApiMap
  def self.keywords(); end

  def self.load(directory); end
end

class Solargraph::Bundle
  def initialize(workspace: T.unsafe(nil), opened: T.unsafe(nil)); end

  def opened(); end

  def sources(); end

  def workspace(); end
end

class Solargraph::Bundle
end

class Solargraph::ComplexType
  def [](index); end

  def all?(&block); end

  def each(&block); end

  def first(); end

  def initialize(types=T.unsafe(nil)); end

  def length(); end

  def map(&block); end

  def method_missing(name, *args, &block); end

  def qualify(api_map, context=T.unsafe(nil)); end

  def select(&block); end

  def self_to(dst); end

  def selfy?(); end
  BOOLEAN = ::T.let(nil, ::T.untyped)
  NIL = ::T.let(nil, ::T.untyped)
  ROOT = ::T.let(nil, ::T.untyped)
  SELF = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
  UNDEFINED = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
end

module Solargraph::ComplexType::TypeMethods
  def ==(other); end

  def defined?(); end

  def duck_type?(); end

  def fixed_parameters?(); end

  def hash_parameters?(); end

  def key_types(); end

  def list_parameters?(); end

  def name(); end

  def namespace(); end

  def nil_type?(); end

  def parameters?(); end

  def qualify(api_map, context=T.unsafe(nil)); end

  def rooted?(); end

  def scope(); end

  def substring(); end

  def subtypes(); end

  def tag(); end

  def undefined?(); end

  def value_types(); end

  def void?(); end
end

module Solargraph::ComplexType::TypeMethods
end

class Solargraph::ComplexType::UniqueType
  include ::Solargraph::ComplexType::TypeMethods
  def initialize(name, substring=T.unsafe(nil)); end

  def self_to(dst); end

  def selfy?(); end
  BOOLEAN = ::T.let(nil, ::T.untyped)
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

class Solargraph::ComplexType::UniqueType
end

class Solargraph::ComplexType
  def self.parse(*strings, partial: T.unsafe(nil)); end

  def self.try_parse(*strings); end
end

module Solargraph::Convention
end

class Solargraph::Convention::Base
  def environ(); end

  def match?(source); end

  def process(); end
  EMPTY_ENVIRON = ::T.let(nil, ::T.untyped)
end

class Solargraph::Convention::Base
end

class Solargraph::Convention::Gemfile
end

class Solargraph::Convention::Gemfile
end

class Solargraph::Convention::Gemspec
end

class Solargraph::Convention::Gemspec
end

class Solargraph::Convention::Rspec
end

class Solargraph::Convention::Rspec
end

module Solargraph::Convention
  def self.for(source); end

  def self.register(convention); end
end

module Solargraph::CoreFills
  KEYWORDS = ::T.let(nil, ::T.untyped)
  OVERRIDES = ::T.let(nil, ::T.untyped)
end

class Solargraph::CoreFills::Override
  def delete(); end

  def initialize(location, name, tags, delete=T.unsafe(nil)); end

  def tags(); end
end

class Solargraph::CoreFills::Override
  def self.from_comment(name, comment); end

  def self.method_return(name, *tags, delete: T.unsafe(nil)); end
end

module Solargraph::CoreFills
end

module Solargraph::Diagnostics
end

class Solargraph::Diagnostics::Base
  def args(); end

  def diagnose(source, api_map); end

  def initialize(*args); end
end

class Solargraph::Diagnostics::Base
end

class Solargraph::Diagnostics::RequireNotFound
end

class Solargraph::Diagnostics::RequireNotFound
end

class Solargraph::Diagnostics::Rubocop
  include ::Solargraph::Diagnostics::RubocopHelpers
  def diagnose(source, _api_map); end
  SEVERITIES = ::T.let(nil, ::T.untyped)
end

class Solargraph::Diagnostics::Rubocop
end

module Solargraph::Diagnostics::RubocopHelpers
end

module Solargraph::Diagnostics::RubocopHelpers
  def self.find_rubocop_file(filename); end

  def self.fix_drive_letter(path); end

  def self.generate_options(filename, code); end

  def self.redirect_stdout(); end
end

module Solargraph::Diagnostics::Severities
  ERROR = ::T.let(nil, ::T.untyped)
  HINT = ::T.let(nil, ::T.untyped)
  INFORMATION = ::T.let(nil, ::T.untyped)
  WARNING = ::T.let(nil, ::T.untyped)
end

module Solargraph::Diagnostics::Severities
end

class Solargraph::Diagnostics::TypeCheck
end

class Solargraph::Diagnostics::TypeCheck
end

class Solargraph::Diagnostics::UpdateErrors
end

class Solargraph::Diagnostics::UpdateErrors
end

module Solargraph::Diagnostics
  def self.register(name, klass); end

  def self.reporter(name); end

  def self.reporters(); end
end

class Solargraph::Documentor
  def document(); end

  def initialize(directory, rebuild: T.unsafe(nil), out: T.unsafe(nil)); end
  RDOC_GEMS = ::T.let(nil, ::T.untyped)
end

class Solargraph::Documentor
  def self.specs_from_bundle(directory); end
end

class Solargraph::Environ
  def clear(); end

  def domains(); end

  def initialize(requires: T.unsafe(nil), domains: T.unsafe(nil), overrides: T.unsafe(nil)); end

  def merge(other); end

  def overrides(); end

  def requires(); end
end

class Solargraph::Environ
end

module Solargraph::LanguageServer
end

module Solargraph::LanguageServer::CompletionItemKinds
  CLASS = ::T.let(nil, ::T.untyped)
  COLOR = ::T.let(nil, ::T.untyped)
  CONSTANT = ::T.let(nil, ::T.untyped)
  CONSTRUCTOR = ::T.let(nil, ::T.untyped)
  ENUM = ::T.let(nil, ::T.untyped)
  ENUM_MEMBER = ::T.let(nil, ::T.untyped)
  EVENT = ::T.let(nil, ::T.untyped)
  FIELD = ::T.let(nil, ::T.untyped)
  FILE = ::T.let(nil, ::T.untyped)
  FOLDER = ::T.let(nil, ::T.untyped)
  FUNCTION = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
  METHOD = ::T.let(nil, ::T.untyped)
  MODULE = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  PROPERTY = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
  SNIPPET = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  TYPE_PARAMETER = ::T.let(nil, ::T.untyped)
  UNIT = ::T.let(nil, ::T.untyped)
  VALUE = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

module Solargraph::LanguageServer::CompletionItemKinds
end

module Solargraph::LanguageServer::ErrorCodes
  INTERNAL_ERROR = ::T.let(nil, ::T.untyped)
  INVALID_PARAMS = ::T.let(nil, ::T.untyped)
  INVALID_REQUEST = ::T.let(nil, ::T.untyped)
  METHOD_NOT_FOUND = ::T.let(nil, ::T.untyped)
  PARSE_ERROR = ::T.let(nil, ::T.untyped)
  REQUEST_CANCELLED = ::T.let(nil, ::T.untyped)
  SERVER_ERROR_END = ::T.let(nil, ::T.untyped)
  SERVER_ERROR_START = ::T.let(nil, ::T.untyped)
  SERVER_NOT_INITIALIZED = ::T.let(nil, ::T.untyped)
  UNKNOWN_ERROR_CODE = ::T.let(nil, ::T.untyped)
end

module Solargraph::LanguageServer::ErrorCodes
end

class Solargraph::LanguageServer::Host
  include ::Solargraph::LanguageServer::UriHelpers
  include ::Solargraph::Logging
  include ::Solargraph::LanguageServer::Host::Dispatch
  include ::Observable
  def allow_registration(method); end

  def can_register?(method); end

  def cancel(id); end

  def cancel?(id); end

  def catalog(); end

  def change(params); end

  def clear(id); end

  def client_capabilities(); end

  def client_capabilities=(client_capabilities); end

  def close(uri); end

  def completions_at(uri, line, column); end

  def configure(update); end

  def create(uri); end

  def default_configuration(); end

  def definitions_at(uri, line, column); end

  def delete(uri); end

  def diagnose(uri); end

  def document(query); end

  def document_symbols(uri); end

  def flush(); end

  def folders(); end

  def folding_ranges(uri); end

  def locate_pins(params); end

  def open(uri, text, version); end

  def open?(uri); end

  def open_from_disk(uri); end

  def options(); end

  def pending_requests(); end

  def prepare(directory, name=T.unsafe(nil)); end

  def prepare_folders(array); end

  def query_symbols(query); end

  def queue(message); end

  def read_text(uri); end

  def receive(request); end

  def references_from(uri, line, column, strip: T.unsafe(nil)); end

  def register_capabilities(methods); end

  def registered?(method); end

  def remove(directory); end

  def remove_folders(array); end

  def search(query); end

  def send_notification(method, params); end

  def send_request(method, params, &block); end

  def show_message(text, type=T.unsafe(nil)); end

  def show_message_request(text, type, actions, &block); end

  def signatures_at(uri, line, column); end

  def start(); end

  def stop(); end

  def stopped?(); end

  def synchronizing?(); end

  def unregister_capabilities(methods); end
end

class Solargraph::LanguageServer::Host::Cataloger
  def initialize(host); end

  def start(); end

  def stop(); end

  def stopped?(); end

  def tick(); end
end

class Solargraph::LanguageServer::Host::Cataloger
end

class Solargraph::LanguageServer::Host::Diagnoser
  def initialize(host); end

  def schedule(uri); end

  def start(); end

  def stop(); end

  def stopped?(); end

  def tick(); end
end

class Solargraph::LanguageServer::Host::Diagnoser
end

module Solargraph::LanguageServer::Host::Dispatch
  def explicit_library_for(uri); end

  def generic_library(); end

  def generic_library_for(uri); end

  def implicit_library_for(uri); end

  def libraries(); end

  def library_for(uri); end

  def sources(); end

  def update_libraries(uri); end
end

module Solargraph::LanguageServer::Host::Dispatch
end

class Solargraph::LanguageServer::Host::Sources
  include ::Observable
  include ::Solargraph::LanguageServer::UriHelpers
  def async_update(uri, updater); end

  def clear(); end

  def close(uri); end

  def find(uri); end

  def include?(uri); end

  def open(uri, text, version); end

  def open_from_disk(uri); end

  def start(); end

  def stop(); end

  def stopped?(); end

  def tick(); end

  def update(uri, updater); end
end

class Solargraph::LanguageServer::Host::Sources
end

class Solargraph::LanguageServer::Host
end

module Solargraph::LanguageServer::Message
end

class Solargraph::LanguageServer::Message::Base
  def error(); end

  def host(); end

  def id(); end

  def initialize(host, request); end

  def method(); end

  def params(); end

  def post_initialize(); end

  def process(); end

  def request(); end

  def result(); end

  def send_response(); end

  def set_error(code, message); end

  def set_result(data); end
end

class Solargraph::LanguageServer::Message::Base
end

class Solargraph::LanguageServer::Message::CancelRequest
end

class Solargraph::LanguageServer::Message::CancelRequest
end

module Solargraph::LanguageServer::Message::CompletionItem
end

class Solargraph::LanguageServer::Message::CompletionItem::Resolve
end

class Solargraph::LanguageServer::Message::CompletionItem::Resolve
end

module Solargraph::LanguageServer::Message::CompletionItem
end

class Solargraph::LanguageServer::Message::ExitNotification
end

class Solargraph::LanguageServer::Message::ExitNotification
end

module Solargraph::LanguageServer::Message::Extended
end

class Solargraph::LanguageServer::Message::Extended::CheckGemVersion
  def initialize(host, request, current: T.unsafe(nil), available: T.unsafe(nil)); end
  GEM_ZERO = ::T.let(nil, ::T.untyped)
end

class Solargraph::LanguageServer::Message::Extended::CheckGemVersion
  def self.fetcher(); end

  def self.fetcher=(obj); end
end

class Solargraph::LanguageServer::Message::Extended::Document
end

class Solargraph::LanguageServer::Message::Extended::Document
end

class Solargraph::LanguageServer::Message::Extended::DocumentGems
end

class Solargraph::LanguageServer::Message::Extended::DocumentGems
end

class Solargraph::LanguageServer::Message::Extended::DownloadCore
end

class Solargraph::LanguageServer::Message::Extended::DownloadCore
end

class Solargraph::LanguageServer::Message::Extended::Environment
end

class Solargraph::LanguageServer::Message::Extended::Environment
end

class Solargraph::LanguageServer::Message::Extended::Search
end

class Solargraph::LanguageServer::Message::Extended::Search
end

module Solargraph::LanguageServer::Message::Extended
end

class Solargraph::LanguageServer::Message::Initialize
end

class Solargraph::LanguageServer::Message::Initialize
end

class Solargraph::LanguageServer::Message::Initialized
end

class Solargraph::LanguageServer::Message::Initialized
end

class Solargraph::LanguageServer::Message::MethodNotFound
end

class Solargraph::LanguageServer::Message::MethodNotFound
end

class Solargraph::LanguageServer::Message::MethodNotImplemented
end

class Solargraph::LanguageServer::Message::MethodNotImplemented
end

class Solargraph::LanguageServer::Message::Shutdown
end

class Solargraph::LanguageServer::Message::Shutdown
end

module Solargraph::LanguageServer::Message::TextDocument
end

class Solargraph::LanguageServer::Message::TextDocument::Base
  include ::Solargraph::LanguageServer::UriHelpers
  def filename(); end
end

class Solargraph::LanguageServer::Message::TextDocument::Base
end

class Solargraph::LanguageServer::Message::TextDocument::CodeAction
end

class Solargraph::LanguageServer::Message::TextDocument::CodeAction
end

class Solargraph::LanguageServer::Message::TextDocument::Completion
  def empty_result(incomplete=T.unsafe(nil)); end
end

class Solargraph::LanguageServer::Message::TextDocument::Completion
end

class Solargraph::LanguageServer::Message::TextDocument::Definition
end

class Solargraph::LanguageServer::Message::TextDocument::Definition
end

class Solargraph::LanguageServer::Message::TextDocument::DidChange
end

class Solargraph::LanguageServer::Message::TextDocument::DidChange
end

class Solargraph::LanguageServer::Message::TextDocument::DidClose
end

class Solargraph::LanguageServer::Message::TextDocument::DidClose
end

class Solargraph::LanguageServer::Message::TextDocument::DidOpen
end

class Solargraph::LanguageServer::Message::TextDocument::DidOpen
end

class Solargraph::LanguageServer::Message::TextDocument::DidSave
end

class Solargraph::LanguageServer::Message::TextDocument::DidSave
end

class Solargraph::LanguageServer::Message::TextDocument::DocumentSymbol
  include ::Solargraph::LanguageServer::UriHelpers
end

class Solargraph::LanguageServer::Message::TextDocument::DocumentSymbol
end

class Solargraph::LanguageServer::Message::TextDocument::FoldingRange
end

class Solargraph::LanguageServer::Message::TextDocument::FoldingRange
end

class Solargraph::LanguageServer::Message::TextDocument::Formatting
  include ::Solargraph::Diagnostics::RubocopHelpers
end

class Solargraph::LanguageServer::Message::TextDocument::Formatting
end

class Solargraph::LanguageServer::Message::TextDocument::Hover
end

class Solargraph::LanguageServer::Message::TextDocument::Hover
end

class Solargraph::LanguageServer::Message::TextDocument::OnTypeFormatting
end

class Solargraph::LanguageServer::Message::TextDocument::OnTypeFormatting
end

class Solargraph::LanguageServer::Message::TextDocument::PrepareRename
end

class Solargraph::LanguageServer::Message::TextDocument::PrepareRename
end

class Solargraph::LanguageServer::Message::TextDocument::References
end

class Solargraph::LanguageServer::Message::TextDocument::References
end

class Solargraph::LanguageServer::Message::TextDocument::Rename
end

class Solargraph::LanguageServer::Message::TextDocument::Rename
end

class Solargraph::LanguageServer::Message::TextDocument::SignatureHelp
end

class Solargraph::LanguageServer::Message::TextDocument::SignatureHelp
end

module Solargraph::LanguageServer::Message::TextDocument
end

module Solargraph::LanguageServer::Message::Workspace
end

class Solargraph::LanguageServer::Message::Workspace::DidChangeConfiguration
end

class Solargraph::LanguageServer::Message::Workspace::DidChangeConfiguration
end

class Solargraph::LanguageServer::Message::Workspace::DidChangeWatchedFiles
  include ::Solargraph::LanguageServer::UriHelpers
  CHANGED = ::T.let(nil, ::T.untyped)
  CREATED = ::T.let(nil, ::T.untyped)
  DELETED = ::T.let(nil, ::T.untyped)
end

class Solargraph::LanguageServer::Message::Workspace::DidChangeWatchedFiles
end

class Solargraph::LanguageServer::Message::Workspace::DidChangeWorkspaceFolders
end

class Solargraph::LanguageServer::Message::Workspace::DidChangeWorkspaceFolders
end

class Solargraph::LanguageServer::Message::Workspace::WorkspaceSymbol
  include ::Solargraph::LanguageServer::UriHelpers
end

class Solargraph::LanguageServer::Message::Workspace::WorkspaceSymbol
end

module Solargraph::LanguageServer::Message::Workspace
end

module Solargraph::LanguageServer::Message
  def self.register(path, message_class); end

  def self.select(path); end
end

module Solargraph::LanguageServer::MessageTypes
  ERROR = ::T.let(nil, ::T.untyped)
  INFO = ::T.let(nil, ::T.untyped)
  LOG = ::T.let(nil, ::T.untyped)
  WARNING = ::T.let(nil, ::T.untyped)
end

module Solargraph::LanguageServer::MessageTypes
end

class Solargraph::LanguageServer::Request
  def initialize(id, &block); end

  def process(result); end

  def send_response(); end
end

class Solargraph::LanguageServer::Request
end

module Solargraph::LanguageServer::SymbolKinds
  ARRAY = ::T.let(nil, ::T.untyped)
  BOOLEAN = ::T.let(nil, ::T.untyped)
  CLASS = ::T.let(nil, ::T.untyped)
  CONSTANT = ::T.let(nil, ::T.untyped)
  CONSTRUCTOR = ::T.let(nil, ::T.untyped)
  ENUM = ::T.let(nil, ::T.untyped)
  ENUM_MEMBER = ::T.let(nil, ::T.untyped)
  EVENT = ::T.let(nil, ::T.untyped)
  FIELD = ::T.let(nil, ::T.untyped)
  FILE = ::T.let(nil, ::T.untyped)
  FUNCTION = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  KEY = ::T.let(nil, ::T.untyped)
  METHOD = ::T.let(nil, ::T.untyped)
  MODULE = ::T.let(nil, ::T.untyped)
  NAMESPACE = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  PACKAGE = ::T.let(nil, ::T.untyped)
  PROPERTY = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  TYPE_PARAMETER = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

module Solargraph::LanguageServer::SymbolKinds
end

module Solargraph::LanguageServer::Transport
end

module Solargraph::LanguageServer::Transport::Adapter
  def closing(); end

  def opening(); end

  def receiving(data); end

  def sending(data); end

  def update(); end
end

module Solargraph::LanguageServer::Transport::Adapter
end

class Solargraph::LanguageServer::Transport::DataReader
  def receive(data); end

  def set_message_handler(&block); end
end

class Solargraph::LanguageServer::Transport::DataReader
end

module Solargraph::LanguageServer::Transport
end

module Solargraph::LanguageServer::UriHelpers
end

module Solargraph::LanguageServer::UriHelpers
  def self.file_to_uri(file); end

  def self.uri_to_file(uri); end
end

module Solargraph::LanguageServer
end

class Solargraph::Library
  include ::Solargraph::Logging
  def attach(source); end

  def attached?(filename); end

  def catalog(); end

  def close(filename); end

  def completions_at(filename, line, column); end

  def contain?(filename); end

  def create(filename, text); end

  def create_from_disk(filename); end

  def current(); end

  def definitions_at(filename, line, column); end

  def delete(filename); end

  def detach(filename); end

  def diagnose(filename); end

  def document(query); end

  def document_symbols(filename); end

  def folding_ranges(filename); end

  def get_path_pins(path); end

  def initialize(workspace=T.unsafe(nil), name=T.unsafe(nil)); end

  def locate_pins(location); end

  def locate_ref(location); end

  def merge(source); end

  def name(); end

  def open?(filename); end

  def path_pins(path); end

  def query_symbols(query); end

  def read_text(filename); end

  def references_from(filename, line, column, strip: T.unsafe(nil)); end

  def search(query); end

  def signatures_at(filename, line, column); end

  def synchronized?(); end

  def workspace(); end
end

class Solargraph::Library
  def self.load(directory=T.unsafe(nil), name=T.unsafe(nil)); end
end

class Solargraph::Location
  def ==(other); end

  def filename(); end

  def initialize(filename, range); end

  def range(); end

  def to_hash(); end
end

class Solargraph::Location
end

module Solargraph::Logging
  DEFAULT_LOG_LEVEL = ::T.let(nil, ::T.untyped)
  LOG_LEVELS = ::T.let(nil, ::T.untyped)
end

module Solargraph::Logging
  def self.logger(); end
end

class Solargraph::Page
  def initialize(directory=T.unsafe(nil)); end

  def render(template, layout: T.unsafe(nil), locals: T.unsafe(nil)); end
end

class Solargraph::Page
  def self.select_template(directories, name); end
end

module Solargraph::Pin
  ROOT_PIN = ::T.let(nil, ::T.untyped)
end

class Solargraph::Pin::Attribute
  def access(); end

  def initialize(access: T.unsafe(nil), **splat); end
end

class Solargraph::Pin::Attribute
end

class Solargraph::Pin::Base
  include ::Solargraph::Pin::Common
  include ::Solargraph::Pin::Conversions
  include ::Solargraph::Pin::Documenting
  def ==(other); end

  def code_object(); end

  def completion_item_kind(); end

  def deprecated?(); end

  def directives(); end

  def docstring(); end

  def filename(); end

  def identity(); end

  def infer(api_map); end

  def initialize(location: T.unsafe(nil), closure: T.unsafe(nil), name: T.unsafe(nil), comments: T.unsafe(nil)); end

  def macros(); end

  def maybe_directives?(); end

  def nearly?(other); end

  def probe(api_map); end

  def probed=(probed); end

  def probed?(); end

  def proxied=(proxied); end

  def proxied?(); end

  def proxy(return_type); end

  def realize(api_map); end

  def return_type=(return_type); end

  def symbol_kind(); end

  def try_merge!(pin); end

  def typify(api_map); end

  def variable?(); end
end

class Solargraph::Pin::Base
end

class Solargraph::Pin::BaseMethod
  def initialize(visibility: T.unsafe(nil), **splat); end

  def parameter_names(); end

  def parameters(); end

  def visibility(); end
end

class Solargraph::Pin::BaseMethod
end

class Solargraph::Pin::BaseVariable
  include ::Solargraph::Source::NodeMethods
  def assignment(); end

  def initialize(assignment: T.unsafe(nil), **splat); end

  def nil_assignment?(); end

  def signature(); end
end

class Solargraph::Pin::BaseVariable
end

class Solargraph::Pin::Block
  def initialize(receiver: T.unsafe(nil), args: T.unsafe(nil), **splat); end

  def parameter_names(); end

  def parameters(); end

  def rebind(context); end

  def rebound?(); end

  def receiver(); end
end

class Solargraph::Pin::Block
end

class Solargraph::Pin::ClassVariable
end

class Solargraph::Pin::ClassVariable
end

class Solargraph::Pin::Closure
  def gates(); end

  def initialize(scope: T.unsafe(nil), **splat); end

  def scope(); end
end

class Solargraph::Pin::Closure
end

module Solargraph::Pin::Common
  def binder(); end

  def closure(); end

  def comments(); end

  def context(); end

  def full_context(); end

  def location(); end

  def name(); end

  def namespace(); end

  def path(); end

  def return_type(); end
end

module Solargraph::Pin::Common
end

class Solargraph::Pin::Constant
  def initialize(visibility: T.unsafe(nil), **splat); end

  def visibility(); end
end

class Solargraph::Pin::Constant
end

module Solargraph::Pin::Conversions
  def completion_item(); end

  def detail(); end

  def link_documentation(); end

  def reset_conversions(); end

  def resolve_completion_item(); end

  def signature_help(); end

  def text_documentation(); end
end

module Solargraph::Pin::Conversions
end

module Solargraph::Pin::Documenting
  def documentation(); end
end

module Solargraph::Pin::Documenting
end

class Solargraph::Pin::DuckMethod
end

class Solargraph::Pin::DuckMethod
end

class Solargraph::Pin::GlobalVariable
end

class Solargraph::Pin::GlobalVariable
end

class Solargraph::Pin::InstanceVariable
  def scope(); end
end

class Solargraph::Pin::InstanceVariable
end

class Solargraph::Pin::Keyword
  def initialize(name); end
end

class Solargraph::Pin::Keyword
end

class Solargraph::Pin::KeywordParam
end

class Solargraph::Pin::KeywordParam
end

class Solargraph::Pin::LocalVariable
  include ::Solargraph::Pin::Localized
  def initialize(assignment: T.unsafe(nil), presence: T.unsafe(nil), **splat); end
end

class Solargraph::Pin::LocalVariable
end

module Solargraph::Pin::Localized
  def presence(); end

  def visible_at?(other_loc); end

  def visible_from?(other, position); end
end

module Solargraph::Pin::Localized
end

class Solargraph::Pin::Method
  include ::Solargraph::Source::NodeMethods
  def initialize(args: T.unsafe(nil), node: T.unsafe(nil), **splat); end

  def node(); end

  def overloads(); end
end

class Solargraph::Pin::Method
end

class Solargraph::Pin::MethodAlias
  def initialize(scope: T.unsafe(nil), original: T.unsafe(nil), **splat); end

  def original(); end
end

class Solargraph::Pin::MethodAlias
end

class Solargraph::Pin::Namespace
  def domains(); end

  def initialize(type: T.unsafe(nil), visibility: T.unsafe(nil), gates: T.unsafe(nil), **splat); end

  def type(); end

  def visibility(); end
end

class Solargraph::Pin::Namespace
end

class Solargraph::Pin::Parameter
  def index(); end
end

class Solargraph::Pin::Parameter
end

class Solargraph::Pin::ProxyType
  def initialize(return_type: T.unsafe(nil), **splat); end
end

class Solargraph::Pin::ProxyType
  def self.anonymous(return_type); end
end

class Solargraph::Pin::Reference
end

class Solargraph::Pin::Reference
end

class Solargraph::Pin::Singleton
  def initialize(name: T.unsafe(nil), location: T.unsafe(nil), closure: T.unsafe(nil)); end
end

class Solargraph::Pin::Singleton
end

class Solargraph::Pin::Symbol
  def initialize(location, name); end

  def visibility(); end
end

class Solargraph::Pin::Symbol
end

module Solargraph::Pin::YardPin
end

class Solargraph::Pin::YardPin::Constant
  include ::Solargraph::Pin::YardPin::YardMixin
  def initialize(code_object, closure=T.unsafe(nil), spec=T.unsafe(nil)); end
end

class Solargraph::Pin::YardPin::Constant
end

class Solargraph::Pin::YardPin::Method
  include ::Solargraph::Pin::YardPin::YardMixin
  def initialize(code_object, name=T.unsafe(nil), scope=T.unsafe(nil), visibility=T.unsafe(nil), closure=T.unsafe(nil), spec=T.unsafe(nil)); end
end

class Solargraph::Pin::YardPin::Method
end

class Solargraph::Pin::YardPin::Namespace
  include ::Solargraph::Pin::YardPin::YardMixin
  def initialize(code_object, spec); end
end

class Solargraph::Pin::YardPin::Namespace
end

module Solargraph::Pin::YardPin::YardMixin
  def code_object(); end

  def comments(); end

  def location(); end

  def spec(); end
end

module Solargraph::Pin::YardPin::YardMixin
end

module Solargraph::Pin::YardPin
end

module Solargraph::Pin
end

class Solargraph::Position
  def ==(other); end

  def character(); end

  def column(); end

  def initialize(line, character); end

  def line(); end

  def to_hash(); end
end

class Solargraph::Position
  def self.from_offset(text, offset); end

  def self.line_char_to_offset(text, line, character); end

  def self.normalize(object); end

  def self.to_offset(text, position); end
end

class Solargraph::Range
  def ==(other); end

  def contain?(position); end

  def ending(); end

  def include?(position); end

  def initialize(start, ending); end

  def start(); end

  def to_hash(); end
end

class Solargraph::Range
  def self.from_expr(expr); end

  def self.from_node(node); end

  def self.from_to(l1, c1, l2, c2); end
end

module Solargraph::ServerMethods
  def available_port(); end
end

module Solargraph::ServerMethods
end

class Solargraph::Shell
  include ::Solargraph::ServerMethods
  def available_cores(); end

  def bundle(); end

  def clear(); end

  def config(directory=T.unsafe(nil)); end

  def download_core(version=T.unsafe(nil)); end

  def list_cores(); end

  def rdoc(gem, version=T.unsafe(nil)); end

  def reporters(); end

  def scan(); end

  def socket(); end

  def stdio(); end

  def typecheck(*files); end

  def uncache(*gems); end

  def version(); end
end

class Solargraph::Shell
end

class Solargraph::Source
  include ::Solargraph::Source::EncodingFixes
  include ::Solargraph::Source::NodeMethods
  def associated_comments(); end

  def at(range); end

  def code(); end

  def code=(code); end

  def code_for(node); end

  def comment_at?(position); end

  def comments(); end

  def comments=(comments); end

  def comments_for(node); end

  def cursor_at(position); end

  def error_ranges(); end

  def error_ranges=(error_ranges); end

  def filename(); end

  def filename=(filename); end

  def finish_synchronize(); end

  def folding_ranges(); end

  def from_to(l1, c1, l2, c2); end

  def initialize(code, filename=T.unsafe(nil), version=T.unsafe(nil)); end

  def last_updater(); end

  def last_updater=(last_updater); end

  def location(); end

  def node(); end

  def node=(node); end

  def node_at(line, column); end

  def parsed=(parsed); end

  def parsed?(); end

  def references(name); end

  def repaired(); end

  def repaired=(repaired); end

  def repaired?(); end

  def start_synchronize(updater); end

  def string_at?(position); end

  def synchronize(updater); end

  def synchronized=(synchronized); end

  def synchronized?(); end

  def tree_at(line, column); end

  def version(); end

  def version=(version); end
  FOLDING_NODE_TYPES = ::T.let(nil, ::T.untyped)
end

class Solargraph::Source::Chain
  def base(); end

  def constant?(); end

  def define(api_map, name_pin, locals); end

  def defined?(); end

  def infer(api_map, name_pin, locals); end

  def initialize(links); end

  def links(); end

  def literal?(); end

  def undefined?(); end
  UNDEFINED_CALL = ::T.let(nil, ::T.untyped)
  UNDEFINED_CONSTANT = ::T.let(nil, ::T.untyped)
end

class Solargraph::Source::Chain::BlockVariable
end

class Solargraph::Source::Chain::BlockVariable
end

class Solargraph::Source::Chain::Call
  def arguments(); end

  def initialize(word, arguments=T.unsafe(nil), with_block=T.unsafe(nil)); end

  def with_block?(); end
end

class Solargraph::Source::Chain::Call
end

class Solargraph::Source::Chain::ClassVariable
end

class Solargraph::Source::Chain::ClassVariable
end

class Solargraph::Source::Chain::Constant
  def initialize(word); end
end

class Solargraph::Source::Chain::Constant
end

class Solargraph::Source::Chain::GlobalVariable
end

class Solargraph::Source::Chain::GlobalVariable
end

class Solargraph::Source::Chain::Head
end

class Solargraph::Source::Chain::Head
end

class Solargraph::Source::Chain::InstanceVariable
end

class Solargraph::Source::Chain::InstanceVariable
end

class Solargraph::Source::Chain::Link
  def ==(other); end

  def constant?(); end

  def initialize(word=T.unsafe(nil)); end

  def last_context(); end

  def last_context=(last_context); end

  def resolve(api_map, name_pin, locals); end

  def undefined?(); end

  def word(); end
end

class Solargraph::Source::Chain::Link
end

class Solargraph::Source::Chain::Literal
  def initialize(type); end
end

class Solargraph::Source::Chain::Literal
end

class Solargraph::Source::Chain::Or
  def initialize(links); end
end

class Solargraph::Source::Chain::Or
end

class Solargraph::Source::Chain::Variable
end

class Solargraph::Source::Chain::Variable
end

class Solargraph::Source::Chain
end

class Solargraph::Source::Change
  include ::Solargraph::Source::EncodingFixes
  def initialize(range, new_text); end

  def new_text(); end

  def range(); end

  def repair(text); end

  def write(text, nullable=T.unsafe(nil)); end
end

class Solargraph::Source::Change
end

class Solargraph::Source::Cursor
  def argument?(); end

  def chain(); end

  def comment?(); end

  def end_of_word(); end

  def filename(); end

  def initialize(source, position); end

  def node(); end

  def node_position(); end

  def position(); end

  def range(); end

  def receiver(); end

  def recipient(); end

  def recipient_node(); end

  def source(); end

  def start_of_constant?(); end

  def start_of_word(); end

  def string?(); end

  def word(); end
end

class Solargraph::Source::Cursor
end

module Solargraph::Source::EncodingFixes
end

module Solargraph::Source::EncodingFixes
  def self.normalize(string); end
end

class Solargraph::Source::FlawedBuilder
end

class Solargraph::Source::FlawedBuilder
end

class Solargraph::Source::NodeChainer
  include ::Solargraph::Source::NodeMethods
  def chain(); end

  def initialize(node, filename=T.unsafe(nil), in_block=T.unsafe(nil)); end
end

class Solargraph::Source::NodeChainer
  def self.chain(node, filename=T.unsafe(nil), in_block=T.unsafe(nil)); end

  def self.load_string(code); end
end

module Solargraph::Source::NodeMethods
  NIL_NODE = ::T.let(nil, ::T.untyped)
end

module Solargraph::Source::NodeMethods
  def self.const_from(node); end

  def self.drill_signature(node, signature); end

  def self.get_node_end_position(node); end

  def self.get_node_start_position(node); end

  def self.infer_literal_node_type(node); end

  def self.pack_name(node); end

  def self.resolve_node_signature(node); end

  def self.returns_from(node); end

  def self.unpack_name(node); end
end

class Solargraph::Source::SourceChainer
  include ::Solargraph::Source::NodeMethods
  def chain(); end

  def initialize(source, position); end
end

class Solargraph::Source::SourceChainer
  def self.chain(source, position); end
end

class Solargraph::Source::Updater
  def changes(); end

  def filename(); end

  def initialize(filename, version, changes); end

  def repair(text); end

  def version(); end

  def write(text, nullable=T.unsafe(nil)); end
end

class Solargraph::Source::Updater
end

class Solargraph::Source
  def self.load(filename); end

  def self.load_string(code, filename=T.unsafe(nil), version=T.unsafe(nil)); end

  def self.parse(code, filename=T.unsafe(nil), line=T.unsafe(nil)); end

  def self.parse_docstring(comments); end

  def self.parse_with_comments(code, filename=T.unsafe(nil)); end

  def self.parser(); end
end

class Solargraph::SourceMap
  def code(); end

  def cursor_at(position); end

  def document_symbols(); end

  def environ(); end

  def filename(); end

  def first_pin(path); end

  def initialize(source, pins, locals); end

  def locals(); end

  def locals_at(location); end

  def locate_block_pin(line, character); end

  def locate_named_path_pin(line, character); end

  def locate_pins(location); end

  def pins(); end

  def query_symbols(query); end

  def references(name); end

  def requires(); end

  def source(); end

  def try_merge!(other_map); end
end

class Solargraph::SourceMap::Clip
  def complete(); end

  def define(); end

  def gates(); end

  def in_block?(); end

  def infer(); end

  def initialize(api_map, cursor); end

  def locals(); end

  def signify(); end
end

class Solargraph::SourceMap::Clip
end

class Solargraph::SourceMap::Completion
  def initialize(pins, range); end

  def pins(); end

  def range(); end
end

class Solargraph::SourceMap::Completion
end

class Solargraph::SourceMap::Mapper
  include ::Solargraph::Source::NodeMethods
  def closure_at(position); end

  def find_directive_line_number(comment, tag, start); end

  def map(source); end

  def pins(); end

  def process_comment(source_position, comment_position, comment); end

  def process_comment_directives(); end

  def process_directive(source_position, comment_position, directive); end

  def remove_inline_comment_hashes(comment); end

  def unmap(filename, code); end
  MACRO_REGEXP = ::T.let(nil, ::T.untyped)
end

class Solargraph::SourceMap::Mapper
  def self.map(source); end
end

module Solargraph::SourceMap::NodeProcessor
end

class Solargraph::SourceMap::NodeProcessor::AliasNode
end

class Solargraph::SourceMap::NodeProcessor::AliasNode
end

class Solargraph::SourceMap::NodeProcessor::ArgsNode
end

class Solargraph::SourceMap::NodeProcessor::ArgsNode
end

class Solargraph::SourceMap::NodeProcessor::Base
  include ::Solargraph::Source::NodeMethods
  def initialize(node, region, pins, locals); end

  def locals(); end

  def node(); end

  def pins(); end

  def process(); end

  def region(); end
end

class Solargraph::SourceMap::NodeProcessor::Base
end

class Solargraph::SourceMap::NodeProcessor::BeginNode
end

class Solargraph::SourceMap::NodeProcessor::BeginNode
end

class Solargraph::SourceMap::NodeProcessor::BlockNode
end

class Solargraph::SourceMap::NodeProcessor::BlockNode
end

class Solargraph::SourceMap::NodeProcessor::CasgnNode
end

class Solargraph::SourceMap::NodeProcessor::CasgnNode
end

class Solargraph::SourceMap::NodeProcessor::CvasgnNode
end

class Solargraph::SourceMap::NodeProcessor::CvasgnNode
end

class Solargraph::SourceMap::NodeProcessor::DefNode
end

class Solargraph::SourceMap::NodeProcessor::DefNode
end

class Solargraph::SourceMap::NodeProcessor::DefsNode
end

class Solargraph::SourceMap::NodeProcessor::DefsNode
end

class Solargraph::SourceMap::NodeProcessor::GvasgnNode
end

class Solargraph::SourceMap::NodeProcessor::GvasgnNode
end

class Solargraph::SourceMap::NodeProcessor::IvasgnNode
end

class Solargraph::SourceMap::NodeProcessor::IvasgnNode
end

class Solargraph::SourceMap::NodeProcessor::LvasgnNode
end

class Solargraph::SourceMap::NodeProcessor::LvasgnNode
end

class Solargraph::SourceMap::NodeProcessor::NamespaceNode
end

class Solargraph::SourceMap::NodeProcessor::NamespaceNode
end

class Solargraph::SourceMap::NodeProcessor::OrasgnNode
end

class Solargraph::SourceMap::NodeProcessor::OrasgnNode
end

class Solargraph::SourceMap::NodeProcessor::ResbodyNode
end

class Solargraph::SourceMap::NodeProcessor::ResbodyNode
end

class Solargraph::SourceMap::NodeProcessor::SclassNode
end

class Solargraph::SourceMap::NodeProcessor::SclassNode
end

class Solargraph::SourceMap::NodeProcessor::SendNode
end

class Solargraph::SourceMap::NodeProcessor::SendNode
end

class Solargraph::SourceMap::NodeProcessor::SymNode
end

class Solargraph::SourceMap::NodeProcessor::SymNode
end

module Solargraph::SourceMap::NodeProcessor
  def self.process(node, region=T.unsafe(nil), pins=T.unsafe(nil), locals=T.unsafe(nil)); end
end

class Solargraph::SourceMap::Region
  def closure(); end

  def code_for(node); end

  def filename(); end

  def initialize(source: T.unsafe(nil), closure: T.unsafe(nil), scope: T.unsafe(nil), visibility: T.unsafe(nil)); end

  def scope(); end

  def source(); end

  def update(closure: T.unsafe(nil), scope: T.unsafe(nil), visibility: T.unsafe(nil)); end

  def visibility(); end
end

class Solargraph::SourceMap::Region
end

class Solargraph::SourceMap
  def self.load(filename); end

  def self.load_string(code, filename=T.unsafe(nil)); end

  def self.map(source); end
end

class Solargraph::TypeChecker
  def filename(); end

  def initialize(filename, api_map: T.unsafe(nil)); end

  def param_type_problems(); end

  def return_type_problems(); end

  def strict_type_problems(); end
end

class Solargraph::TypeChecker::ParamDef
  def initialize(name, type); end

  def name(); end

  def type(); end
end

class Solargraph::TypeChecker::ParamDef
  def self.from(pin); end
end

class Solargraph::TypeChecker::Problem
  def initialize(location, message, pin: T.unsafe(nil), suggestion: T.unsafe(nil)); end

  def location(); end

  def message(); end

  def pin(); end

  def suggestion(); end
end

class Solargraph::TypeChecker::Problem
end

class Solargraph::TypeChecker
  def self.load(filename); end

  def self.load_string(code, filename=T.unsafe(nil)); end
end

class Solargraph::Workspace
  def config(); end

  def directory(); end

  def filenames(); end

  def gemspec?(); end

  def gemspecs(); end

  def has_file?(filename); end

  def initialize(directory=T.unsafe(nil), config=T.unsafe(nil)); end

  def merge(source); end

  def remove(filename); end

  def require_paths(); end

  def source(filename); end

  def sources(); end

  def synchronize!(updater); end

  def would_merge?(filename); end

  def would_require?(path); end
end

class Solargraph::Workspace::Config
  def allow?(filename); end

  def calculated(); end

  def directory(); end

  def domains(); end

  def excluded(); end

  def included(); end

  def initialize(directory=T.unsafe(nil)); end

  def max_files(); end

  def raw_data(); end

  def reporters(); end

  def require_paths(); end

  def required(); end
  MAX_FILES = ::T.let(nil, ::T.untyped)
end

class Solargraph::Workspace::Config
end

class Solargraph::Workspace
end

class Solargraph::YardMap
  def change(new_requires, new_gemset); end

  def core_pins(); end

  def gemset(); end

  def initialize(required: T.unsafe(nil), gemset: T.unsafe(nil), with_dependencies: T.unsafe(nil)); end

  def load_yardoc(y); end

  def path_pin(path); end

  def pins(); end

  def require_reference(path); end

  def required(); end

  def unresolved_requires(); end

  def with_dependencies=(with_dependencies); end

  def with_dependencies?(); end

  def yardocs(); end
end

class Solargraph::YardMap::Cache
  def get_path_pins(path); end

  def set_path_pins(path, pins); end
end

class Solargraph::YardMap::Cache
end

module Solargraph::YardMap::CoreDocs
  DEFAULT = ::T.let(nil, ::T.untyped)
  SOURCE = ::T.let(nil, ::T.untyped)
end

module Solargraph::YardMap::CoreDocs
  def self.available(); end

  def self.best_download(current=T.unsafe(nil)); end

  def self.best_match(); end

  def self.cache_dir(); end

  def self.clear(); end

  def self.download(version); end

  def self.require_minimum(); end

  def self.valid?(ver); end

  def self.versions(); end

  def self.yardoc_file(ver=T.unsafe(nil)); end

  def self.yardoc_stdlib_file(ver=T.unsafe(nil)); end
end

module Solargraph::YardMap::CoreGen
end

module Solargraph::YardMap::CoreGen
  def self.generate_docs(ruby_dir, dest_dir); end

  def self.generate_gzip(ruby_dir, ver_name=T.unsafe(nil), dest_dir=T.unsafe(nil)); end
end

class Solargraph::YardMap::Mapper
  def generate_pins(code_object); end

  def initialize(code_objects, spec=T.unsafe(nil)); end

  def map(); end
end

class Solargraph::YardMap::Mapper
end

module Solargraph::YardMap::RdocToYard
end

module Solargraph::YardMap::RdocToYard
  extend ::Solargraph::ApiMap::SourceToYard
  def self.base_name(mod); end

  def self.commentary(cmnt); end

  def self.find_file(obj); end

  def self.locate(obj); end

  def self.run(spec); end
end

class Solargraph::YardMap
end

class Sorbet::Private::ConstantLookupCache
  def all_module_aliases(); end

  def all_module_names(); end

  def all_named_modules(); end

  def class_by_name(name); end

  def name_by_class(klass); end
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::ConstantLookupCache::ConstantEntry
  def aliases(); end

  def aliases=(_); end

  def const(); end

  def const=(_); end

  def const_name(); end

  def const_name=(_); end

  def found_name(); end

  def found_name=(_); end

  def owner(); end

  def owner=(_); end

  def primary_name(); end

  def primary_name=(_); end
end

class Sorbet::Private::ConstantLookupCache::ConstantEntry
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::ConstantLookupCache
end

class Sorbet::Private::CreateConfig
  include ::Sorbet::Private::StepInterface
  SORBET_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  SORBET_DIR = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::CreateConfig
  def self.main(); end

  def self.output_file(); end
end

class Sorbet::Private::FetchRBIs
  include ::Sorbet::Private::StepInterface
  HEADER = ::T.let(nil, ::T.untyped)
  RBI_CACHE_DIR = ::T.let(nil, ::T.untyped)
  SORBET_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  SORBET_DIR = ::T.let(nil, ::T.untyped)
  SORBET_RBI_LIST = ::T.let(nil, ::T.untyped)
  SORBET_RBI_SORBET_TYPED = ::T.let(nil, ::T.untyped)
  SORBET_TYPED_REPO = ::T.let(nil, ::T.untyped)
  SORBET_TYPED_REVISION = ::T.let(nil, ::T.untyped)
  XDG_CACHE_HOME = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::FetchRBIs
  def self.fetch_sorbet_typed(); end

  def self.main(); end

  def self.matching_version_directories(root, version); end

  def self.output_file(); end

  def self.paths_for_gem_version(gemspec); end

  def self.paths_for_ruby_version(ruby_version); end

  def self.vendor_rbis_within_paths(vendor_paths); end
end

class Sorbet::Private::FindGemRBIs
  include ::Sorbet::Private::StepInterface
  GEM_DIR = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  RBI_CACHE_DIR = ::T.let(nil, ::T.untyped)
  XDG_CACHE_HOME = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::FindGemRBIs
  def self.main(); end

  def self.output_file(); end

  def self.paths_within_gem_sources(gemspec); end
end

module Sorbet::Private::GemGeneratorTracepoint
  include ::Sorbet::Private::StepInterface
  OUTPUT = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def defs(); end

  def defs=(_); end

  def id(); end

  def id=(_); end

  def klass(); end

  def klass=(_); end
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::GemGeneratorTracepoint::TracepointSerializer
  def initialize(files:, delegate_classes:); end

  def serialize(output_dir); end
  BAD_METHODS = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemGeneratorTracepoint::TracepointSerializer
end

class Sorbet::Private::GemGeneratorTracepoint::Tracer
end

class Sorbet::Private::GemGeneratorTracepoint::Tracer
  def self.add_to_context(item); end

  def self.disable_tracepoints(); end

  def self.finish(); end

  def self.install_tracepoints(); end

  def self.on_method_added(mod, method, singleton); end

  def self.on_module_created(mod); end

  def self.on_module_extended(extended, extender); end

  def self.on_module_included(included, includer); end

  def self.pre_cache_module_methods(); end

  def self.register_delegate_class(klass, delegate); end

  def self.start(); end

  def self.trace(); end

  def self.trace_results(); end
end

module Sorbet::Private::GemGeneratorTracepoint
  def self.main(output_dir=T.unsafe(nil)); end

  def self.output_file(); end
end

class Sorbet::Private::GemLoader
  GEM_LOADER = ::T.let(nil, ::T.untyped)
  NO_GEM = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemLoader
  def self.my_require(gem); end

  def self.require_all_gems(); end

  def self.require_gem(gem); end
end

class Sorbet::Private::HiddenMethodFinder
  include ::Sorbet::Private::StepInterface
  def all_modules_and_aliases(); end

  def capture_stderr(); end

  def constant_cache(); end

  def gen_source_rbi(classes, aliases); end

  def looks_like_stub_name(name); end

  def main(); end

  def mk_dir(); end

  def read_constants(); end

  def real_name(mod); end

  def require_everything(); end

  def rm_dir(); end

  def serialize_alias(source_entry, rbi_entry, my_klass, source_symbols, rbi_symbols); end

  def serialize_class(source_entry, rbi_entry, klass, source_symbols, rbi_symbols, source_by_name); end

  def serialize_constants(source, rbi, klass, is_singleton, source_symbols, rbi_symbols); end

  def symbols_id_to_name(entry, prefix); end

  def write_constants(); end

  def write_diff(source, rbi); end
  BLACKLIST = ::T.let(nil, ::T.untyped)
  DIFF_RBI = ::T.let(nil, ::T.untyped)
  ERRORS_RBI = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  HIDDEN_RBI = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  RBI_CONSTANTS = ::T.let(nil, ::T.untyped)
  RBI_CONSTANTS_ERR = ::T.let(nil, ::T.untyped)
  SOURCE_CONSTANTS = ::T.let(nil, ::T.untyped)
  SOURCE_CONSTANTS_ERR = ::T.let(nil, ::T.untyped)
  TMP_PATH = ::T.let(nil, ::T.untyped)
  TMP_RBI = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::HiddenMethodFinder
  def self.main(); end

  def self.output_file(); end
end

module Sorbet::Private::Main
end

module Sorbet::Private::Main
  def self.cyan(msg); end

  def self.emojify(emoji, msg); end

  def self.init(); end

  def self.main(argv); end

  def self.make_step(step); end

  def self.usage(); end

  def self.yellow(msg); end
end

module Sorbet::Private::RealStdlib
end

module Sorbet::Private::RealStdlib
  def self.real_ancestors(mod); end

  def self.real_autoload?(o, klass); end

  def self.real_const_get(obj, const, arg); end

  def self.real_constants(mod); end

  def self.real_eqeq(obj, other); end

  def self.real_hash(o); end

  def self.real_instance_methods(mod, arg); end

  def self.real_is_a?(o, klass); end

  def self.real_method(obj, sym); end

  def self.real_name(o); end

  def self.real_object_id(o); end

  def self.real_private_instance_methods(mod, arg); end

  def self.real_singleton_class(obj); end

  def self.real_singleton_methods(mod, arg); end

  def self.real_spaceship(obj, arg); end

  def self.real_superclass(o); end
end

class Sorbet::Private::RequireEverything
end

class Sorbet::Private::RequireEverything
  def self.excluded_rails_files(); end

  def self.load_bundler(); end

  def self.load_rails(); end

  def self.my_require(abs_path, numerator, denominator); end

  def self.patch_kernel(); end

  def self.rails?(); end

  def self.rails_load_paths(); end

  def self.rb_file_paths(); end

  def self.require_all_files(); end

  def self.require_everything(); end
end

class Sorbet::Private::Serialize
  def alias(base, other_name); end

  def ancestor_has_method(method, klass); end

  def blacklisted_method(method); end

  def class_or_module(class_name); end

  def comparable?(value); end

  def constant(const, value); end

  def from_method(method); end

  def initialize(constant_cache); end

  def serialize_method(method, static=T.unsafe(nil), with_sig: T.unsafe(nil)); end

  def serialize_sig(parameters); end

  def to_sig(kind, name); end

  def valid_class_name(name); end

  def valid_method_name(name); end
  BLACKLIST_CONSTANTS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::Serialize
  def self.header(typed=T.unsafe(nil), subcommand=T.unsafe(nil)); end
end

module Sorbet::Private::Status
end

module Sorbet::Private::Status
  def self.done(); end

  def self.say(message, print_without_tty: T.unsafe(nil)); end
end

module Sorbet::Private::StepInterface
end

module Sorbet::Private::StepInterface
  def self.main(); end

  def self.output_file(); end
end

class Sorbet::Private::SuggestTyped
  include ::Sorbet::Private::StepInterface
end

class Sorbet::Private::SuggestTyped
  def self.main(); end

  def self.output_file(); end

  def self.suggest_typed(); end
end

class Sorbet::Private::TodoRBI
  include ::Sorbet::Private::StepInterface
  HEADER = ::T.let(nil, ::T.untyped)
  OUTPUT = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::TodoRBI
  def self.main(); end

  def self.output_file(); end
end

SorbetRails::ModelPlugins::Base::Parameter = Parlour::RbiGenerator::Parameter

module SorbetRails
  extend ::T::Private::Methods::SingletonMethodHooks
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

module Sprockets
  VERSION = ::T.let(nil, ::T.untyped)
end

Sprockets::Autoload::Sass = Sass

class Sprockets::Base
  include ::Sprockets::Dependencies
  include ::Sprockets::Compressing
  include ::Sprockets::Loader
  include ::Sprockets::DigestUtils
  include ::Sprockets::Transformers
  include ::Sprockets::PathDependencyUtils
  include ::Sprockets::Processing
  include ::Sprockets::Mime
  include ::Sprockets::Engines
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::PathDigestUtils
  include ::Sprockets::ProcessorUtils
end

module Sprockets::Bower
  POSSIBLE_BOWER_JSONS = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache
  PEEK_SIZE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache::FileStore
  DEFAULT_MAX_SIZE = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache::MemoryStore
  DEFAULT_MAX_SIZE = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache::NullStore
  def get(key); end

  def set(key, value); end
end

class Sprockets::Cache::NullStore
end

class Sprockets::ClosureCompressor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::CoffeeScriptProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::CoffeeScriptTemplate
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::CoffeeScriptTemplate
  def self.cache_key(); end

  def self.call(*args); end
end

module Sprockets::Configuration
  include ::Sprockets::Dependencies
  include ::Sprockets::Compressing
  include ::Sprockets::Processing
  include ::Sprockets::Transformers
  include ::Sprockets::Engines
  include ::Sprockets::Mime
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::PathDigestUtils
  include ::Sprockets::ProcessorUtils
  include ::Sprockets::HTTPUtils
  include ::Sprockets::DigestUtils
end

module Sprockets::Dependencies
  include ::Sprockets::URIUtils
  include ::Sprockets::PathDigestUtils
  include ::Sprockets::PathUtils
end

module Sprockets::DigestUtils
  DIGEST_SIZES = ::T.let(nil, ::T.untyped)
  HASH_ALGORITHMS = ::T.let(nil, ::T.untyped)
end

class Sprockets::DirectiveProcessor
  DIRECTIVE_PATTERN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::ERBTemplate
  def call(*args); end
end

class Sprockets::ERBTemplate
end

module Sprockets::EcoProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::EcoTemplate
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::EcoTemplate
  def self.cache_key(); end

  def self.call(*args); end
end

module Sprockets::EjsProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::EjsTemplate
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::EjsTemplate
  def self.cache_key(); end

  def self.call(*args); end
end

module Sprockets::EncodingUtils
  BOM = ::T.let(nil, ::T.untyped)
  CHARSET_DETECT = ::T.let(nil, ::T.untyped)
  CHARSET_SIZE = ::T.let(nil, ::T.untyped)
  CHARSET_START = ::T.let(nil, ::T.untyped)
end

Sprockets::Index = Sprockets::CachedEnvironment

class Sprockets::LegacyProcProcessor
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Sprockets::LegacyTiltProcessor
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Sprockets::Loader
  include ::Sprockets::Transformers
  include ::Sprockets::Resolve
  include ::Sprockets::PathDependencyUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::Processing
  include ::Sprockets::Mime
  include ::Sprockets::URIUtils
  include ::Sprockets::ProcessorUtils
  include ::Sprockets::HTTPUtils
end

module Sprockets::ManifestUtils
  LEGACY_MANIFEST_RE = ::T.let(nil, ::T.untyped)
  MANIFEST_RE = ::T.let(nil, ::T.untyped)
end

module Sprockets::Mime
  include ::Sprockets::Utils
end

module Sprockets::PathDigestUtils
  include ::Sprockets::PathUtils
end

module Sprockets::PathUtils
  SEPARATOR_PATTERN = ::T.let(nil, ::T.untyped)
end

module Sprockets::Paths
  include ::Sprockets::Utils
end

module Sprockets::Processing
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
end

module Sprockets::ProcessorUtils
  VALID_METADATA_COMPOUND_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_COMPOUND_TYPES_HASH = ::T.let(nil, ::T.untyped)
  VALID_METADATA_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_VALUE_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_VALUE_TYPES_HASH = ::T.let(nil, ::T.untyped)
end

module Sprockets::Rails
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::Rails::Helper
  VIEW_ACCESSORS = ::T.let(nil, ::T.untyped)
end

class Sprockets::Railtie
  LOOSE_APP_ASSETS = ::T.let(nil, ::T.untyped)
end

module Sprockets::Resolve
  include ::Sprockets::PathDependencyUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::URIUtils
end

class Sprockets::SassCompressor
  VERSION = ::T.let(nil, ::T.untyped)
end

Sprockets::SassFunctions = Sprockets::SassProcessor::Functions

class Sprockets::SassProcessor::CacheStore
  def initialize(cache, version); end

  def path_to(key); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::SassProcessor::CacheStore
end

class Sprockets::SassTemplate
end

class Sprockets::SassTemplate
  def self.call(*args); end
end

class Sprockets::ScssTemplate
end

class Sprockets::ScssTemplate
  def self.call(*args); end
end

module Sprockets::Transformers
  include ::Sprockets::Utils
  include ::Sprockets::ProcessorUtils
end

class Sprockets::UglifierCompressor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::Utils
  UNBOUND_METHODS_BIND_TO_ANY_OBJECT = ::T.let(nil, ::T.untyped)
end

class Sprockets::Utils::Gzip
  COMPRESSABLE_MIME_TYPES = ::T.let(nil, ::T.untyped)
end

class Sprockets::YUICompressor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets
  extend ::Sprockets::Dependencies
  extend ::Sprockets::Compressing
  extend ::Sprockets::Processing
  extend ::Sprockets::Transformers
  extend ::Sprockets::Engines
  extend ::Sprockets::Mime
  extend ::Sprockets::Utils
  extend ::Sprockets::URIUtils
  extend ::Sprockets::PathDigestUtils
  extend ::Sprockets::HTTPUtils
  extend ::Sprockets::DigestUtils
end

class StopIteration
  def result(); end
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def []=(*_); end

  def casecmp?(_); end

  def each_grapheme_cluster(); end

  def encode!(*_); end

  def funcall_style(); end

  def grapheme_clusters(); end

  def parse_csv(**options); end

  def quote(); end

  def reverse!(); end

  def sans_arguments(); end

  def shell_split(); end

  def shellescape(); end

  def shellsplit(); end

  def succ!(); end

  def to_d(); end

  def tr_cpp(); end

  def undump(); end

  def unicode_normalize(*_); end

  def unicode_normalize!(*_); end

  def unicode_normalized?(*_); end

  def unpack1(fmt); end

  def unspace(); end
  BLANK_RE = ::T.let(nil, ::T.untyped)
  ENCODED_BLANKS = ::T.let(nil, ::T.untyped)
end

module StringDirection
  BIDI = ::T.let(nil, ::T.untyped)
  LTR = ::T.let(nil, ::T.untyped)
  RTL = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class StringDirection::CharactersStrategy
  IGNORED_CHARS = ::T.let(nil, ::T.untyped)
end

class StringDirection::MarksStrategy
  LTR_MARK = ::T.let(nil, ::T.untyped)
  RTL_MARK = ::T.let(nil, ::T.untyped)
end

class StringIO
  def length(); end

  def set_encoding_by_bom(); end

  def truncate(_); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class StringScanner
  def <<(_); end

  def [](_); end

  def beginning_of_line?(); end

  def bol?(); end

  def captures(); end

  def charpos(); end

  def check(_); end

  def check_until(_); end

  def clear(); end

  def concat(_); end

  def empty?(); end

  def exist?(_); end

  def fixed_anchor?(); end

  def get_byte(); end

  def getbyte(); end

  def initialize(*_); end

  def match?(_); end

  def matched(); end

  def matched?(); end

  def matched_size(); end

  def peek(_); end

  def peep(_); end

  def pointer(); end

  def pointer=(pointer); end

  def pos(); end

  def pos=(pos); end

  def post_match(); end

  def pre_match(); end

  def reset(); end

  def rest(); end

  def rest?(); end

  def rest_size(); end

  def restsize(); end

  def scan_full(_, _1, _2); end

  def scan_until(_); end

  def search_full(_, _1, _2); end

  def size(); end

  def skip(_); end

  def skip_until(_); end

  def string(); end

  def string=(string); end

  def terminate(); end

  def unscan(); end

  def values_at(*_); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class StringScanner
  def self.must_C_version(); end
end

class Struct
  def [](_); end

  def []=(_, _1); end

  def deconstruct(); end

  def deconstruct_keys(_); end

  def dig(*_); end

  def each_pair(); end

  def filter(*_); end

  def length(); end

  def members(); end

  def select(*_); end

  def size(); end

  def to_a(); end

  def to_h(); end

  def values(); end

  def values_at(*_); end
end

class Struct::CompletionJourneyData
  def list(); end

  def list=(_); end

  def pointer(); end

  def pointer=(_); end

  def postposing(); end

  def postposing=(_); end

  def preposing(); end

  def preposing=(_); end
end

class Struct::CompletionJourneyData
  def self.[](*_); end

  def self.members(); end
end

Struct::Group = Etc::Group

class Struct::Key
  def char(); end

  def char=(_); end

  def combined_char(); end

  def combined_char=(_); end

  def with_meta(); end

  def with_meta=(_); end
end

class Struct::Key
  def self.[](*_); end

  def self.members(); end
end

class Struct::MenuInfo
  def list(); end

  def list=(_); end

  def target(); end

  def target=(_); end
end

class Struct::MenuInfo
  def self.[](*_); end

  def self.members(); end
end

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class SynchronizedDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class SystemCallError
  def errno(); end
end

class SystemExit
  def status(); end

  def success?(); end
end

module TZInfo::RubyCoreSupport
  HALF_DAYS_IN_DAY = ::T.let(nil, ::T.untyped)
end

class TZInfo::ZoneinfoDataSource
  DEFAULT_ALTERNATE_ISO3166_TAB_SEARCH_PATH = ::T.let(nil, ::T.untyped)
  DEFAULT_SEARCH_PATH = ::T.let(nil, ::T.untyped)
end

class TZInfo::ZoneinfoTimezoneInfo
  MAX_TIMESTAMP = ::T.let(nil, ::T.untyped)
  MIN_TIMESTAMP = ::T.let(nil, ::T.untyped)
end

class Tag
  include ::Tag::GeneratedAttributeMethods
  include ::Tag::GeneratedAssociationMethods
  def after_add_for_locations(); end

  def after_add_for_locations=(val); end

  def after_add_for_locations?(); end

  def after_add_for_locations_tags(); end

  def after_add_for_locations_tags=(val); end

  def after_add_for_locations_tags?(); end

  def after_add_for_mtransactions(); end

  def after_add_for_mtransactions=(val); end

  def after_add_for_mtransactions?(); end

  def after_remove_for_locations(); end

  def after_remove_for_locations=(val); end

  def after_remove_for_locations?(); end

  def after_remove_for_locations_tags(); end

  def after_remove_for_locations_tags=(val); end

  def after_remove_for_locations_tags?(); end

  def after_remove_for_mtransactions(); end

  def after_remove_for_mtransactions=(val); end

  def after_remove_for_mtransactions?(); end

  def autosave_associated_records_for_category(*args); end

  def autosave_associated_records_for_locations(*args); end

  def autosave_associated_records_for_locations_tags(*args); end

  def autosave_associated_records_for_mtransactions(*args); end

  def before_add_for_locations(); end

  def before_add_for_locations=(val); end

  def before_add_for_locations?(); end

  def before_add_for_locations_tags(); end

  def before_add_for_locations_tags=(val); end

  def before_add_for_locations_tags?(); end

  def before_add_for_mtransactions(); end

  def before_add_for_mtransactions=(val); end

  def before_add_for_mtransactions?(); end

  def before_remove_for_locations(); end

  def before_remove_for_locations=(val); end

  def before_remove_for_locations?(); end

  def before_remove_for_locations_tags(); end

  def before_remove_for_locations_tags=(val); end

  def before_remove_for_locations_tags?(); end

  def before_remove_for_mtransactions(); end

  def before_remove_for_mtransactions=(val); end

  def before_remove_for_mtransactions?(); end

  def validate_associated_records_for_locations(*args); end

  def validate_associated_records_for_locations_tags(*args); end

  def validate_associated_records_for_mtransactions(*args); end
end

class Tag::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Tag::GeneratedRelationMethods
end

class Tag::ActiveRecord_AssociationRelation
end

class Tag::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Tag::GeneratedRelationMethods
end

class Tag::ActiveRecord_Associations_CollectionProxy
end

class Tag::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Tag::GeneratedRelationMethods
end

class Tag::ActiveRecord_Relation
end

module Tag::GeneratedAssociationMethods
  def build_category(*args, &block); end

  def category(); end

  def category=(value); end

  def create_category(*args, &block); end

  def create_category!(*args, &block); end

  def location_ids(); end

  def location_ids=(ids); end

  def locations(); end

  def locations=(value); end

  def mtransaction_ids(); end

  def mtransaction_ids=(ids); end

  def mtransactions(); end

  def mtransactions=(value); end

  def reload_category(); end
end

module Tag::GeneratedAssociationMethods
end

module Tag::GeneratedAttributeMethods
end

module Tag::GeneratedAttributeMethods
  extend ::Mutex_m
end

module Tag::GeneratedRelationMethods
end

module Tag::GeneratedRelationMethods
  extend ::Mutex_m
end

class Tag
  def self.after_add_for_locations(); end

  def self.after_add_for_locations=(val); end

  def self.after_add_for_locations?(); end

  def self.after_add_for_locations_tags(); end

  def self.after_add_for_locations_tags=(val); end

  def self.after_add_for_locations_tags?(); end

  def self.after_add_for_mtransactions(); end

  def self.after_add_for_mtransactions=(val); end

  def self.after_add_for_mtransactions?(); end

  def self.after_remove_for_locations(); end

  def self.after_remove_for_locations=(val); end

  def self.after_remove_for_locations?(); end

  def self.after_remove_for_locations_tags(); end

  def self.after_remove_for_locations_tags=(val); end

  def self.after_remove_for_locations_tags?(); end

  def self.after_remove_for_mtransactions(); end

  def self.after_remove_for_mtransactions=(val); end

  def self.after_remove_for_mtransactions?(); end

  def self.before_add_for_locations(); end

  def self.before_add_for_locations=(val); end

  def self.before_add_for_locations?(); end

  def self.before_add_for_locations_tags(); end

  def self.before_add_for_locations_tags=(val); end

  def self.before_add_for_locations_tags?(); end

  def self.before_add_for_mtransactions(); end

  def self.before_add_for_mtransactions=(val); end

  def self.before_add_for_mtransactions?(); end

  def self.before_remove_for_locations(); end

  def self.before_remove_for_locations=(val); end

  def self.before_remove_for_locations?(); end

  def self.before_remove_for_locations_tags(); end

  def self.before_remove_for_locations_tags=(val); end

  def self.before_remove_for_locations_tags?(); end

  def self.before_remove_for_mtransactions(); end

  def self.before_remove_for_mtransactions=(val); end

  def self.before_remove_for_mtransactions?(); end
end

class Tempfile
  def _close(); end

  def inspect(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

Test = Minitest::Parallel::Test

class Thor
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
end

class Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Thor::Actions::CreateFile
end

class Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Thor::Actions::EmptyDirectory
end

module Thor::Actions
  def self.included(base); end
end

Thor::AmbiguousTaskError = Thor::AmbiguousCommandError

class Thor::Argument
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Thor::Arguments
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Thor::Command
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

Thor::Correctable = DidYouMean::Correctable

Thor::DynamicTask = Thor::DynamicCommand

class Thor::Group
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

Thor::HiddenTask = Thor::HiddenCommand

class Thor::Option
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Thor::Options
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

module Thor::RakeCompat
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Thor::RakeCompat
  def self.included(base); end

  def self.rake_classes(); end
end

module Thor::Shell
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

Thor::Task = Thor::Command

class Thor::UndefinedCommandError
  include ::DidYouMean::Correctable
end

Thor::UndefinedTaskError = Thor::UndefinedCommandError

class Thor::UnknownArgumentError
  include ::DidYouMean::Correctable
end

module ThreadSafe
  NULL = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

ThreadSafe::Array = Array

class ThreadSafe::AtomicReferenceCacheBackend
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def compute(key); end

  def compute_if_absent(key); end

  def compute_if_present(key); end

  def delete(key); end

  def delete_pair(key, value); end

  def each_pair(); end

  def empty?(); end

  def get_and_set(key, value); end

  def get_or_default(key, else_value=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def key?(key); end

  def merge_pair(key, value); end

  def replace_if_exists(key, new_value); end

  def replace_pair(key, old_value, new_value); end

  def size(); end
  DEFAULT_CAPACITY = ::T.let(nil, ::T.untyped)
  HASH_BITS = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MAX_CAPACITY = ::T.let(nil, ::T.untyped)
  MOVED = ::T.let(nil, ::T.untyped)
  NOW_RESIZING = ::T.let(nil, ::T.untyped)
  TRANSFER_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  WAITING = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::AtomicReferenceCacheBackend::Node
  include ::ThreadSafe::Util::CheapLockable
  def initialize(hash, key, value, next_node=T.unsafe(nil)); end

  def key(); end

  def key?(key); end

  def locked?(); end

  def matches?(key, hash); end

  def pure_hash(); end

  def try_await_lock(table, i); end

  def try_lock_via_hash(node_hash=T.unsafe(nil)); end

  def unlock_via_hash(locked_hash, node_hash); end
  HASH_BITS = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MOVED = ::T.let(nil, ::T.untyped)
  SPIN_LOCK_ATTEMPTS = ::T.let(nil, ::T.untyped)
  WAITING = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::AtomicReferenceCacheBackend::Node
  extend ::ThreadSafe::Util::Volatile
  def self.locked_hash?(hash); end
end

class ThreadSafe::AtomicReferenceCacheBackend::Table
  def cas_new_node(i, hash, key, value); end

  def delete_node_at(i, node, predecessor_node); end

  def try_lock_via_hash(i, node, node_hash); end

  def try_to_cas_in_computed(i, hash, key); end
end

class ThreadSafe::AtomicReferenceCacheBackend::Table
end

class ThreadSafe::AtomicReferenceCacheBackend
  extend ::ThreadSafe::Util::Volatile
end

ThreadSafe::ConcurrentCacheBackend = ThreadSafe::MriCacheBackend

ThreadSafe::Hash = Hash

class ThreadSafe::MriCacheBackend
  WRITE_LOCK = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::SynchronizedCacheBackend
  include ::Mutex_m
  def lock(); end

  def locked?(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class ThreadSafe::SynchronizedCacheBackend
end

module ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::Util::Adder
  def add(x); end

  def decrement(); end

  def increment(); end

  def reset(); end

  def sum(); end
end

class ThreadSafe::Util::Adder
end

class ThreadSafe::Util::AtomicReference
  def compare_and_set(old_value, new_value); end

  def get(); end

  def initialize(value=T.unsafe(nil)); end

  def set(new_value); end

  def value(); end

  def value=(new_value); end
end

class ThreadSafe::Util::AtomicReference
end

module ThreadSafe::Util::CheapLockable
  def cas_mutex(old_value, new_value); end

  def compare_and_set_mutex(old_value, new_value); end

  def lazy_set_mutex(value); end

  def mutex(); end

  def mutex=(value); end
end

module ThreadSafe::Util::CheapLockable
  extend ::ThreadSafe::Util::Volatile
end

class ThreadSafe::Util::PowerOfTwoTuple
  def hash_to_index(hash); end

  def next_in_size_table(); end

  def volatile_get_by_hash(hash); end

  def volatile_set_by_hash(hash, value); end
end

class ThreadSafe::Util::PowerOfTwoTuple
end

class ThreadSafe::Util::Striped64
  def busy?(); end

  def initialize(); end

  def retry_update(x, hash_code, was_uncontended); end
  THREAD_LOCAL_KEY = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::Util::Striped64::Cell
  def cas(old_value, new_value); end

  def cas_computed(); end

  def padding_(); end
end

class ThreadSafe::Util::Striped64::Cell
end

class ThreadSafe::Util::Striped64
  extend ::ThreadSafe::Util::Volatile
end

module ThreadSafe::Util::Volatile
  def attr_volatile(*attr_names); end
end

module ThreadSafe::Util::Volatile
end

class ThreadSafe::Util::VolatileTuple
  include ::Enumerable
  def cas(i, old_value, new_value); end

  def compare_and_set(i, old_value, new_value); end

  def each(&blk); end

  def initialize(size); end

  def size(); end

  def volatile_get(i); end

  def volatile_set(i, value); end
end

class ThreadSafe::Util::VolatileTuple
end

module ThreadSafe::Util::XorShiftRandom
  def get(); end

  def xorshift(x); end
  MAX_XOR_SHIFTABLE_INT = ::T.let(nil, ::T.untyped)
end

module ThreadSafe::Util::XorShiftRandom
  extend ::ThreadSafe::Util::XorShiftRandom
end

module ThreadSafe::Util
end

module Tilt
  LOCK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Tilt::BuilderTemplate
  def precompiled_postamble(locals); end

  def precompiled_template(locals); end
end

class Tilt::BuilderTemplate
end

class Tilt::CSVTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::CSVTemplate
  def self.engine(); end
end

class Tilt::ERBTemplate
  def precompiled(locals); end

  def precompiled_postamble(locals); end

  def precompiled_preamble(locals); end

  def precompiled_template(locals); end
  SUPPORTS_KVARGS = ::T.let(nil, ::T.untyped)
end

class Tilt::ERBTemplate
  def self.default_output_variable(); end

  def self.default_output_variable=(name); end
end

class Tilt::ErubiTemplate
  def precompiled_template(locals); end
end

class Tilt::ErubiTemplate
end

class Tilt::EtanniTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::EtanniTemplate
end

class Tilt::Mapping
  AUTOLOAD_IS_BROKEN = ::T.let(nil, ::T.untyped)
  LOCK = ::T.let(nil, ::T.untyped)
end

class Tilt::MarukuTemplate
  def allows_script?(); end
end

class Tilt::MarukuTemplate
end

class Tilt::NokogiriTemplate
  def evaluate(scope, locals); end

  def precompiled_postamble(locals); end

  def precompiled_preamble(locals); end

  def precompiled_template(locals); end
  DOCUMENT_HEADER = ::T.let(nil, ::T.untyped)
end

class Tilt::NokogiriTemplate
end

class Tilt::PlainTemplate
end

class Tilt::PlainTemplate
end

class Tilt::RDocTemplate
  def allows_script?(); end

  def markup(); end
end

class Tilt::RDocTemplate
end

class Tilt::SassTemplate
  def allows_script?(); end
end

Tilt::SassTemplate::Sass = Sass

class Tilt::SassTemplate
end

class Tilt::ScssTemplate
end

class Tilt::ScssTemplate
end

class Tilt::SigilTemplate
  def allows_script?(); end
end

class Tilt::SigilTemplate
end

class Tilt::StringTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::StringTemplate
end

Tilt::TOPOBJECT = Tilt::CompiledTemplates

class Time
  COMMON_YEAR_DAYS_IN_MONTH = ::T.let(nil, ::T.untyped)
  DATE_FORMATS = ::T.let(nil, ::T.untyped)
end

class TracePoint
  def eval_script(); end

  def event(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TracePoint
  def self.new(*events); end
end

class TransactionFile
  def autosave_associated_records_for_file_attachment(); end

  def autosave_associated_records_for_file_blob(); end
end

class TransactionFile::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::TransactionFile::GeneratedRelationMethods
end

class TransactionFile::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::TransactionFile::GeneratedRelationMethods
end

class TransactionFile::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::TransactionFile::GeneratedRelationMethods
end

module TransactionFile::GeneratedAssociationMethods
  def build_file_attachment(*args, &block); end

  def create_file_attachment(*args, &block); end

  def create_file_attachment!(*args, &block); end

  def reload_file_attachment(); end

  def reload_file_blob(); end
end

module TransactionFile::GeneratedAttributeMethods
  extend ::Mutex_m
end

module TransactionFile::GeneratedRelationMethods
  def with_attached_file(*args, &block); end
end

module TransactionFile::GeneratedRelationMethods
  extend ::Mutex_m
end

class TransferTransaction
  include ::TransferTransaction::GeneratedAttributeMethods
  include ::TransferTransaction::GeneratedAssociationMethods
  def autosave_associated_records_for_from_account(*args); end

  def autosave_associated_records_for_to_account(*args); end
end

class TransferTransaction::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::TransferTransaction::GeneratedRelationMethods
end

class TransferTransaction::ActiveRecord_AssociationRelation
end

class TransferTransaction::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::TransferTransaction::GeneratedRelationMethods
end

class TransferTransaction::ActiveRecord_Associations_CollectionProxy
end

class TransferTransaction::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::TransferTransaction::GeneratedRelationMethods
end

class TransferTransaction::ActiveRecord_Relation
end

module TransferTransaction::GeneratedAssociationMethods
  def build_from_account(*args, &block); end

  def build_to_account(*args, &block); end

  def create_from_account(*args, &block); end

  def create_from_account!(*args, &block); end

  def create_to_account(*args, &block); end

  def create_to_account!(*args, &block); end

  def from_account(); end

  def from_account=(value); end

  def reload_from_account(); end

  def reload_to_account(); end

  def to_account(); end

  def to_account=(value); end
end

module TransferTransaction::GeneratedAssociationMethods
end

module TransferTransaction::GeneratedAttributeMethods
end

module TransferTransaction::GeneratedAttributeMethods
  extend ::Mutex_m
end

module TransferTransaction::GeneratedRelationMethods
end

module TransferTransaction::GeneratedRelationMethods
  extend ::Mutex_m
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
end

module Turbolinks
  VERSION = ::T.let(nil, ::T.untyped)
end

module Turbolinks::Assertions
  TURBOLINKS_VISIT = ::T.let(nil, ::T.untyped)
end

module Turbolinks::Source
  VERSION = ::T.let(nil, ::T.untyped)
end

module URI
  include ::URI::RFC2396_REGEXP
end

module URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

class URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::File
end

class URI::GID
  COMPONENT = ::T.let(nil, ::T.untyped)
  PATH_REGEXP = ::T.let(nil, ::T.untyped)
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.get_encoding(label); end

end

class UnboundMethod
  def bind_call(*_); end

  def clone(); end

  def original_name(); end
end

class UncaughtThrowError
  def tag(); end

  def value(); end
end

module UnicodeNormalize
end

module UnicodeNormalize
end

class Vector
  include ::ExceptionForMatrix
  include ::Enumerable
  include ::Matrix::CoercionHelper
  def *(x); end

  def +(v); end

  def +@(); end

  def -(v); end

  def -@(); end

  def /(x); end

  def ==(other); end

  def [](i); end

  def []=(i, v); end

  def angle_with(v); end

  def coerce(other); end

  def collect(&block); end

  def collect!(&block); end

  def collect2(v); end

  def component(i); end

  def covector(); end

  def cross(*vs); end

  def cross_product(*vs); end

  def dot(v); end

  def each(&block); end

  def each2(v); end

  def element(i); end

  def elements(); end

  def elements_to_f(); end

  def elements_to_i(); end

  def elements_to_r(); end

  def eql?(other); end

  def independent?(*vs); end

  def initialize(array); end

  def inner_product(v); end

  def magnitude(); end

  def map(&block); end

  def map!(&block); end

  def map2(v, &block); end

  def norm(); end

  def normalize(); end

  def r(); end

  def round(ndigits=T.unsafe(nil)); end

  def size(); end

  def to_a(); end

  def to_matrix(); end

  def zero?(); end
end

class Vector::ZeroVectorError
end

class Vector::ZeroVectorError
end

class Vector
  extend ::Matrix::ConversionHelper
  def self.[](*array); end

  def self.basis(size:, index:); end

  def self.elements(array, copy=T.unsafe(nil)); end

  def self.independent?(*vs); end

  def self.zero(size); end
end

Visitor = Psych::Visitors::Visitor

module Warning
  def warn(_); end
end

module Warning
  extend ::Warning
  def self.[](_); end

  def self.[]=(_, _1); end
end

class WeakRef
  def initialize(orig); end

  def weakref_alive?(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class WeakRef::RefError
end

class WeakRef::RefError
end

class WeakRef
end

class WebConsole::Context
  def extract(input=T.unsafe(nil)); end

  def initialize(binding); end
  GLOBAL_OBJECTS = ::T.let(nil, ::T.untyped)
end

class WebConsole::Context
end

class WebConsole::DoubleRenderError
end

class WebConsole::DoubleRenderError
end

class WebConsole::Error
end

class WebConsole::Error
end

class WebConsole::Evaluator
  def cleaner(); end

  def eval(input); end

  def initialize(binding=T.unsafe(nil)); end
end

class WebConsole::Evaluator
  def self.cleaner(); end
end

class WebConsole::ExceptionMapper
  def [](index); end

  def exc(); end

  def first(); end

  def initialize(exception); end
end

class WebConsole::ExceptionMapper
  def self.find_binding(mappers, exception_object_id); end

  def self.follow(exc); end
end

class WebConsole::Injector
  def initialize(body, headers); end

  def inject(content); end
end

class WebConsole::Injector
end

class WebConsole::Middleware
  TEMPLATES_PATH = ::T.let(nil, ::T.untyped)
end

class WebConsole::Permissions
  ALWAYS_PERMITTED_NETWORKS = ::T.let(nil, ::T.untyped)
end

class WebConsole::Session
  def context(objpath); end

  def eval(input); end

  def id(); end

  def initialize(exception_mappers); end

  def inmemory_storage(); end

  def switch_binding_to(index, exception_object_id); end
end

class WebConsole::Session
  def self.find(id); end

  def self.from(storage); end

  def self.inmemory_storage(); end
end

class WebConsole::Template
  def initialize(env, session); end

  def render(template); end

  def template_paths(); end

  def template_paths=(obj); end
end

class WebConsole::Template
  def self.template_paths(); end

  def self.template_paths=(obj); end
end

class WebConsole::View
  def only_on_error_page(*args); end

  def only_on_regular_page(*args); end

  def render(*_); end

  def render_inlined_string(template); end

  def render_javascript(template); end
end

class WebConsole::View
end

class WebConsole::WhinyRequest
  def permitted?(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class WebConsole::WhinyRequest
end

module Webdrivers
  DEFAULT_CACHE_TIME = ::T.let(nil, ::T.untyped)
  DEFAULT_INSTALL_DIR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Webpacker::DevServer
  DEFAULT_ENV_PREFIX = ::T.let(nil, ::T.untyped)
end

class Webpacker::Env
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module XPath::DSL
  AXES = ::T.let(nil, ::T.untyped)
  LOWERCASE_LETTERS = ::T.let(nil, ::T.untyped)
  METHODS = ::T.let(nil, ::T.untyped)
  OPERATORS = ::T.let(nil, ::T.untyped)
  UPPERCASE_LETTERS = ::T.let(nil, ::T.untyped)
end

YAML = Psych

YAMLTree = Psych::Visitors::YAMLTree

module Zeitwerk::ExplicitNamespace
  extend ::Zeitwerk::RealModName
end

module Zip
  CDIR_ENTRY_STATIC_HEADER_LENGTH = ::T.let(nil, ::T.untyped)
  CENTRAL_DIRECTORY_ENTRY_SIGNATURE = ::T.let(nil, ::T.untyped)
  FILE_TYPE_DIR = ::T.let(nil, ::T.untyped)
  FILE_TYPE_FILE = ::T.let(nil, ::T.untyped)
  FILE_TYPE_SYMLINK = ::T.let(nil, ::T.untyped)
  FSTYPES = ::T.let(nil, ::T.untyped)
  FSTYPE_ACORN = ::T.let(nil, ::T.untyped)
  FSTYPE_AMIGA = ::T.let(nil, ::T.untyped)
  FSTYPE_ATARI = ::T.let(nil, ::T.untyped)
  FSTYPE_ATHEOS = ::T.let(nil, ::T.untyped)
  FSTYPE_BEOS = ::T.let(nil, ::T.untyped)
  FSTYPE_CPM = ::T.let(nil, ::T.untyped)
  FSTYPE_FAT = ::T.let(nil, ::T.untyped)
  FSTYPE_HPFS = ::T.let(nil, ::T.untyped)
  FSTYPE_MAC = ::T.let(nil, ::T.untyped)
  FSTYPE_MAC_OSX = ::T.let(nil, ::T.untyped)
  FSTYPE_MVS = ::T.let(nil, ::T.untyped)
  FSTYPE_NTFS = ::T.let(nil, ::T.untyped)
  FSTYPE_QDOS = ::T.let(nil, ::T.untyped)
  FSTYPE_TANDEM = ::T.let(nil, ::T.untyped)
  FSTYPE_THEOS = ::T.let(nil, ::T.untyped)
  FSTYPE_TOPS20 = ::T.let(nil, ::T.untyped)
  FSTYPE_UNIX = ::T.let(nil, ::T.untyped)
  FSTYPE_VFAT = ::T.let(nil, ::T.untyped)
  FSTYPE_VMS = ::T.let(nil, ::T.untyped)
  FSTYPE_VM_CMS = ::T.let(nil, ::T.untyped)
  FSTYPE_Z_SYSTEM = ::T.let(nil, ::T.untyped)
  LOCAL_ENTRY_SIGNATURE = ::T.let(nil, ::T.untyped)
  LOCAL_ENTRY_STATIC_HEADER_LENGTH = ::T.let(nil, ::T.untyped)
  LOCAL_ENTRY_TRAILING_DESCRIPTOR_LENGTH = ::T.let(nil, ::T.untyped)
  RUNNING_ON_WINDOWS = ::T.let(nil, ::T.untyped)
  VERSION_MADE_BY = ::T.let(nil, ::T.untyped)
  VERSION_NEEDED_TO_EXTRACT = ::T.let(nil, ::T.untyped)
  VERSION_NEEDED_TO_EXTRACT_ZIP64 = ::T.let(nil, ::T.untyped)
end

class Zip::CentralDirectory
  END_OF_CDS = ::T.let(nil, ::T.untyped)
  MAX_END_OF_CDS_SIZE = ::T.let(nil, ::T.untyped)
  STATIC_EOCD_SIZE = ::T.let(nil, ::T.untyped)
  ZIP64_END_OF_CDS = ::T.let(nil, ::T.untyped)
  ZIP64_EOCD_LOCATOR = ::T.let(nil, ::T.untyped)
end

class Zip::Decompressor
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
end

class Zip::Entry
  DEFLATED = ::T.let(nil, ::T.untyped)
  EFS = ::T.let(nil, ::T.untyped)
  STORED = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField
  ID_MAP = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::IUnix
  HEADER_ID = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::NTFS
  HEADER_ID = ::T.let(nil, ::T.untyped)
  SEC_TO_UNIX_EPOCH = ::T.let(nil, ::T.untyped)
  WINDOWS_TICK = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::OldUnix
  HEADER_ID = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::UniversalTime
  HEADER_ID = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::Zip64
  HEADER_ID = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::Zip64Placeholder
  HEADER_ID = ::T.let(nil, ::T.untyped)
end

class Zip::File
  CREATE = ::T.let(nil, ::T.untyped)
  DATA_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  IO_METHODS = ::T.let(nil, ::T.untyped)
  MAX_SEGMENT_SIZE = ::T.let(nil, ::T.untyped)
  MIN_SEGMENT_SIZE = ::T.let(nil, ::T.untyped)
  SPLIT_SIGNATURE = ::T.let(nil, ::T.untyped)
  ZIP64_EOCD_SIGNATURE = ::T.let(nil, ::T.untyped)
end

module Zip::IOExtras
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
  RANGE_ALL = ::T.let(nil, ::T.untyped)
end

module Zip::IOExtras::AbstractInputStream
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

module Zip::NullInputStream
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Zip::StreamableStream
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

Zip::ZipCompressionMethodError = Zip::CompressionMethodError

Zip::ZipDestinationFileExistsError = Zip::DestinationFileExistsError

Zip::ZipEntryExistsError = Zip::EntryExistsError

Zip::ZipEntryNameError = Zip::EntryNameError

Zip::ZipError = Zip::Error

Zip::ZipInternalError = Zip::InternalError

module Zlib
  ASCII = ::T.let(nil, ::T.untyped)
  BEST_COMPRESSION = ::T.let(nil, ::T.untyped)
  BEST_SPEED = ::T.let(nil, ::T.untyped)
  BINARY = ::T.let(nil, ::T.untyped)
  DEFAULT_COMPRESSION = ::T.let(nil, ::T.untyped)
  DEFAULT_STRATEGY = ::T.let(nil, ::T.untyped)
  DEF_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  FILTERED = ::T.let(nil, ::T.untyped)
  FINISH = ::T.let(nil, ::T.untyped)
  FIXED = ::T.let(nil, ::T.untyped)
  FULL_FLUSH = ::T.let(nil, ::T.untyped)
  HUFFMAN_ONLY = ::T.let(nil, ::T.untyped)
  MAX_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  MAX_WBITS = ::T.let(nil, ::T.untyped)
  NO_COMPRESSION = ::T.let(nil, ::T.untyped)
  NO_FLUSH = ::T.let(nil, ::T.untyped)
  OS_AMIGA = ::T.let(nil, ::T.untyped)
  OS_ATARI = ::T.let(nil, ::T.untyped)
  OS_CODE = ::T.let(nil, ::T.untyped)
  OS_CPM = ::T.let(nil, ::T.untyped)
  OS_MACOS = ::T.let(nil, ::T.untyped)
  OS_MSDOS = ::T.let(nil, ::T.untyped)
  OS_OS2 = ::T.let(nil, ::T.untyped)
  OS_QDOS = ::T.let(nil, ::T.untyped)
  OS_RISCOS = ::T.let(nil, ::T.untyped)
  OS_TOPS20 = ::T.let(nil, ::T.untyped)
  OS_UNIX = ::T.let(nil, ::T.untyped)
  OS_UNKNOWN = ::T.let(nil, ::T.untyped)
  OS_VMCMS = ::T.let(nil, ::T.untyped)
  OS_VMS = ::T.let(nil, ::T.untyped)
  OS_WIN32 = ::T.let(nil, ::T.untyped)
  OS_ZSYSTEM = ::T.let(nil, ::T.untyped)
  RLE = ::T.let(nil, ::T.untyped)
  SYNC_FLUSH = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  ZLIB_VERSION = ::T.let(nil, ::T.untyped)
end

class Zlib::BufError
end

class Zlib::BufError
end

class Zlib::DataError
end

class Zlib::DataError
end

class Zlib::Deflate
  def <<(_); end

  def deflate(*_); end

  def flush(*_); end

  def initialize(*_); end

  def params(_, _1); end

  def set_dictionary(_); end
end

class Zlib::Deflate
  def self.deflate(*_); end
end

class Zlib::Error
end

class Zlib::Error
end

class Zlib::GzipFile
  def close(); end

  def closed?(); end

  def comment(); end

  def crc(); end

  def finish(); end

  def level(); end

  def mtime(); end

  def orig_name(); end

  def os_code(); end

  def sync(); end

  def sync=(sync); end

  def to_io(); end
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::Error
  def input(); end
end

class Zlib::GzipFile::Error
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile
  def self.wrap(*_); end
end

class Zlib::GzipReader
  include ::Enumerable
  def bytes(); end

  def each(*_, &blk); end

  def each_byte(); end

  def each_char(); end

  def each_line(*_); end

  def eof(); end

  def eof?(); end

  def external_encoding(); end

  def getbyte(); end

  def getc(); end

  def initialize(*_); end

  def lineno(); end

  def lineno=(lineno); end

  def lines(*_); end

  def pos(); end

  def read(*_); end

  def readbyte(); end

  def readchar(); end

  def readpartial(*_); end

  def rewind(); end

  def tell(); end

  def ungetbyte(_); end

  def ungetc(_); end

  def unused(); end
end

class Zlib::GzipReader
end

class Zlib::GzipWriter
  def <<(_); end

  def comment=(comment); end

  def flush(*_); end

  def initialize(*_); end

  def mtime=(mtime); end

  def orig_name=(orig_name); end

  def pos(); end

  def tell(); end

  def write(*_); end
end

class Zlib::GzipWriter
end

class Zlib::Inflate
  def <<(_); end

  def add_dictionary(_); end

  def inflate(_); end

  def initialize(*_); end

  def set_dictionary(_); end

  def sync(_); end

  def sync_point?(); end
end

class Zlib::Inflate
  def self.inflate(_); end
end

class Zlib::MemError
end

class Zlib::MemError
end

class Zlib::NeedDict
end

class Zlib::NeedDict
end

class Zlib::StreamEnd
end

class Zlib::StreamEnd
end

class Zlib::StreamError
end

class Zlib::StreamError
end

class Zlib::VersionError
end

class Zlib::VersionError
end

class Zlib::ZStream
  def adler(); end

  def avail_in(); end

  def avail_out(); end

  def avail_out=(avail_out); end

  def close(); end

  def closed?(); end

  def data_type(); end

  def end(); end

  def ended?(); end

  def finish(); end

  def finished?(); end

  def flush_next_in(); end

  def flush_next_out(); end

  def reset(); end

  def stream_end?(); end

  def total_in(); end

  def total_out(); end
end

class Zlib::ZStream
end

module Zlib
  def self.adler32(*_); end

  def self.adler32_combine(_, _1, _2); end

  def self.crc32(*_); end

  def self.crc32_combine(_, _1, _2); end

  def self.crc_table(); end

  def self.deflate(*_); end

  def self.gunzip(_); end

  def self.gzip(*_); end

  def self.inflate(_); end

  def self.zlib_version(); end
end
