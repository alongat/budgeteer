# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strong
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/readapt/all/readapt.rbi
#
# readapt-0.8.1
module Readapt
  def self.normalize_path(arg0); end
end
module Readapt::Breakpoints
  def self.clear; end
  def self.delete(arg0); end
  def self.match(arg0, arg1); end
  def self.set(arg0, arg1); end
end
class Readapt::Frame < Data
  def evaluate(code); end
  def file; end
  def frame_binding; end
  def initialize(arg0, arg1, arg2); end
  def line; end
  def local(sym); end
  def local_id; end
  def locals; end
end
class Readapt::Thread < Data
  def control; end
  def control=(arg0); end
  def frames; end
  def id; end
  def name; end
  def object; end
  def self.all; end
  def self.find(arg0); end
  def self.include?(arg0); end
end
module Readapt::Monitor
  def self.pause(arg0); end
  def self.start(arg0); end
  def self.stop; end
end
class Readapt::Breakpoint
  def condition; end
  def hit_condition; end
  def hit_cursor; end
  def hit_cursor=(arg0); end
  def initialize(source, line, condition, hit_condition); end
  def line; end
  def source; end
end
class Readapt::Snapshot
  def control; end
  def control=(arg0); end
  def event; end
  def file; end
  def initialize(thread_id, file, line, event); end
  def line; end
  def thread_id; end
end
module Readapt::Finder
  def find(program); end
  def self.find(program); end
  def self.which(program); end
  def which(program); end
end
class Readapt::Debugger
  def attached?; end
  def clear_breakpoints(source); end
  def config(arguments, request); end
  def debug(snapshot); end
  def disconnect; end
  def file; end
  def frame(id); end
  def get_breakpoint(source, line); end
  def initialize(machine = nil); end
  def launched?; end
  def monitor; end
  def output(data, category = nil); end
  def run; end
  def self.run(&block); end
  def send_event(event, data, wait = nil); end
  def set_breakpoint(source, line, condition, hitcount); end
  def set_original_args; end
  def set_program_args; end
  def shutdown; end
  def start; end
  def thread(id); end
  def threads; end
  include Observable
  include Readapt::Finder
end
module Readapt::Message
  def self.process(arguments, debugger); end
  def self.register(name, klass); end
end
class Readapt::Message::Base
  def arguments; end
  def body; end
  def debugger; end
  def initialize(arguments, debugger); end
  def run; end
  def self.run(arguments, debugger); end
  def set_body(hash); end
end
class Readapt::Message::Initialize < Readapt::Message::Base
  def run; end
end
class Readapt::Message::Launch < Readapt::Message::Base
  def run; end
end
class Readapt::Message::SetBreakpoints < Readapt::Message::Base
  def run; end
end
class Readapt::Message::SetExceptionBreakpoints < Readapt::Message::Base
end
class Readapt::Message::ConfigurationDone < Readapt::Message::Base
  def run; end
end
class Readapt::Message::Threads < Readapt::Message::Base
  def run; end
end
class Readapt::Message::StackTrace < Readapt::Message::Base
  def frame_code(file, line); end
  def read_file(file); end
  def run; end
end
class Readapt::Message::Scopes < Readapt::Message::Base
  def run; end
end
class Readapt::Message::Continue < Readapt::Message::Base
  def run; end
end
class Readapt::Message::Variables < Readapt::Message::Base
  def object_reference; end
  def run; end
end
class Readapt::Message::Next < Readapt::Message::Base
  def run; end
end
class Readapt::Message::StepIn < Readapt::Message::Base
  def run; end
end
class Readapt::Message::StepOut < Readapt::Message::Base
  def run; end
end
class Readapt::Message::Disconnect < Readapt::Message::Base
  def run; end
end
class Readapt::Message::Attach < Readapt::Message::Base
  def run; end
end
class Readapt::Message::Pause < Readapt::Message::Base
  def run; end
end
class Readapt::Message::Evaluate < Readapt::Message::Base
  def run; end
end
class Readapt::Variable
  def empty?; end
  def enumerable?; end
  def initialize(name, object); end
  def name; end
  def no_references?; end
  def object; end
  def reference; end
  def show_class_for_value?; end
  def type; end
  def unstructured; end
  def value; end
end
module Readapt::Adapter
  def closing; end
  def format(result); end
  def opening; end
  def process(data); end
  def receiving(data); end
  def self.host(debugger); end
  def update(event, data); end
end
class Readapt::DataReader
  def initialize; end
  def parse_message_from_buffer; end
  def prepare_to_parse_message; end
  def receive(data); end
  def set_message_handler(&block); end
end
class Readapt::Shell < Thor
end
