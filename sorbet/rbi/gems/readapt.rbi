# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strong
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/readapt/all/readapt.rbi
#
# readapt-0.7.1
module Readapt
  def self.normalize_path(arg0); end
end
class Readapt::Breakpoint
  def condition; end
  def initialize(source, line, condition); end
  def line; end
  def source; end
end
class Readapt::Location
  def file; end
  def initialize(file, line); end
  def line; end
  def match?(other); end
end
class Readapt::Thread
  def control; end
  def control=(arg0); end
  def frames; end
  def id; end
  def initialize(id); end
  def name; end
end
class Readapt::Thread::NullThread < Readapt::Thread
  def initialize; end
end
class Readapt::Frame
  def evaluate(code); end
  def initialize(location, binding_id); end
  def local(sym); end
  def local_id; end
  def locals; end
  def location; end
end
module Readapt::Monitor
  def self.pause(arg0); end
  def self.start(arg0); end
  def self.stop; end
end
class Readapt::Snapshot
  def binding_id; end
  def control; end
  def control=(arg0); end
  def depth; end
  def event; end
  def file; end
  def initialize(thread_id, binding_id, file, line, method_name, event, depth); end
  def line; end
  def method_name; end
  def thread_id; end
end
module Readapt::Finder
  def find(program); end
  def self.find(program); end
  def self.which(program); end
  def which(program); end
end
class Readapt::Debugger
  def attached?; end
  def clear_breakpoints(source); end
  def config(arguments, request); end
  def debug(snapshot); end
  def disconnect; end
  def file; end
  def frame(id); end
  def get_breakpoint(source, line); end
  def initialize(machine = nil); end
  def launched?; end
  def monitor; end
  def output(data, category = nil); end
  def run; end
  def self.run(&block); end
  def send_event(event, data, wait = nil); end
  def set_breakpoint(source, line, condition); end
  def set_original_args; end
  def set_program_args; end
  def shutdown; end
  def start; end
  def thread(id); end
  def threads; end
  include Observable
  include Readapt::Finder
end
module Readapt::Message
  def self.process(arguments, debugger); end
  def self.register(name, klass); end
end
class Readapt::Message::Base
  def arguments; end
  def body; end
  def debugger; end
  def initialize(arguments, debugger); end
  def run; end
  def self.run(arguments, debugger); end
  def set_body(hash); end
end
class Readapt::Message::Initialize < Readapt::Message::Base
  def run; end
end
class Readapt::Message::Launch < Readapt::Message::Base
  def run; end
end
class Readapt::Message::SetBreakpoints < Readapt::Message::Base
  def run; end
end
class Readapt::Message::SetExceptionBreakpoints < Readapt::Message::Base
end
class Readapt::Message::ConfigurationDone < Readapt::Message::Base
  def run; end
end
class Readapt::Message::Threads < Readapt::Message::Base
  def run; end
end
class Readapt::Message::StackTrace < Readapt::Message::Base
  def run; end
end
class Readapt::Message::Scopes < Readapt::Message::Base
  def run; end
end
class Readapt::Message::Continue < Readapt::Message::Base
  def run; end
end
class Readapt::Message::Variables < Readapt::Message::Base
  def object_reference; end
  def run; end
end
class Readapt::Message::Next < Readapt::Message::Base
  def run; end
end
class Readapt::Message::StepIn < Readapt::Message::Base
  def run; end
end
class Readapt::Message::StepOut < Readapt::Message::Base
  def run; end
end
class Readapt::Message::Disconnect < Readapt::Message::Base
  def run; end
end
class Readapt::Message::Attach < Readapt::Message::Base
  def run; end
end
class Readapt::Message::Pause < Readapt::Message::Base
  def run; end
end
class Readapt::Message::Evaluate < Readapt::Message::Base
  def run; end
end
class Readapt::Variable
  def empty?; end
  def enumerable?; end
  def initialize(name, object); end
  def name; end
  def no_references?; end
  def object; end
  def reference; end
  def show_class_for_value?; end
  def type; end
  def unstructured; end
  def value; end
end
module Readapt::Adapter
  def closing; end
  def format(result); end
  def opening; end
  def process(data); end
  def receiving(data); end
  def self.host(debugger); end
  def update(event, data); end
end
class Readapt::DataReader
  def initialize; end
  def parse_message_from_buffer; end
  def prepare_to_parse_message; end
  def receive(data); end
  def set_message_handler(&block); end
end
module Readapt::Breakpoints
  def self.clear; end
  def self.delete(arg0); end
  def self.match(arg0, arg1); end
  def self.set(arg0, arg1); end
end
class Readapt::Shell < Thor
end
